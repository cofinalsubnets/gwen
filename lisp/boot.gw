# top expression
(: prelude '(
  (: true -1 false 0 nilp (= 0) not nilp
     (atomp x) (nilp (twop x))
     (!= a b) (? (= a b) 0 -1)
     cons X car A cdr B null nilp
     (caar x) (A (A x)) (cadr x) (A (B x))
     (cdar x) (B (A x)) (cddr x) (B (B x))
     AA caar AB cadr BA cdar BB cddr
     inc (+ 1) dec (+ -1) :: (tset macros)
     (id x) x (const x y) x (co f g x) (f (g x))
     (flip f x y) (f y x) (diag f x) (f x x)
     (map f l) (? l (X (f (A l)) (map f (B l))))
     (foldl z f l) (? l (foldl (f z (A l)) f (B l)) z)
     (foldr z f l) (? l (f (A l) (foldr z f (B l))) z)
     (foldl1 f l) (foldl (A l) f (B l))
     (foldr1 f l) (foldr (last l) f (init l))
     (filter p l) (? l (: m (filter p (B l))
                        (? (p (A l)) (X (A l) m) m)))
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (each l f) (? l (, (f (A l)) (each (B l) f)))
     (ldel x l) (? (twop l) (? (= (A l) x) (B l) (X (A l) (ldel x (B l)))))
     (all f l) (? l (? (f (A l)) (all f (B l))) true)
     (any f l) (? l (? (f (A l)) true (any f (B l))))
     (cat a b) (foldr b X a)
     (assq x l) (? l (? (= x (AA l)) (A l) (assq x (B l))))
     (lidx x) ((: (f n l) (? (twop l) (? (= x (A l)) n (f (+ 1 n) (B l))) -1)) 0)
     (memq x) (any (= x))
     (zip a b) (? (twop a) (? (twop b) (X (X (A a) (A b)) (zip (B a) (B b)))))
     rev (foldl 0 (flip X))
     (part p) (foldr '(0) (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))
     (.. x) (, (. x) (putc 10) x)
     (llen l) (? (twop l) (+ 1 (llen (B l))))
     )
  (: (puts s) ((: (f n l) (? (= n l) s (, (putc (sget s n)) (f (+ n 1) l)))) 0 (slen s)))

  (:: 'L (foldr 0 (\ a l (X X (X a (X l 0))))))
  (:: '&& (\ l (: (and l) (? (B l) (X '? (X (A l) (X (and (B l)) 0))) (A l)) (? l (and l) -1))))
  (:: '|| (\ l (: (or l) (? l (: y (sym 0) (L ': y (A l) (L '? y y (or (B l)))))) (or l))))
  (:: ':- (\ a (X ': (cat (B a) (X (A a) 0)))))
  (:: '>>= (\ l (X (last l) (init l))))
  (:: '|> (foldl1 (\ m f (L f m ))))
  (:: '>=> (\ g (: y (sym 0) (L '\ y (foldl y (\ x f (L f x)) g)))))
  (:: '<=< (\ g (: y (sym 0) (L '\ y (foldr y (\ f x (L f x)) g)))))
  ) ; end prelude

  evaluator '(:- eval
    (scop par arg imp) (: t (tnew()) (, (tset t 'par par) (tset t 'arg arg) (tset t 'imp imp) t))
    anon (sym 0)
    (toplp c) (nilp (parof c))
    (parof c) (tget 0 c 'par)
    (stkof c) (tget 0 c 'stk)
    (argof c) (tget 0 c 'arg)
    (impof c) (tget 0 c 'imp)
    zget (tget 0)
    (arity c) (+ (llen (argof c)) (llen (impof c)))
    (thd0 r n) (poke i_ret (seek -1 (poke (arity r) (seek (+ 1 n) (thd (+ 2 n))))))
    (cpush c k v) (, (tset c k (X v (zget c k))) v)
    (import c v) (? (not (toplp c)) (cpush c 'imp v))
    (cpop c k) (: s (zget c k) (, (tset c k (B s)) (A s)))
    (cpeek c k) (A (zget c k))
    (em1 i k n) (poke i (seek -1 (k (+ 1 n))))
    (em2 i x k) (em1 i (em1 x k))
    (em_ap k n)
     (: j (k (+ 1 n))
      (? (= i_ret (peek j))
         (poke i_tap j)
         (poke i_ap (seek -1 j))))
    (em_apn n k m) (: j (k (+ 2 m))
     (? (= i_ret (peek j))
      (poke i_tapn (seek -1 (poke n j)))
      (poke i_apn (seek -1 (poke n (seek -1 j))))))
    imm (em2 i_imm)
    (cata_var c x ins j m) (:
     k (j (+ 2 m))
     (poke i_ref (seek -1 (poke (+ ins (stkidx c x)) (seek -1 k)))))
    (stkidx d x)
      (: imp  (impof d)
         ii (idx imp x)
       (? (<= 0 ii) ii
        (: ai (idx (argof d) x)
         (? (<= 0 ai) (+ (llen imp) ai)
                      -1))))
    (idx l i) (>>= l 0 (: (ii l n) (? l (? (= i (A l)) n (ii (B l) (inc n))) -1)))

    (eval x) (: top (scop 0 (L 0) 0) (ana top x (thd0 top) 0 0))

    (ana c x) (:- (? (symp x)  (ana_sym c x)
                     (atomp x) (imm x)
                               (ana_two c (A x) (B x)))
     (ana_apl_s n c b) (:
           (loop c b)
            (? (atomp b) id
             (: a1 (ana c (A b))
                a2 em_ap
                a3 (loop c (B b))
               (<=< a1 a2 a3)))
      _ (cpush c 'stk n)
      a (loop c b)
      _ (cpop c 'stk)
      a)

     (ana_ap c f b)  (co (ana c f) (ana_apl_s 0 c b))
     (ana_sym c x) (>>= c (: (ana_sym_r d)
      (? (nilp d) ; outside all lexical scopes?
          (: y (tget anon globals x) ; check global scope
           (? (!= y anon) (imm y) ; if it's there use that
            (, (import c x) ; if it's not there... do something
               (em2 i_free_variable x))))
        ; else...
       (: lam (zget d 'lam)
          stk (zget d 'stk)
          lfd (assq x lam)
        (? lfd ; local function def? ;; ana_sym_local_fn
             (: y (X x lam)
                arg (BB lfd)
                a1 (em2 i_lazy_bind y)
                a2 (ana_apl_s 0 c arg)
              (co a1 a2))
          ; else ...
          ; bound on stack by an inner let form?
         (&& (= c d) (memq x stk))
          (em2 i_ref (lidx x stk))
         ; bound on stack by an outer let form or function or closure?
         (? (memq x stk) 1 (<= 0 (stkidx d x)))
          (, (? (!= c d) (import c x))
             (cata_var c x (llen (stkof c))))
         ; else recur
         (ana_sym_r (zget d 'par)))))))

     (ana_two c a b) (:-
      (? (= a '` )  (imm (A b))
         (= a '? )  (ana_if  c b)
         (= a '\ )  (ana_lam c b)
         (= a ': )  (ana_let c b)
         (= a ', )  (ana_seq c b)
         (atomp b) (ana c a)
         (: m (zget macros a)
          (? m (ana c (m b))
               (ana_ap c a b))))

      ; ana_seq is recursive but pretty simple
      (ana_seq c x)
       (? (atomp x) (imm 0)
        (co (ana c (A x))
            (? (atomp (B x)) id
             (co (em1 i_drop1)
                 (ana_seq c (B x))))))

      ;ana_if is a bit complicated
      (ana_if c b) (:- (co (pop 'end) (co (ana_if_r b) (push 'end)))
       (pop y k n) (: j (k n) (, (cpop c y) j))
       (push y k n) (cpush c y (k n))
       (peek_end c k n) (: j (k (+ 2 n))
        dest (cpeek c 'end)
        (? (= i_ret (peek dest))
         (poke i_ret  (seek -1 (poke (peek (seek 1 dest)) (seek -1 j))))
         (poke i_jump (seek -1 (poke (cpeek c 'end)       (seek -1 j))))))

       (pop_alt c k n) (: j (k (+ 2 n))
        (poke i_cond (seek -1 (poke (cpop c 'alt) (seek -1 j)))))
       (ana_if_r b) (?
        (atomp b) (imm 0)
        (atomp (B b)) (co (ana c (A b))
                          (peek_end c))
        ; we want exact control over evaluation order here
        (: a0 (ana c (A b))
           a1 (pop_alt c)
           a2 (ana c (AB b))
           a3 (peek_end c)
           a4 (push 'alt)
           a5 (ana_if_r (BB b))
        (<=< a0 a1 a2 a3 a4 a5))))

      ; ana_lam is small because it uses ana_ll which ana_let also uses
      (ana_lam c b) (? (atomp b)     (imm 0)
                       (atomp (B b)) (ana c (A b))
                                     (ana c (ana_ll c 0 b)))
      ; ana_ll isn't too bad
      (ana_ll c imp exp) (:
       arg (init exp)
       x (last exp)
       d (scop c arg imp)
       k0 (ana d x (thd0 d))
       ar (arity d)
       k (trim ((? (> ar 1) (em2 i_curry ar) id) k0 0))
       (X k (zget d 'imp)))

      ; ana_let is the worst :[
      (ana_let c b) (:-
       (? (atomp b)     (imm 0)
          (atomp (B b)) (ana c (A b))
          (l1 0 0 (A b) (AB b) (BB b)))
       (lambp x) (? (twop x) (= '\ (A x)))
       (desug n d) (? (atomp n) (X n d)
                      (desug (A n) (X '\ (cat (B n) (L d)))))
       q (scop c (zget c 'arg) (zget c 'imp))
;       _ (tset c 'stk s) # FIXME should be adjusting this consistently elsewhere
       # l1 pass nom def and value expressions to l2
       ; l1 collects bindings and passes them with the body expression to l2
       (l1 noms defs nom def rest) (:
        nd1 (desug nom def)
        nom1 (A nd1) def1 (B nd1)
        noms1 (X nom1 noms) defs1 (X def1 defs)
        (? (atomp rest) (l2 noms1 defs1 nom1 rest) ; even case -- we lose that info here
           (atomp (B rest)) (l2 noms1 defs1 (A rest) rest)
           (l1 noms1 defs1 (A rest) (AB rest) (BB rest))))

       # l2 pass noms defs exp with revised lambda defs to l3
       ; l2 finds closures for all local functions and passes a lambda expression for the body to l3
       (l2 noms defs exp rest) (:- (l3 (rev noms) (rev defs) clams llam rest)
        lams (>>= 0 noms defs
              (: (b l n d) (? (atomp n) l
               (: ll (? (not (lambp (A d))) l (X
                                                 (X (A n)
                                                  (ana_ll q 0 (BA d))
                                                 )
                                               l))
                (b ll (B n) (B d))))))

        (set_car p x) (, (poke x (seek 2 p)) x) # don't do this :<
        (set_cdr p x) (, (poke x (seek 3 p)) x) # don't do this :<
        (cl n l l1 l2) (?
         l2 (? (? (!= l1 l2) (memq (AA l1) (BB (A l2))))
             (>>= n (BB (A l1)) (: (f n v)
                            (? v (: var ( (A v))
                                    vars ( (B (BA l2)))
                                    (? (memq var vars)
                                     (f n (B v))
                                     (, (set_cdr (BA l2) (X var vars))
                                        (f (+ 1 n) (B v)))))
                             (cl n l l1 (B l2)))))
             (cl n l l1 (B l2)))
         l1 (cl n l (B l1) l)
         n (close l)
         l)
        (close l) (cl 0 l l l)
        lnoms (map A lams)
        (lamdel cs) (flip map cs (\ ll (X (A ll) (X (AB ll) (foldl (BB ll) (flip ldel) lnoms)))))
        clams (lamdel (close lams))
        llam (X '\ (cat noms (L exp)))) ;; construct reversed lambda expression

       # l3 collect defs and apply
       (l3 noms defs clams llam rest) (:
         (loops n nds) (, (cpush c 'stk n) (loop nds))
         (loop nds) (? (nilp nds) id
          (: nd (A nds) n (A nd) d (B nd)
             ; this will now be the expression to evaluate
             d1 (? (lambp d)
                 (: qa (assq n clams)
                    x (ana_ll q (BB qa) (B d))
                  (, (set_cdr qa x)
                     x))
                 d)
             a1 (ana c d1)
             a2 (? (&& (toplp c) (atomp rest))
                   (em2 i_defglob n)
                   id)
              ; here is where to bind in global scope if toplp q and atomp rest
             a3 (loops n (B nds))
             (<=< a1 a2 a3)))
         _ (tset q 'lam clams)
         s0 (stkof c)
         n (llen noms)
         a1 (ana c llam)
         a2 (loops -1 (zip noms defs))
         a3 (? (> n 1) (em_apn n) em_ap)
         _ (tset c 'stk s0)
         (<=< a1 a2 a3))))))

; this does some initialization and then returns the main function
(: ; we can't use prelude yet here
   (go e a b) (? b (go e (e (A b)) (B b)) a)
   _ (tset globals 'evaluator evaluator)
   _ (tset globals 'prelude prelude)
   e0 ev
   _ (go e0 0 prelude)
   ex (e0 '(cat (A prelude) (L evaluator)))
   _ (tset globals 'ex ex)
   e1 (e0 evaluator)
;   _ (go e1 0 prelude)
   e2 (e1 evaluator)
   _ (tset globals '_ev ev)
   _ (tset globals 'eval e2)
   _ (tset globals 'ev e2)
    ; (each (tdel 0 globals) (cat '(peek poke seek macros thd globals) (filter (\ y (= "i_" (ssub (nom y) 0 2))) (tkeys globals))))
   (e2 '(\ fs ; we can use prelude in here
    (:- (? args       (procs prog (A args) (B args))
           (isatty 0) (repl prompt)
                      (reads 0))
      prog (A fs) args (B fs)
      prompt "    "
      (reads _) (: r (read 0) (? r (, (ev (A r)) (reads 0))))
      (repl p)  (: r (, (puts p) (read 0))
                 (? r (, (. (ev (A r))) (putc 10) (repl p))))
      (procs prog a as) (, (proc1 prog a) (? as (procs prog (A as) (B as))))
      (proc1 prog arg)
       (? (= arg "-h") (, (puts "usage: ") (puts prog) (each help putln))
          (= arg "-v") (, (puts prog) (puts " ") (putln version))
          (= arg "-r") (repl prompt)
          (each (readf arg) ev))
      (putln s) (, (puts s) (putc 10))
       help (L " [args]"
               " args:"
               "   -h   show this message"
               "   -v   show version"
               "   -r   start repl"
               " file   evaluate file"))))))
