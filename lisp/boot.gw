# top expression
(: prelude '(
  (: true -1 false 0 nilp (= 0) not nilp
     (atomp x) (nilp (twop x))
     (!= a b) (? (= a b) 0 -1)
     cons X car A cdr B null nilp
     (caar x) (A (A x)) (cadr x) (A (B x))
     (cdar x) (B (A x)) (cddr x) (B (B x))
     AA caar AB cadr BA cdar BB cddr
     inc (+ 1) dec (+ -1) :: (tset macros)
     (id x) x (const x y) x (co f g x) (f (g x))
     (flip f x y) (f y x) (diag f x) (f x x)
     (map f l) (? l (X (f (A l)) (map f (B l))))
     (foldl z f l) (? l (foldl (f z (A l)) f (B l)) z)
     (foldr z f l) (? l (f (A l) (foldr z f (B l))) z)
     (foldl1 f l) (foldl (A l) f (B l))
     (foldr1 f l) (foldr (last l) f (init l))
     (filter p l) (? l (: m (filter p (B l))
                        (? (p (A l)) (X (A l) m) m)))
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (each l f) (? l (, (f (A l)) (each (B l) f)))
     (ldel x l) (? (twop l) (? (= (A l) x) (B l) (X (A l) (ldel x (B l)))))
     (all f l) (? l (? (f (A l)) (all f (B l))) true)
     (any f l) (? l (? (f (A l)) true (any f (B l))))
     (cat a b) (foldr b X a)
     (assq x l) (? l (? (= x (AA l)) (A l) (assq x (B l))))
     (lidx x) ((: (f n l) (? (twop l) (? (= x (A l)) n (f (+ 1 n) (B l))) -1)) 0)
     (memq x) (any (= x))
     (zip a b) (? (twop a) (? (twop b) (X (X (A a) (A b)) (zip (B a) (B b)))))
     rev (foldl 0 (flip X))
     (part p) (foldr '(0) (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))
     (.. x) (, (. x) (putc 10) x)
     (llen l) (? (twop l) (+ 1 (llen (B l))))
     ) (:
     (puts s) ((: (f n l) (? (= n l) s (, (putc (sget s n)) (f (+ n 1) l)))) 0 (slen s)))
  (, (:: 'L (foldr 0 (\ a l (X X (X a (X l 0))))))
     (:: '&& (\ l (: (and l) (? (B l) (X '? (X (A l) (X (and (B l)) 0))) (A l)) (? l (and l) -1))))
     (:: ':- (\ a (X ': (cat (B a) (X (A a) 0)))))
     (:: '>>= (\ l (X (last l) (init l)))))
     (:: '|> (foldl1 (\ m f (L f m ))))
     (:: '>=> (\ g (: y (sym 0) (L '\ y (foldl y (\ x f (L f x)) g)))))
     (:: '<=< (\ g (: y (sym 0) (L '\ y (foldr y (\ f x (L f x)) g)))))
  (: eval (:
    (scop par arg imp) (: t (tnew()) (, (tset t 'par par) (tset t 'arg arg) (tset t 'imp imp) t))
    (eval x)
   (:- (ana top x (thd0 top) 0 0)
    anon (sym 0)
    top (scop 0 (L anon) 0)
    toplp (= top)
    (par e) (tget 0 e 'par)
    (stkof c) (zget c 'stk)
    zget (tget 0)
    (arity c) (+ (llen (zget c 'arg)) (llen (zget c 'imp)))
    (thd0 r n) (poke i_ret (seek -1 (poke (arity r) (seek (+ 1 n) (thd (+ 2 n))))))
    (cpush c k v) (, (tset c k (X v (zget c k))) v)
    (import c v) (? (!= top c) (cpush c 'imp v))
    (cpop c k) (: s (zget c k) (, (tset c k (B s)) (A s)))
    (cpeek c k) (A (zget c k))
    (em1 i k n) (poke i (seek -1 (k (+ 1 n))))
    (em2 i x k) (em1 i (em1 x k))
    imm (em2 i_imm)
    (cata_var c x ins j m) (:
     k (j (+ 2 m))
     (poke i_ref (seek -1 (poke (+ ins (stkidx c x)) (seek -1 k)))))
    (stkidx d x)
      (: imp  (zget d 'imp)
         arg  (zget d 'arg)
         ii (idx imp x)
         ai (idx arg x)
       (? (>= ii 0) ii
          (>= ai 0) (+ (llen imp) ai)
          -1))
    (ana c x) (:- (? (symp x)  (ana_sym c x)
                     (atomp x) (imm x)
                               (ana_two c (A x) (B x)))
     (ana_apl_s n c b) (:
           (loop c b) (,
            (? (atomp b) id
             (:
                a1 (ana c (A b))
                a2 (em1 i_ap)
                a3 (loop c (B b))

               (<=< a1 a2 a3))))

      _ (cpush c 'stk n)
      a (loop c b)
      _ (cpop c 'stk)
      a)

     (ana_ap c f b)  (:
      a1 (ana c f)
      a2 (ana_apl_s 0 c b)
      (<=< a1 a2))

     (ana_sym c x) (>>= c (:- ana_sym_r
      (idx l i) (>>= l 0 (: (ii l n) (? l (? (= i (A l)) n (ii (B l) (inc n))) -1)))
      (ana_sym_local_fn asq d) (,
       (: a1 (em2 i_lazy_bind (X (A asq) (zget d 'lam)))
          a2 (ana_apl_s 1 c (BB asq))
        (<=< a1 a2)))
      (ana_sym_stack_ref d) (,
       (? (nilp (= c d)) (import c x))
       (cata_var c x (llen (stkof c))))
      (ana_sym_local_def stack) (,
       (em2 i_ref (lidx x stack))
       )
      (ana_sym_free x) (,
       (: y (tget anon globals x)
          (? (!= y anon) (imm y)
          (, (import c x) (em2 i_free_variable x)))))
      (ana_sym_r d)
       (? (nilp d) (ana_sym_free x)
        (: y (assq x (zget d 'lam))
         (? y (ana_sym_local_fn y d)
          (? (&& (= c d) (memq x (zget d 'stk)))
              (ana_sym_local_def (zget d 'stk))
             (memq x (zget d 'stk)) (ana_sym_stack_ref d)
             (>= (stkidx d x) 0) (ana_sym_stack_ref d)
                                 (ana_sym_r (zget d 'par))))))))

     (ana_two c a b) (:- (? (= a '`)  (imm (A b))
                            (= a '?)  (ana_if  c b)
                            (= a '\)  (ana_lam c b)
                            (= a ':)  (ana_let c b)
                            (= a ',)  (ana_seq c b)
                            (atomp b) (ana c a)
                            (: m (zget macros a)
                             (? m (ana c (m b))
                                  (ana_ap c a b))))

      (ana_lam c b) (? (atomp b)     (imm 0)
                       (atomp (B b)) (ana c (A b))
                                     (ana c (ana_ll c 0 b)))
      (ana_ll c imp exp) (:
       arg (init exp)
       x (last exp)
       d (scop c arg imp)
       k0 (ana d x (thd0 d))
       ar (arity d)
       k (trim ((? (> ar 1) (em2 i_curry ar) id) k0 0))
       (X k (zget d 'imp)))

      (desug n d) (? (atomp n) (X n d)
                     (desug (A n) (X '\ (cat (B n) (L d)))))
      (lambp x) (? (twop x) (= '\ (A x)))

      (ana_let c b) (:-
       (? (atomp b)     (imm 0)
          (atomp (B b)) (ana c (A b))
          (l1 0 0 (A b) (AB b) (BB b)))
       q (scop c (zget c 'arg) (zget c 'imp))
;       _ (tset c 'stk s) # FIXME should be adjusting this consistently elsewhere
       # l1 pass nom def and value expressions to l2
       ; l1 collects bindings and passes them with the body expression to l2
       (l1 noms defs nom def rest) (:
        nd1 (desug nom def)
        nom1 (A nd1) def1 (B nd1)
        noms1 (X nom1 noms) defs1 (X def1 defs)
        (? (atomp rest) (l2 noms1 defs1 nom1 rest) ; even case -- we lose that info here
           (atomp (B rest)) (l2 noms1 defs1 (A rest) rest)
           (l1 noms1 defs1 (A rest) (AB rest) (BB rest))))

       # l2 pass noms defs exp with revised lambda defs to l3
       ; l2 finds closures for all local functions and passes a lambda expression for the body to l3
       (l2 noms defs exp rest) (:- (l3 rnoms rdefs clams llam rest)
        rnoms (rev noms)
        rdefs (rev defs)
        lams (>>= 0 noms defs
              (: (b l n d) (? (atomp n) l
               (: ll (? (not (lambp (A d))) l (X
                                                 (X (A n)
                                                  (ana_ll q 0 (BA d))
                                                 )
                                               l))
                (b ll (B n) (B d))))))

        (set_cdr p x) (, (poke x (seek 3 p)) x) # don't do this :<
        (cl n l l1 l2) (?
         l2 (? (? (!= l1 l2) (memq (AA l1) (BB (A l2))))
             (>>= n (BB (A l1)) (: (f n v)
                            (? v (: var ( (A v))
                                    vars ( (B (BA l2)))
                                    (? (memq var vars)
                                     (f n (B v))
                                     (, (set_cdr (BA l2) (X var vars))
                                        (f (+ 1 n) (B v)))))
                             (cl n l l1 (B l2)))))
             (cl n l l1 (B l2)))
         l1 (cl n l (B l1) l)
         n (close l)
         l)
        (close l) (cl 0 l l l)
        lnoms (map A lams)
        (lamdel cs) (flip map cs (\ ll (X (A ll) (X (AB ll) (foldl (BB ll) (flip ldel) lnoms)))))
        clams (lamdel (close lams))
        llam (X '\ (cat noms (L exp)))) ;; construct reversed lambda expression

       # l3 collect defs and apply
       (l3 noms defs clams llam rest) (:
         (loop_s n nds) (:
          _ (cpush c 'stk n)
;          _ (tset q 'stk s1)
          l (loop nds)
          l)
         (loop nds) (? (nilp nds) id
          (: nd (A nds) n (A nd) d (B nd)
             ; this will now be the expression to evaluate
             d1 (? (lambp d)
                 (: qa (assq n clams)
                    x (ana_ll q (BB qa) (B d))
                  (, (set_cdr qa x)
                     x))
                 d)
             a1 (ana c d1)
             a2 (? (&& (toplp c) (atomp rest))
                   (em2 i_defglob (last noms))
                   id)
              ; here is where to bind in global scope if toplp q and atomp rest
             a3 (loop_s n (B nds))
             (<=< a1 a2 a3)))
         _ (tset q 'lam clams)
         s0 (stkof c)
         n (llen noms)
         a1 (ana c llam)
         a2 (loop_s -1 (zip noms defs))
         a3 (? (> n 1) (em2 i_apn n) (em1 i_ap))
         _ (tset c 'stk s0)
         (<=< a1 a2 a3))) ; end ana_let

      (ana_seq c x)
       (? (atomp x) (imm 0)
        (co (ana c (A x))
            (? (atomp (B x)) id
             (co (em1 i_drop1)
                 (ana_seq c (B x))))))
      (ana_if c b) (:- (co (pop 'end) (co (ana_if_r b) (push 'end)))
       (pop y k n) (: j (k n) (, (cpop c y) j))
       (push y k n) (cpush c y (k n))
       (peek_end c k n) (: j (k (+ 2 n))
        dest (cpeek c 'end)
        (? (= i_ret (peek dest))
         (poke i_ret (seek -1 (poke (peek (seek 1 dest)) (seek -1 j))))
         (poke i_jump (seek -1 (poke (cpeek c 'end) (seek -1 j))))))

       (pop_alt c k n) (: j (k (+ 2 n))
        (poke i_cond (seek -1 (poke (cpop c 'alt) (seek -1 j)))))
       (ana_if_r b) (?
        (atomp b) (imm 0)
        (atomp (B b)) (co (ana c (A b))
                          (peek_end c))
        (: a0 (ana c (A b))
           a1 (pop_alt c)
           a2 (ana c (AB b))
           a3 (peek_end c)
           a4 (push 'alt)
           a5 (ana_if_r (BB b))
        (<=< a0 a1 a2 a3 a4 a5)))))))
   eval
    )))
  boot_script '
   (\ fs (:- (? args       (procs prog (A args) (B args))
                (isatty 0) (repl prompt)
                           (reads ()))

          prog (A fs) args (B fs)
          prompt "    "
          (reads l) (: r (read ()) (? r (, (ev 'ev (A r)) (reads l)) l))
          (repl p)  (: r (, (puts p) (read 0))
                     (? r (, (.. (ev 'ev (A r))) (repl p))))
          (procs prog a as) (, (proc1 prog a)
                               (? as (procs prog (A as) (B as))))
          (proc1 prog arg) (:-
           (? (= arg "-h") (, (puts "usage: ") (puts prog) (each help putln))
              (= arg "-v") (, (puts prog) (puts " ") (putln version))
              (= arg "-r") (repl prompt)
              ((: (evals x) (? x (, (ev 'ev (A x)) (evals (B x))))) (readf arg)))
           (putln s) (, (puts s) (putc 10))
           help (L " [args]"
                   " args:"
                   "   -h   show this message"
                   "   -v   show version"
                   "   -r   start repl"
                   " file   evaluate file"))))

(: (go a b) (? b (go (ev 'ev (A b)) (B b)) a)
 (, (go 0 prelude)
    (tset globals 'prelude prelude)
    ; (each (tdel 0 globals) (cat '(peek poke seek macros thd globals) (filter (\ y (= "i_" (ssub (nom y) 0 2))) (tkeys globals))))
    (ev 'ev boot_script)
 ))

))
