#include "la.h"
// function functions
//
// functions are laid out in memory like this
//
// *|*|*|*|*|*|?|0|^
// * = function pointer or inline value
// ? = function name / metadata (optional)
// 0 = null
// ^ = pointer to head of function
//
// this way we can support internal pointers for branch
// destinations, return addresses, etc, while letting
// the garbage collector always find the head.
//
// two easy potential optimizations are:
// - add a tail pointer to the start of the function,
//   so GC can find the head quickly (since often we
//   won't have an internal pointer)
// - tag the tail/head pointers instead of using a null
//   sentinel (but then the C compiler would need to
//   align functions)

la_fn ini_mo(void *_, size_t len) {
  la_fn k = _;
  la_fn_tag t = (la_fn_tag) (k + len);
  t->null = NULL, t->head = k;
  return k; }

// allocate a thread
la_fn mkmo(la_carrier v, size_t n) {
  la_fn k = cells(v, n + wsizeof(struct tl));
  return k ? ini_mo(k, n) : k; }

// get the tag at the end of a function
la_fn_tag motag(la_fn k) {
  while (G(k)) k = F(k);
  return (la_fn_tag) k; }

// instructions for the internal compiler
// initialize a function
Vm(hom_f) {
  ArityCheck(1);
  size_t len = getnum(fp->argv[0]);
  Have(len + wsizeof(struct tl));
  mo k = setw(ini_mo(hp, len), nil, len);
  hp += len + wsizeof(struct tl);
  return ApC(ret, (ob) (k + len)); }

// trim a function after writing out code
Vm(hfin_f) {
  ArityCheck(1);
  xp = fp->argv[0];
  Check(homp(xp) && G(xp) != disp);
  motag((mo) xp)->head = (mo) xp;
  return ApC(ret, xp); }

// emit data
Vm(poke_f) {
  ArityCheck(2);
  Check(homp(fp->argv[1]));
  mo k = (mo) fp->argv[1] - 1;
  G(k) = (vm*) fp->argv[0];
  return ApC(ret, (ob) k); }

// frameless
Vm(poke) {
  mo k = (mo) *sp++ - 1;
  G(k) = (vm*) xp;
  return ApN(1, (ob) k); }

// read data from a thread (be sure it's really data!)
Vm(peekx_f) {
  ArityCheck(1);
  xp = fp->argv[0];
  Check(homp(xp));
  return ApC(ret, (ob) G(xp)); }

// thread pointer arithmetic -- not bounds checked!
Vm(seek_f) {
  ArityCheck(2);
  Check(homp(fp->argv[0]));
  ip = (mo) fp->argv[0];
  xp = getnum(fp->argv[1]);
  return ApC(ret, (ob) (ip + xp)); }

// dispatch a data thread
// TODO maybe we could do this with closures instead?
Vm(disp) { return ApC(((mtbl) GF(ip))->does, xp); }

// closure functions
//
// pop some things off the stack into an array.
Vm(take) {
  ob n = getnum((ob) GF(ip));
  Have(n + wsizeof(struct tl));
  mo k = ini_mo(cpyw_r2l(hp, sp, n), n);
  hp += n + wsizeof(struct tl);
  return ApN(2, (ob) k); }

// set the closure for this frame
static Vm(setclo) { return
  fp->clos = (ob*) GF(ip),
  ApY(G(FF(ip)), xp); }

Vm(ccl) {
  Have(3 + wsizeof(struct tl));
  mo k = ini_mo(hp, 3);
  hp += 3 + wsizeof(struct tl);
  G(k) = setclo;
  GF(k) = (vm*) xp;
  G(FF(k)) = GF(ip);
  return ApN(2, (ob) k); }

// finalize function instance closure
static Vm(genclo1) { return
  G(ip) = setclo,
  GF(ip) = (vm*) xp,
  ApY(ip, xp); }

// this function is run the first time a user
// function with a closure is called. its
// purpose is to reconstruct the enclosing
// environment and call the closure constructor
// thread generated by the compiler. afterwards
// it overwrites itself with a special jump
// instruction that sets the closure and enters
// the function.

struct clo_env {
  mo cons;
  ob loc, *clo, argc, argv[]; };

static Vm(genclo0) {
  struct clo_env *ec = (void*) GF(ip);
  size_t adic = getnum(ec->argc);
  Have(wsizeof(struct sf) + adic + 1);
  sf subd = fp;
  G(ip) = genclo1;
  sp = (ob*) (fp = (sf) (sp - adic) - 1);
  cpyw_r2l(fp->argv, ec->argv, adic);
  fp->retp = ip;
  fp->subd = subd;
  fp->argc = adic;
  fp->clos = (ob*) ec->clo;
  ob loc = ec->loc;
  if (!nilp(loc)) *--sp = loc;
  return ApY(ec->cons, xp); }

// the next few functions create and store
// lexical environments.
static Vm(enclose) {
  size_t
    thd_len = 3 + wsizeof(struct tl),
    env_len = wsizeof(struct clo_env) + fp->argc + wsizeof(struct tl);
  Have(env_len + thd_len);
  ob codeXcons = (ob) GF(ip); // pair of the compiled thread & closure constructor
  ob *block = hp;
  hp += env_len + thd_len;

  struct clo_env *env = (void*)
    ini_mo(block, wsizeof(struct clo_env) + fp->argc); // holds the closure environment & constructor
  env->cons = (mo) B(codeXcons);
     // TODO get closure out of stack frame; configure via xp
  env->loc = nilp(xp) ? xp : ((ob*)fp)[-1];
  env->clo = fp->clos;
  env->argc = putnum(fp->argc);
  cpyw_r2l(env->argv, fp->argv, fp->argc);

  mo thd = ini_mo(block + env_len, 3); // the thread that actually gets returned
  G(thd) = genclo0;
  GF(thd) = (vm*) env;
  G(FF(thd)) = (vm*) A(codeXcons);

  return ApN(2, (ob) thd); }

// these pass the locals array to encl in xp
// TODO do the same thing with the closure ptr
Vm(encl1) { return ApC(enclose, putnum(1)); }
// FIXME if there are no locals we don't need to defer closure construction!
Vm(encl0) { return ApC(enclose, putnum(0)); }

// try to get the name of a function
ob hnom(la v, mo x) {
  if (!livep(v, (ob) x)) return nil;
  vm *k = G(x);
  // closures get special treatment
  if (k == setclo || k == genclo0 || k == genclo1)
    return hnom(v, (mo) G(FF(x)));
  ob n = ((ob*) motag(x))[-1];
  // this is a little hairy! basically we assume that if the
  // last thing in a thread before the tail is a data object,
  // then that's the name.
  return homp(n) && livep(v, n) && G(n) == disp ? n : nil; }
