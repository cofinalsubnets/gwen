# lisa
LISt Action

## build / install
are you on linux? `make` will probably work. otherwise, see
`Makefile` for the suggested compiler flags.

## syntax

lisa is borderline unstable.

special forms compared to scheme:

| scheme                     |             |
|----------------------------|-------------|
|`(begin a b)`               |`(, a b)`    |
|`(lambda _ #f)`             |`(\)`        |
|`(lambda _ x)`              |`(\ x)`      |
|`(lambda (a b) c)`          |`(\ a b c)`  |
|`(begin (define a b) a)`    |`(: a b)`    |
|`(letrec ((a b)) c)`        |`(: a b c)`  |
|`(cond (a b) (#t #f))`      |`(? a b)`    |
|`(cond (a b) (#t c))`       |`(? a b c)`  |
|`(cond (a b) (c d) (#t #f))`|`(? a b c d)`|
|`'x`                        |`'x`         |

etc.

- `()` = `#f` = `0`
- numbers may take a C-style radix in `{b=2,o=8,d=10,z=12,x=16}`
- strings delimited by `"` which can be escaped with a backslash

## code examples

### a quine
```lisp
((\ - (L - (L ` -))) '(\ - (L - (L ` -))))
```

### hyperoperation sequence
```lisp
(: (hy x n y) ( ? (~ n) (+ x y) (~ y) 1
 (hy x (- n 1) (hy x n (- y 1)))))
```

### church numerals

church numerals display natural numbers as elements of an abelian
monoid `N = zero + succ N`. hyperoperations appear as complexity
classes of self-actions of `N` via `M`, the monoid of endomorphisms on
`N` generated by `succ`. by construction, `M` is `N`'s image under
`succ`, and it forms a second abelian monoid under `one = succ zero`.
the fundamental theorem of arithmetic maps `N` onto `M` through the
factorizing homomorphism `f` whose kernel is `{ zero, one }`.

this paints a dramatic picture. when the polymorphism `f` floods `N`,
the receding waters reveal `M`, having lost its former identity, yet
holding a second within its nature, as if by chance. a rainbow appears:
a bridge back to the origin made out of `M`'s infinite generators. the
bridge is endless, and the toll to pass is unlimited attention paid to
the smeared image we now possess.

```lisp
(:
 ; zero is the constant function at the identity function
 zero (\ (\ - -))
 ; a successor applies its argument then yields to its predecessor
 (((succ f) g) h) ((f g) (g h))

 one (succ zero) ; \ f -> f = identity
 two (succ one) ; \ f -> f . f = square
 three (succ two) ; \ f -> f . f . f = cube 

 ; other operations follow from succ

 ((add g) f)         ; the monoid on N
  ((f succ) g)       ; \ g f x -> f x . g x
 ((mul g) f)         ; the monoid on End(N)
  ((f (add g)) zero) ; \ g f x -> f (g x)

 ; the rest are iterations of the "up arrow" map
 (((up op) g) f) ((f (op g)) one)
 pow (up mul) ; exponentiation ; \ f -> f = one
 tet (up pow) ; tetration, etc.

 (C n) (? n (succ (C (- n 1))) zero) ; ℕ->⛪
 (N c) ((c (\ x (+ x 1))) 0))        ; ⛪->ℕ

(: (/p m n) (~ (% m n))
   (fizzbuzz m)
    ((\ (+ m 1)) (. (?
     ; TODO division in ⛪
     (/p m 15) 'fizzbuzz
     (/p m 5)  'buzz
     (/p m 3)  'fizz
     m)))
 ((((pow ((mul ((add three) two)) two)) two) fizzbuzz) 1))
```
