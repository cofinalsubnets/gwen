;; here's some functions for doing tests with
(: test (\ n v (. (? v 'ok 'NO) n)))

(: type (\ x (?
  (homp x) 'hom
  (nump x) 'num
  (symp x) 'sym
  (twop x) 'two
  (strp x) 'str
  (tblp x) 'tbl
           'nil)))

;; here's some data constructors
(: li (\ . . .) ; dot only has special meaning following another argument, which can be dot
   ++ (\ a b(?(twop a)(::(*: a)(++(:* a)b))b)) ; append
   iota (\ n x .
    (: iota.l (\ m n (? (< m n) (:: m (iota.l (+ m 1) n))))
     (? (nilp x) (iota.l 0 n) (iota.l n (*: x)))))
   rho (\ n xs .
    (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
     (?(> n 0)(rho.l n xs)))))

; hurray a new language
(: quine ((\ q ((ev q) q)) '(\ i (li i (li '` i))))
 (test 'ev-q (= (ev quine) quine)))

(: list-len (\ l (? (twop l) (+ 1 (list-len (:* l))) 0))
   de-str (\ s
     (: de-str.l (\ s n
        (? (= n (str-len s)) ()
           (:: (str-get s n) (de-str.l s (+ n 1)))))
        (de-str.l s 0))))

; strings are supposed to work
(test 'strings (&&
  (: l (de-str "hello person")
     (&& (= 12 (list-len l)) (= (*: l) 104)))
  (= "a" (str 97))
  (= "asdf" "asdf")
  (nilp (= "asdf" "asd"))
  (= "" (str 0 0 2 0))))

; here's a function for iterating over ranges
(: from (\ m n f (? (< m n) (, (f m) (from (+ m 1) n f)))))

; hash tables are mysterious
(: hasht (\ n
 (: d (tbl) (,(from 0 (+ n 1) (\ m (tbl-set d m m)))
              (tbl-get d n))))
 (test 'hashes (= 99 (hasht 99))))


(test 'continuations
  ;; grow the call stack then call a continuation
  (: loop (\ m n c (? (= m n) (c m) (, (loop (+ 1 m) n c) m)))
    (= 12 (ccc (\ k (loop 0 12 k))))))

(test 'closures
  ;; if the compiler gets too smart we'll need a better test.
  (: math (\ x y z
     (: a(\ n(\ m((i +)((i *)m n)z)))
        b(\ f(\ x(f x)))
        i(\ x x)
        ((b(a x))y)))
    (= 22 (math 4 5 2))))

(: id (\ x x)
  (test 'user-functions
    (&& (= 36 ((id ap) * (rho 2 1 2 3)))
        (= 3  ((id &&) 1 2 3))
        (= 15 ((id +) 1 2 3 4 5))
        (= 1  ((id ||) 1 2 3)))))

(: box (:: 0 ())
   get *: set *!
   ct (\ x (,(set box (+ 1 (get box))) x))
   (test 'shortcut-eval
     (&& (&& (nilp (&& (ct 1) (ct 2) (ct ()) (ct 3)))
             (= (get box) 3))
         (&& (|| (ct ()) (ct ()) (ct 1) (ct 2))
             (= (get box) 6)))))

(: fib (\ n ;; double recursive fibonacci function
    (? (< n 3) 1 (+ (fib (- n 1)) (fib (- n 2)))))
   ack (\ m n ;; ackermann function
    (? (< m 1) (+ n 1)
     (ack (- m 1) (? (> n 0) (ack m (- n 1)) 1))))
   (, (test 'fib32 (= 2178309 (fib 32)))
      (test 'ack3,9 (= 4093 (ack 3 9)))))


(: emm (\ f x k ((\ f x k (, (f k x) k)) f x (hom-seek k -1)))
   emi (\ i k (emm hom-set-i i k))
   emx (\ x k (emm hom-set-x x k))
   hom-fin (\ k (: .hf (\ j k (? (= 0 (hom-get-i k))
                                 (hom-set-x (hom-seek k 1) j)
                                 (.hf j (hom-seek k 1))))
                   (.hf k k))))
(: map (\ f x (? (twop x) (:: (f (*: x)) (map f (:* x)))))
   foldl(\ z f x (? (twop x) (foldl (f z (*: x)) f (:* x)) z))
   foldr (\ z f x (? (twop x) (f (*: x) (foldr z f (:* x))) z))
   foldl1 (\ f x (foldl (*: x) f (:* x)))
   foldr1  (\ f x (? (twop (:* x)) (f (*: x) (foldr1 f (:* x)))
                                   (*: x)))
   each (\ x f (? x (,(f (*: x)) (each (:* x) f))))

   -> (\ x f (f x))
   at (\ l n (? (< n 1) (*: l) (at (:* l) (- n 1))))
   atn (\ n (\ l (at l n)))
   flip (\ f (\ x y (f y x)))
   snoc  (\ l x (? (twop l) (:: (*: l) (snoc (:* l) x))
                            (:: x l)))
   idx (\ l x
    ((: .l (\ l x n (? (twop l) (? (= x (*: l)) n (.l (:* l) x (+ n 1))) -1)))
     l x 0))
   len (\ l (? (twop l) (+ 1 (len (:* l))) 0)))

(test 'functionals
  (&& (= (foldr 1 + (li 2 3))
         (foldr1 + (li 1 2 3))
         (foldl 1 + (li 2 3))
         (foldl1 + (li 1 2 3)))
      (= (li 1 2 3)
         (map (\ x (+ 1 x)) (iota 3))
         (snoc ((flip snoc) 2 (li 1)) 3)
         (foldr () :: (iota 1 4)))))

(: ; ok now let's port the compiler
 env (\ a p n vs
  (: .l (\ a n ;; lol what is this thing
         (? (twop a)
             (? (&& (twop (:* a)) (= '. (*: (:* a))))
                 (:: (- (+ n 1)) (li (*: a)))
                (-> (.l (:* a) (+ n 1)) (\ r
                 (:: (*: r) (:: (*: a) (:* r))))))
            (:: n a)))
       (-> (.l a 0) (\ b (: d (tbl)
          (, (tbl-set d
               'arg (:* b) 'loc ()
               'clo ()     'par p
               'lam (tbl)  'nom n
               'val vs  'sig (*: b))
             d))))))
 gtk (\ k (\ d v . (?
  (nilp v) (tbl-get d k)
           (tbl-set d k (*: v)))))
 e-arg (gtk 'arg) e-loc (gtk 'loc)
 e-clo (gtk 'clo) e-par (gtk 'par)
 e-lam (gtk 'lam) e-nom (gtk 'nom)
 e-val (gtk 'val) e-sig (gtk 'sig)
 e-s1  (gtk 's1)  e-s2  (gtk 's2)
 inst (\ e m i k (emi i (k e (+ m 1))))
 insx (\ e m i x k (emi i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x k))
 cev  (\ e m x k ((? (twop x) c2 (symp x) cy imm) e m x k))

 cy (\ e m x k (?                      ; this is weird sorry
  (tbl-has (e-val e) x)                ; the C version has a lot of reassigning variables
   (imm e m (tbl-get (e-val e) x) k) ; and that behavior is unstable right now
  (toplp e)
   (late e m x (e-val e) k)
  (< -1 (: a (idx (e-lams e) x)))
   (late e m x (e-val e) k)
  (< -1 (: b (idx (e-loc e) x)))
   (imx e m i-locn b k)
  (< -1 (: c (idx (e-arg e) x)))
   (imx e m i-argn c k)
  (< -1 (: d (idx (e-clo e) x)))
   (imx e m i-clon d k)
  (-> (look (e-par e) x) (\ q
   (-> (*: q) (\ r (?
    (= q 'here) (imm e m (:* q) k)
    (= q 'wait) (late e m x (:* q) k)
    (-> (len (e-clo e)) (\ y
     (,(e-clo e (snoc (e-clo e) x)
       (imx e m i-clon y))))))))))))

 c2 (\ e m x k (-> (*: x) (\ z (?
  (= z '`) (-> (:* x) (\ y (imm e m (? (twop y) (*: y)) k)))
  (= z '?) (cco e m x k)
  (= z ':) (cde e m x k)
  (= z '\) (cla e m x k)
  (= z ',) (cse e m x k)
           (cap e m x k)))))
 toplp (\ e (nilp (e-par e)))
 look (\ e y (?
  (tbl-has (e-val e) y)    (li 'here (tbl-get (e-val e) y))
  (toplp e)                (li 'wait (e-val e))
  (< -1 (idx (e-lam e) y)) (li 'wait (e-val e))
  (< -1 (idx (e-loc e) y)) (li 'loc e)
  (< -1 (idx (e-arg e) y)) (li 'arg e)
  (< -1 (idx (e-clo e) y)) (li 'clo e)
                           (look (e-par e) y)))
 init (\ l (? (twop (:* l)) (:: (*: l) (init (:* l)))))
 last (\ l (? (twop (:* l)) (last (:* l)) (*: l)))
 t-hom 0 t-num 1 t-two 2 t-tup 3 t-oct 4
 t-tbl 5 t-sym 6 t-nil 7 t-none 8
 consumes (\ h (-> (hom-get-i h) (\ i
  (? (= i i-tchom) t-hom
     (= i i-tcnum) t-num
     (= i i-tctwo) t-two
                   t-none))))
 late (\ e m x d k (-> (k e (+ m 2)) (\ h
  (-> (consumes h) (\ t
   (-> (? (= t t-none) h (hom-seek h 1)) (\ h
    (emi i-lbind (emx (:: t (:: d x)) h)))))))))

 cap (\ e m x k
  ((: cca (\ e m x k (-> (k e (+ m 2)) (\ q (?
       (nilp (= i-ret (hom-get-i q))) (emi i-call (emx x q))
       (= x (len (e-arg e)))          (emi i-loop q)
                                      (emi i-rec (emx x q))))))
      capi (\ e m x k
            (? (nilp x) (k e m)
             (capi e m (:* x) (\ e m
              (cev e m (*: x) (\ e m (inst e m i-push k))))))))
   e m (:* x) (\ e m
    (cev e m (*: x) (\ e m
     (cca e m (len (:* x)) k))))))

 cse (\ e m x k (,
  (: cser (\ e m x k (?
      (nilp x) (k e m)
               (cev e m (*: x) (\ e m
                (cser e m (:* x) k))))))
  (? (:* x) (cser e m (:* x) k)
            (imm e m () k))))

 cde (\ e m x k (,
  (: desug (\ d (li (li '\ (li ', (init d) (last d)))))
     cder (\ e m x k (?
      (nilp x) (k e m)
               (cev e m (*: (:* x)) (\ e m
                (cdeb e m (*: x) (\ e m
                 (cder e m (:* (:* x)) k)))))))
     cdeb (\ e m x k (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (e-loc e) x) k))))
  (?  (nilp (:* x))            (imm e m nil k)
      (= 1 (% (len (:* x)) 2)) (cev e m (desug x) k)
                               (cder e m (:* x) k))))

 ccopre (\ e m k (-> (k e m) (\ k
  (*: (e-s2 e (:: k (e-s2 e)))))))

 cco (\ e m x k (,
  (: ccopreant (\ e m k (-> (k e (+ m 2)) (\ k
      (-> (emi i-branch (emx (*: (e-s1 e)) k)) (\ k
       (, (e-s1 e (:* (e-s1 e))) k))))))
     ccoprecon (\ e m k (-> (k e (+ m 2)) (\ x
      (-> (*: (e-s2 e)) (\ k
       (: i (hom-get-i k)
        (? (= i i-ret) (emi i x)
         (emi i-jump
          (emx (? (= i i-jump) (hom-get-x (hom-seek k 1)) k) x)))))))))
     ccopostcon (\ e m k (-> (k e m) (\ k
      (*: (e-s1 e (:: k (e-s1 e)))))))
     ccor (\ e m x k (?
      (nilp x) (ccor e m (:: x x) k)
      (nilp (:* x)) (cev e m (*: x) (\ e m (ccoprecon e m k)))
      (cev e m (*: x) (\ e m
       (ccopreant e m (\ e m
        (ccor e m (:* (:* x)) (\ e m
         (ccopostcon e m (\ e m
          (cev e m (*: (:* x)) (\ e m
           (ccoprecon e m k))))))))))))))
  (? (nilp (:* x)) (imm e m nil k)
   (-> (ccor e m (:* x) (\ e m (ccopre e m k))) (\ k
    (, (e-s2 e (:* (e-s2 e))) k))))))
 
 ltu (\ e n l (,
  (: m (:* l)
     n (? m m (:: m m))
     f (env (init n) e n (tbl)))
  (compose f (last n))))

 compose (\ e x (,
  (scan e x)
  (resolve e)
  (-> (c_ev e 4 x ini) (\ k (,
   (-> (? (= 0 (: i (llen (e-loc e)))) k
        (emi i-prel (emx i k))) (\ k
    (-> (hom-fin (?
         (> (: i (e-sig e)) 0) (emi i-arity (emx i k))
         (< i 0) (emi i-vararg (emx (- (- i) 1) k))
         k)) (\ k
     (? (e-clo e) (:: (e-clo e) k) k))))))))))

 scan (\ e x (,
  (: scandef (\ e x (?
      (nilp x) 1
      (nilp (:* x)) ()
      (-> (scandef e (:* (:* x))) (\ r 
       (, (? r (scandefadd e (*: x) (*: (:* x))))
          r)))))
     mcar (\ x (? x (*: x)))
     addloc (\ e y (e-loc e (:: y (e-loc e))))

     scandefadd (\ e y x (,
      (? (symp x) (addloc e y)
         (twop x) (-> (*: x) (\ z (?
          (= z '`) (tbl-set (e-val e) y (mcar (:* x)))
          (= z '\) (, (tbl-set (e-lam e) y x) (addloc e y))
          (addloc e y))))
         (tbl-set (e-val e) y x))
      (scan e x))))

  (?
   (|| (nilp (twop x)) (= (*: x) '\) (= (*: x) '`)) ()
   (= (*: x) ':) (scandef e (:* x))
   (each x (\ x (scan e x))))))
  
 t-nom (\ t (?
  (= t t-hom) 'hom
  (= t t-num) 'num
  (= t t-two) 'two
  (= t t-tup) 'tup
  (= t t-oct) 'str
  (= t t-tbl) 'tbl
  (= t t-sym) 'sym
  (= t t-nil) 'nil))

 type-err (\ h w (fail
  (li 'type-error ': (t-nom h) 'for (t-nom w))))
 arity-err (\ h w (fail
  (li 'arity-error ': h 'of w)))
 tc (\ t h
  (-> (consumes h) (\ u
   (? (= t u) (tc t (hom-seek h 1))
    (? (= u t-none) h
     (type-err t u))))))
 produce (\ e m t k (tc t (k e (+ m 2))))
 cla (\ e m x k
  (-> (produce e m t-hom (\ e m (k e (+ m 2)))) (\ k
   (-> (ltu e () x) (\ x (?
    (homp x) (emi i-immv (emx x k))
             (emi (? (|| (toplp e) (nilp (e-loc e))) i-encln i-encll)
                  (emx (claclo e x) k))))))))

 ini (\ e m (insx e m i-ret (e-nom e) (\ e m (hom m))))
 ana (\ x (cev (env () () () (ns)) 0 x ini)))

(test 'get-set (= (li 1) (: d (tbl) (e-s1 d (:: 1 (e-s1 d))))))
(test 'de-scan (: e (env () () () (tbl)) (,
 (scan e '(: a 1 b (+ a a) f (\)))
 (&& (= (tbl-get (e-val e) 'a) 1)
     (= (e-loc e) '(b f))))))
(test 'comp-em (= 3 ((emi i-immv (emx 3 (emi i-ret (hom 3)))))))
(test 'comp-qt (-> (li 1) (\ y (= y ((ana (li '` y)))))))
(test 'comp-ap (= 6 ((ana (li + 1 2 3)))))
(test 'comp-sq (: box (li 0) inc (\(*! box (+ 1 (*: box))))
 (= 3 ((ana (li ', (li inc) (li inc) (li inc)))))))
(test 'comp-de
 (-> 123 (\ x
  (-> ((ana (li ': '_123 x))) (\ y
   (-> _123 (\ z (= 123 x y z))))))))
(test 'comp-sy (= _123 ((ana '_123))))
(test 'comp-co (&& (= 1 ((ana '(? () 0 1))));false
                   (= 0 ((ana '(? 1 0 ()))));true
                   (nilp ((ana '(? () 1))));even
                   (= 1 ((ana '(? () (? () 1 0);nested
                                     (? () 0 1)))))))
