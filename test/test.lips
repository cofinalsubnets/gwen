;; here's some functions for doing tests with
(: test (\ n v (. (? v 'ok 'NO) n)))

(: type (\ x (?
  (homp x) 'hom
  (nump x) 'num
  (symp x) 'sym
  (twop x) 'two
  (strp x) 'str
  (tblp x) 'tbl
           'nil)))

;; here's some data constructors
(: li (\ . . .) ; dot only has special meaning following another argument, which can be dot
   ++ (\ a b(?(twop a)(::(*: a)(++(:* a)b))b)) ; append
   iota (\ n x .
     (: .i (\ m n (? (< m n) (:: m (.i (+ m 1) n))))
       (? (nilp x) (.i 0 n) (.i n (*: x)))))
   rho (\ n xs .
     ;; like in APL
     ;; (rho 0 1 2) = ()
     ;; (rho 1 1 2) = (li 1 2)
     ;; (rho 2 1 2) = (li 1 2 1 2)
     ;; (rho 2 (rho 2 0)) = (li (li 0 0) (li 0 0))
     (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
       (?(> n 0)(rho.l n xs)))))

; hurray a new language
(: quine ((\ q ((ev q) q)) '(\ i (li i (li '` i))))
 (test 'ev-q (= (ev quine) quine)))

(: list-len (\ l (? (twop l) (+ 1 (list-len (:* l))) 0))
   de-str (\ s
     (: de-str.l (\ s n
        (? (= n (str-len s)) ()
           (:: (str-get s n) (de-str.l s (+ n 1)))))
        (de-str.l s 0))))

; strings are supposed to work
(test 'strings (&&
  (: l (de-str "hello person")
     (&& (= 12 (list-len l)) (= (*: l) 104)))
  (= "a" (str 97))
  (= "asdf" "asdf")
  (nilp (= "asdf" "asd"))
  (= "" (str 0 0 2 0))))

; here's a function for iterating over ranges
(: from (\ m n f (? (< m n) (, (f m) (from (+ m 1) n f)))))

; hash tables are mysterious
(: hasht (\ n
  (: d (tbl) (, (from 0 (+ n 1) (\ m (tbl-set d m m)))
                (tbl-get d n))))
  (test 'hashes (= 99 (hasht 99))))


(test 'continuations
  ;; grow the call stack then call a continuation
  (: loop (\ m n c (? (= m n) (c m) (, (loop (+ 1 m) n c) m)))
    (= 12 (ccc (\ k (loop 0 12 k))))))

(test 'closures
  ;; if the compiler gets too smart we'll need a better test.
  (: math (\ x y z
     (: a(\ n(\ m((i +)((i *)m n)z)))
        b(\ f(\ x(f x)))
        i(\ x x)
        ((b(a x))y)))
    (= 22 (math 4 5 2))))

(: id (\ x x)
  (test 'user-functions
    (&& (= 36 ((id ap) * (rho 2 1 2 3)))
        (= 3  ((id &&) 1 2 3))
        (= 15 ((id +) 1 2 3 4 5))
        (= 1  ((id ||) 1 2 3)))))

(: box (:: 0 ())
   get *: set *!
   ct (\ x (,(set box (+ 1 (get box))) x))
   (test 'shortcut-eval
     (&& (&& (nilp (&& (ct 1) (ct 2) (ct ()) (ct 3)))
             (= (get box) 3))
         (&& (|| (ct ()) (ct ()) (ct 1) (ct 2))
             (= (get box) 6)))))

(: fib (\ n ;; double recursive fibonacci function
    (? (< n 3) 1 (+ (fib (- n 1)) (fib (- n 2)))))
   ack (\ m n ;; ackermann function
    (? (< m 1) (+ n 1)
     (ack (- m 1) (? (> n 0) (ack m (- n 1)) 1))))
   (, (test 'fib32 (= 2178309 (fib 32)))
      (test 'ack3,9 (= 4093 (ack 3 9)))))


(: emm (\ f x k ((\ f x k (, (f k x) k)) f x (hom-seek k -1)))
   emi (\ i k (emm hom-set-i i k))
   emx (\ x k (emm hom-set-x x k))
   hom-fin (\ k (: .hf (\ j k (? (= 0 (hom-get-i k))
                                 (hom-set-x (hom-seek k 1) j)
                                 (.hf j (hom-seek k 1))))
                   (.hf k k))))
(: map (\ f x (? (twop x) (:: (f (*: x)) (map f (:* x)))))
   foldl(\ z f x (? (twop x) (foldl (f z (*: x)) f (:* x)) z))
   foldr (\ z f x (? (twop x) (f (*: x) (foldr z f (:* x))) z))
   foldl1 (\ f x (foldl (*: x) f (:* x)))
   foldr1  (\ f x (? (twop (:* x)) (f (*: x) (foldr1 f (:* x)))
                                   (*: x)))
   -> (\ x f (f x))
   at (\ l n (? (< n 1) (*: l) (at (:* l) (- n 1))))
   atn (\ n (\ l (at l n)))
   flip (\ f (\ x y (f y x)))
   snoc  (\ l x (? (twop l) (:: (*: l) (snoc (:* l) x))
                            (:: x l)))
   idx (\ l x
    ((: .l (\ l x n (? (twop l) (? (= x (*: l)) n (.l (:* l) x (+ n 1))) -1)))
     l x 0))
   len (\ l (? (twop l) (+ 1 (len (:* l))) 0)))

(test 'functionals
  (&& (= (foldr 1 + (li 2 3))
         (foldr1 + (li 1 2 3))
         (foldl 1 + (li 2 3))
         (foldl1 + (li 1 2 3)))
      (= (li 1 2 3)
         (map (\ x (+ 1 x)) (iota 3))
         (snoc ((flip snoc) 2 (li 1)) 3)
         (foldr () :: (iota 1 4)))))

(:
 env (\ a p n vs
  (: .l (\ a n ;; lol what is this thing
         (? (twop a)
             (? (&& (twop (:* a)) (= '. (*: (:* a))))
                 (:: (- (+ n 1)) (li (*: a)))
                (-> (.l (:* a) (+ n 1)) (\ r
                 (:: (*: r) (:: (*: a) (:* r))))))
            (:: n a)))
       (-> (.l a 0) (\ b (: d (tbl)
          (, (tbl-set d
               'arg (:* b) 'loc ()
               'clo ()     'par p
               'lam (tbl)  'nom n
               'val vs  'sig (*: b))
             d))))))
 gtk (\ k (\ d v . (?
  (nilp v) (tbl-get d k)
           (tbl-set d k (*: v)))))
 e-arg (gtk 'arg) e-loc (gtk 'loc)
 e-clo (gtk 'clo) e-par (gtk 'par)
 e-lam (gtk 'lam) e-nom (gtk 'nom)
 e-val (gtk 'val) e-sig (gtk 'sig)
 inst (\ e m i k (emi i (k e (+ m 1))))
 insx (\ e m i x k (emi i (emx x (k e (+ m 2)))))
 ini  (\ e m (insx e m i-ret (e-nom e) (\ e m (hom m))))
 imm  (\ e m x k (insx e m i-immv x k))
 cev  (\ e m x k ((? (twop x) c2 (symp x) cy imm) e m x k))
 ana (\ x (cev (env () () () (ns)) 0 x ini))

 cy (\ e m x k (?                      ; this is weird sorry
  (tbl-has (e-val e) x)                ; the C version has a lot of reassigning variables
   (imm e m (tbl-get (e-val e) x) k) ; and that behavior is unstable right now
  (toplp e)
   (late e m x (e-val e) k)
  (< -1 (: a (idx (e-lams e) x)))
   (late e m x (e-val e) k)
  (< -1 (: b (idx (e-loc e) x)))
   (imx e m i-locn b k)
  (< -1 (: c (idx (e-arg e) x)))
   (imx e m i-argn c k)
  (< -1 (: d (idx (e-clo e) x)))
   (imx e m i-clon d k)
  (-> (look (e-par e) x) (\ q
   (-> (*: q) (\ r (?
    (= q 'here) (imm e m (:* q) k)
    (= q 'wait) (late e m x (:* q) k)
    (-> (len (e-clo e)) (\ y
     (,(e-clo e (snoc (e-clo e) x)
       (imx e m i-clon y))))))))))))
             
 c2 (\ e m x k (-> (*: x) (\ z (?
  (= z '`) (-> (:* x) (\ y (imm e m (? (twop y) (*: y)) k)))
  (= z '?) (cco e m y k)
  (= z ':) (cde e m x k)
  (= z '\) (cla e m x k)
  (= z ',) (cse e m x k)
           (cap e m x k)))))
 toplp (\ e (nilp (e-par e)))
 look (\ e y (?
  (tbl-has (e-val e) y)    (li 'here (tbl-get (e-val e) y))
  (toplp e)                (li 'wait (e-val e))
  (>= (idx (e-lam e) y) 0) (li 'wait (e-val e))
  (>= (idx (e-loc e) y) 0) (li 'loc e)
  (>= (idx (e-arg e) y) 0) (li 'arg e)
  (>= (idx (e-clo e) y) 0) (li 'clo e)
                           (look (e-par e) y)))
 desug (\ d (li (li '\ (li ', (init d) (last d)))))
 init (\ l (? (twop (:* l)) (:: (*: l) (init (:* l)))))
 last (\ l (? (twop (:* l)) (last (:* l)) (*: l)))
 consumes (\ h (-> (hom-get-i h) (\ i
  (? (= i i-tchom) 0
     (= i i-tcnum) 1
     (= i i-tctwo) 2
                   8))))
 late (\ e m x d k (-> (k e (+ m 2)) (\ h
  (-> (consumes h) (\ t
   (-> (? (= t 'none) h (hom-seek h 1)) (\ h
    (emi i-lbind (emx (:: t (:: d x)) h)))))))))
  
 cca (\ e m x k (-> (k e (+ m 2)) (\ q (?
  (nilp (= i-ret (hom-get-i q))) (emi i-call (emx x q))
  (= x (len (e-arg e)))          (emi i-loop q)
                                 (emi i-recur (emx x q))))))
 cap (\ e m x k
  ((: capi (\ e m x k
            (? (nilp x) (k e m)
             (capi e m (:* x) (\ e m
              (cev e m (*: x) (\ e m (inst e m i-push k))))))))
   e m (:* x) (\ e m
    (cev e m (*: x) (\ e m
     (cca e m (len (:* x)) k))))))
 cser (\ e m x k (?
  (nilp x) (k e m)
           (cev e m (*: x) (\ e m
            (cser e m (:* x) k)))))
 cse (\ e m x k (?
  (nilp (:* x)) (imm e m () k)
                (cser e m (:* x) k)))
 cder (\ e m x k (?
  (nilp x) (k e m)
           (cev e m (*: (:* x)) (\ e m
            (cdeb e m (*: x) (\ e m
             (cder e m (:* (:* x)) k)))))))
 cdeb (\ e m x k (?
  (toplp e) (insx e m i-tbind x k)
            (insx e m i-setl (idx (e-loc e) x) k)))
 cde (\ e m x k (?
  (nilp (:* x))            (imm e m nil k)
  (= 1 (% (len (:* x)) 2)) (cev e m (desug x) k)
                           (cder e m (:* x) k)))

  (,(test 'comp-em
     (= 3 ((emi i-immv (emx 3 (emi i-ret (hom 3)))))))
    (test 'comp-qt (-> (li 1) (\ y (= y ((ana (li '` y)))))))
    (test 'comp-ap (= 6 ((ana (li + 1 2 3)))))
    (test 'comp-sq (: box (li 0) inc (\(*! box (+ 1 (*: box))))
     (= 3 ((ana (li ', (li inc) (li inc) (li inc)))))))
    (test 'comp-de
     (-> 123 (\ x
      (-> ((ana (li ': '__123 x))) (\ y
       (-> __123 (\ z (= x y z))))))))
    (test 'comp-y-top (= __123 ((ana '__123))))))
