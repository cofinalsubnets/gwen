;; here's some functions for doing tests with
(: test (\ n v (. (? v 'ok 'NO) n)))

(: type (\ x (?
  (homp x) 'hom
  (nump x) 'num
  (symp x) 'sym
  (twop x) 'two
  (strp x) 'str
  (tblp x) 'tbl
           'nil)))

;; here's some data constructors
(: li (\ . . .) ; dot only has special meaning following another argument, which can be dot
   ++ (\ a b(?(twop a)(::(*: a)(++(:* a)b))b)) ; append
   iota (\ n x .
    (: iota.l (\ m n (? (< m n) (:: m (iota.l (+ m 1) n))))
     (? (nilp x) (iota.l 0 n) (iota.l n (*: x)))))
   rho (\ n xs .
    (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
     (?(> n 0)(rho.l n xs)))))

(: list-len (\ l (? (twop l) (+ 1 (list-len (:* l))) 0))
   de-str (\ s
     (: de-str.l (\ s n
        (? (= n (str-len s)) ()
           (:: (str-get s n) (de-str.l s (+ n 1)))))
        (de-str.l s 0))))

; strings are supposed to work
(test 'strings (&&
  (: l (de-str "hello person")
     (&& (= 12 (list-len l)) (= (*: l) 104)))
  (= "a" (str 97))
  (= "asdf" "asdf")
  (nilp (= "asdf" "asd"))
  (= "" (str 0 0 2 0))))

; here's a function for iterating over ranges
(: from (\ m n f (? (< m n) (, (f m) (from (+ m 1) n f)))))

; hash tables are mysterious
(: hasht (\ n
 (: d (tbl) (,(from 0 (+ n 1) (\ m (tbl-set d m m)))
              (tbl-get d n))))
 (test 'hashes (= 99 (hasht 99))))


(test 'continuations
  ;; grow the call stack then call a continuation
  (: loop (\ m n c (? (= m n) (c m) (, (loop (+ 1 m) n c) m)))
    (= 12 (ccc (\ k (loop 0 12 k))))))

(test 'closures
  ;; if the compiler gets too smart we'll need a better test.
  (: math (\ x y z
     (: a(\ n(\ m((i +)((i *)m n)z)))
        b(\ f(\ x(f x)))
        i(\ x x)
        ((b(a x))y)))
    (= 22 (math 4 5 2))))

(: id (\ x x))
(test 'user-functions
  (&& (= 36 ((id ap) * (rho 2 1 2 3)))
      (= 3  ((id &&) 1 2 3))
      (= 15 ((id +) 1 2 3 4 5))
      (= 1  ((id ||) 1 2 3))))

(: box (:: 0 ())
   get *: set *!
   ct (\ x (,(set box (+ 1 (get box))) x))
   (test 'shortcut-eval
     (&& (&& (nilp (&& (ct 1) (ct 2) (ct ()) (ct 3)))
             (= (get box) 3))
         (&& (|| (ct ()) (ct ()) (ct 1) (ct 2))
             (= (get box) 6)))))

(: emm (\ f x k ((\ f x k (, (f k x) k)) f x (hom-seek k -1)))
   emi (\ i k (emm hom-set-i i k))
   emx (\ x k (emm hom-set-x x k)))
(: map (\ f x (? (twop x) (:: (f (*: x)) (map f (:* x)))))
   foldl(\ z f x (? (twop x) (foldl (f z (*: x)) f (:* x)) z))
   foldr (\ z f x (? (twop x) (f (*: x) (foldr z f (:* x))) z))
   foldl1 (\ f x (foldl (*: x) f (:* x)))
   foldr1  (\ f x (? (twop (:* x)) (f (*: x) (foldr1 f (:* x)))
                                   (*: x)))
   each (\ x f (? x (,(f (*: x)) (each (:* x) f))))

   -> (\ x f (f x))
   at (\ l n (? (< n 1) (*: l) (at (:* l) (- n 1))))
   atn (\ n (\ l (at l n)))
   flip (\ f (\ x y (f y x)))
   snoc  (\ l x (? (twop l) (:: (*: l) (snoc (:* l) x))
                            (:: x l)))
   idx (\ l x
    ((: .l (\ l x n (? (twop l) (? (= x (*: l)) n (.l (:* l) x (+ n 1))) -1)))
     l x 0))
   len (\ l (? (twop l) (+ 1 (len (:* l))) 0)))

(test 'functionals
  (&& (= (foldr 1 + (li 2 3))
         (foldr1 + (li 1 2 3))
         (foldl 1 + (li 2 3))
         (foldl1 + (li 1 2 3)))
      (= (li 1 2 3)
         (map (\ x (+ 1 x)) (iota 3))
         (snoc ((flip snoc) 2 (li 1)) 3)
         (foldr () :: (iota 1 4)))))
(: boot (\ e (,
(: compiler '(: ; ok now let's port the compiler
 env (\ a p n vs
  (: .l (\ a n ;; lol what is this thing
         (? (twop a)
             (? (&& (twop (:* a)) (= '. (*: (:* a))))
                 (:: (- (+ n 1)) (li (*: a)))
                (-> (.l (:* a) (+ n 1)) (\ r
                 (:: (*: r) (:: (*: a) (:* r))))))
            (:: n a)))
       (-> (.l a 0) (\ b (: d (tbl)
          (, (tbl-set d
               'arg (:* b) 'loc ()
               'clo ()     'par p
               'lam (tbl)  'nom n
               'val vs  'sig (*: b))
             d))))))
 gtk (\ k (\ d v . (?
  (nilp v) (tbl-get d k)
           (tbl-set d k (*: v)))))
 e-arg (gtk 'arg) e-loc (gtk 'loc)
 e-clo (gtk 'clo) e-par (gtk 'par)
 e-lam (gtk 'lam) e-nom (gtk 'nom)
 e-val (gtk 'val) e-sig (gtk 'sig)
 e-s1  (gtk 's1)  e-s2  (gtk 's2)
 inst (\ e m i k (,;(.(inom i))
                   (emi i (k e (+ m 1)))))
 inom (\ i ((: ii (\ l (? l (? (= i (tbl-get (cns) (*: l))) (*: l)
                                 (ii (:* l))))))
            (tbl-keys (cns))))

 insx (\ e m i x k (emi i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x k))
 cev  (\ e m x k ((? (twop x) c2 (symp x) cy imm) e m x k))

 cy (\ e m x k (:
  r ((\ r (? (= x 'ana) (. r) r))(look e x))
  s (*: r)
  (? (= s 'here)  (imm e m (:* r) k)
     (= s 'wait)  (late e m x (:* r) k)
     (= e (:* r)) (? (= s 'arg)
                      (insx e m i-argn (idx (e-arg e) x) k)
                     (= s 'loc)
                      (insx e m i-locn (idx (e-loc e) x) k)
                     (= s 'clo)
                      (insx e m i-clon (idx (e-clo e) x) k))
     (: l (len (e-clo e)) (, (e-clo e (snoc (e-clo e) x))
                             (insx e m i-clon l k))))))

 cqt (\ e m x k (: y (:* x) (imm e m (? y (*: y)) k)))
 c2 (\ e m x k (-> (*: x) (\ z ((?
  (= z '`) cqt (= z '?) cco (= z ':) cde
  (= z '\) cla (= z ',) cse          cap) e m x k))))

 toplp (\ e (nilp (e-par e)))
 looktop (\ e y
  (: d (ns) c (cns) (? (tbl-has d y) (:: 'here (tbl-get d y))
                       (tbl-has c y) (:: 'here (tbl-get c y))
                       (:: 'wait d))))
 look (\ e y (,
 (? (= y 'ana) (,(. 'ana) (dbg-env e)))
 (?
  (tbl-has (e-val e) y) (:: 'here (tbl-get (e-val e) y))
  (toplp e)
   (? (tbl-has (cns) y)
    (:: 'here (tbl-get (cns) y))
    (:: 'wait (ns)))
  (< -1 (idx (e-lam e) y)) (:: 'wait (e-val e))
  (< -1 (idx (e-loc e) y)) (:: 'loc e)
  (< -1 (idx (e-arg e) y)) (:: 'arg e)
  (< -1 (idx (e-clo e) y)) (:: 'clo e)
  (look (e-par e) y))))
 init (\ l (? (twop (:* l)) (:: (*: l) (init (:* l)))))
 last (\ l (? (twop (:* l)) (last (:* l)) (*: l)))
 t-hom 0 t-num 1 t-two 2 t-tup 3 t-oct 4
 t-tbl 5 t-sym 6 t-nil 7 t-none 8
 consumes (\ h (-> (hom-get-i h) (\ i
  (? (= i i-tchom) t-hom
     (= i i-tcnum) t-num
     (= i i-tctwo) t-two
                   t-none))))
 late (\ e m x d k (-> (k e (+ m 2)) (\ h
  (-> (consumes h) (\ t
   (-> (? (= t t-none) h (hom-seek h 1)) (\ h
    (emi i-lbind (emx (:: t (:: d x)) h)))))))))

 cap (\ e m x k
  ((: cca (\ e m x k (-> (k e (+ m 2)) (\ k (?
       (nilp (= i-ret (hom-get-i k))) (emi i-call (emx x k))
       (= x (len (e-arg e)))          (emi i-loop k)
                                      (emi i-rec (emx x k))))))
      capi (\ e m x k
            (? (nilp x) (k e m)
             (capi e m (:* x) (\ e m
              (cev e m (*: x) (\ e m (inst e m i-push k))))))))
   e m (:* x) (\ e m
    (cev e m (*: x) (\ e m
     (inst e m i-tchom (\ e m
       (cca e m (len (:* x)) k))))))))

 cse (\ e m x k (,
  (: cser (\ e m x k (?
      (nilp x) (k e m)
               (cev e m (*: x) (\ e m
                (cser e m (:* x) k))))))
  (? (:* x) (cser e m (:* x) k)
            (imm e m () k))))

 mat (\ e x (: y (look e x) (? (= (*: y) 'here) (li (:* y)))))
 cde (\ e m x k (,
  (: desug (\ d (li (li '\ (li ', (init d) (last d)))))
     cder (\ e m x k (? (nilp x) (k e m) (?
      (-> (\ e m (cder e m (:* (:* x)) k)) (\ k
       (-> (? (|| (toplp e) (< -1 (idx (e-loc e) (*: x))))
              (\ e m (cdeb e m (*: x) k))
              k) (\ k
        (? (: q (mat e (*: x)))
         (imm e m (*: q) k)
         (cev e m (*: (:* x)) k)))))))))
     cdeb (\ e m x k (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (e-loc e) x) k))))
  (?  (nilp (:* x))            (imm e m nil k)
      (= 1 (% (len (:* x)) 2)) (cev e m (desug x) k)
                               (cder e m (:* x) k))))

 ccopre (\ e m k (-> (k e m) (\ k
  (*: (e-s2 e (:: k (e-s2 e)))))))

 cco (\ e m x k (,
  (: ccopreant (\ e m k (-> (k e (+ m 2)) (\ k
      (-> (emi i-branch (emx (*: (e-s1 e)) k)) (\ k
       (, (e-s1 e (:* (e-s1 e))) k))))))
     ccoprecon (\ e m k (-> (k e (+ m 2)) (\ x
      (-> (*: (e-s2 e)) (\ k
       (: i (hom-get-i k)
        (? (= i i-ret) (emi i x)
         (emi i-jump
          (emx (? (= i i-jump) (hom-get-x (hom-seek k 1)) k) x)))))))))
     ccopostcon (\ e m k (-> (k e m) (\ k
      (*: (e-s1 e (:: k (e-s1 e)))))))
     ccor (\ e m x k (?
      (nilp x) (ccor e m (:: x x) k)
      (nilp (:* x)) (cev e m (*: x) (\ e m (ccoprecon e m k)))
      (cev e m (*: x) (\ e m
       (ccopreant e m (\ e m
        (ccor e m (:* (:* x)) (\ e m
         (ccopostcon e m (\ e m
          (cev e m (*: (:* x)) (\ e m
           (ccoprecon e m k))))))))))))))

  (? (nilp (:* x)) (imm e m nil k)
   (-> (ccor e m (:* x) (\ e m (ccopre e m k))) (\ k
    (, (e-s2 e (:* (e-s2 e))) k))))))

 ltu (\ e nom l (,
  (? (= nom 'ana)
   (,(. 'ltu)(dbg-env e)))
  (: n ((\ x (? x x (:: x x))) (:* l))
     x (last n)
     f (env (init n) e nom (tbl)))
  (scan f x)
  (resolve f)
  (-> (cev f 4 x (ini i-ret)) (\ k
   (-> (? (nilp (e-loc f)) k
        (emi i-prel (emx (len (e-loc f)) k))) (\ k
    (-> (hom-fin (?
         (> (: i (e-sig f)) 0) (emi i-arity (emx i k))
         (< i 0) (emi i-vararg (emx (- (- i) 1) k))
         k)) (\ k
     (? (e-clo f) (:: (e-clo f) k) k)))))))))


 ldel (\ l k (? l
  ((? (= (k (*: l))) id (\ m (:: (*: l) m)))
   (ldel (:* l) k))))

 precomps (\ e ks (? ks (,
  (: k (*: ks) i (ltu e k (tbl-get (e-lam e) k)))
  (? (homp i)
      (, (tbl-set (e-val e) k i) (tbl-del (e-lam e) k) (e-loc e (ldel (e-loc e) k)))
     (, (!* i (tbl-get (e-lam e) k))  (tbl-set (e-lam e) k i)))
  (precomps e (:* ks)))))

 okvs (\ e vs (?
  (nilp vs) 0
  (: v (*: vs)
   (? (|| (tbl-has (e-lam e) v) (tbl-has (e-val e) v))
      (okvs e (:* vs))))))

 elim (\ e ks (? ks (-> (*: ks) (\ k (?
  (nilp (okvs e (*: (tbl-get (e-lam e) k))))
   (, (tbl-del (e-lam e) k) (elim e (tbl-keys (e-lam e))))
  (elim e (:* ks)))))))

 recomps (\ e d ks (? ks (: k (*: ks) (,
  (e-loc e (ldel (e-loc e) k))
  (tbl-set (e-val e) k (ltu e k (:* (tbl-get d k))))
  (recomps e d (:* ks))))))

 resolve (\ e (,
  (precomps e (tbl-keys (e-lam e)))
  (elim e (tbl-keys (e-lam e)))
  (: ls (e-lam e)
     (recomps e ls (e-lam e (tbl-keys ls))))))

 scan (\ e x (,
  (: scandef (\ e x (?
      (nilp x) 1
      (nilp (:* x)) ()
      (-> (scandef e (:* (:* x))) (\ r
       (, (? r (scandefadd e (*: x) (*: (:* x))))
          r)))))
     mcar (\ x (? x (*: x)))
     addloc (\ e y (e-loc e (:: y (e-loc e))))

     scandefadd (\ e y x (,
      (? (symp x) (addloc e y)
         (twop x) (-> (*: x) (\ z (?
          (= z '`) (tbl-set (e-val e) y (mcar (:* x)))
          (= z '\) (, (tbl-set (e-lam e) y x) (addloc e y))
          (addloc e y))))
         (tbl-set (e-val e) y x))
      (scan e x))))

  (? (&& (twop x) (nilp (: y (*: x) (|| (= y '\) (= y '`))))
     (? (= (*: x) ':) (scandef e (:* x))
                      (each x (\ x (scan e x))))))))

 t-nom (\ t (?
  (= t t-hom) 'hom
  (= t t-num) 'num
  (= t t-two) 'two
  (= t t-tup) 'tup
  (= t t-oct) 'str
  (= t t-tbl) 'tbl
  (= t t-sym) 'sym
  (= t t-nil) 'nil))

 type-err (\ h w (fail
  (li 'type-error ': (t-nom h) 'for (t-nom w))))
 arity-err (\ h w (fail
  (li 'arity-error ': h 'of w)))
 tc (\ t h
  (-> (consumes h) (\ u
   (? (= t u) (tc t (hom-seek h 1))
    (? (= u t-none) h
     (type-err t u))))))
 produce (\ e m t k (tc t (k e (+ m 2))))
 cla (\ e m x k
  (-> (produce e m t-hom (\ e m (k e (+ m 2)))) (: cla.in (\ k
   (-> (ltu e () x) (\ x (?
    (homp x) (emi i-immv (emx x k))
             (emi (? (e-loc e) i-encll i-encln)
              (emx (:: (:* x) ((claclo e (*: x) 0) e 0)) k)))))))))

 claclo (\ e arg n (? (nilp arg)
  (\ e m (emi i-take (emx n (hom (+ m 2)))))
  (-> (claclo e (:* arg) (+ n 1)) (\ k
   (\ e m (cy e m (*: arg) (\ e m (inst e m i-push k))))))))

 dbg-env (\ e (. 'env ': 'arg (e-arg e) 'loc (e-loc e) 'clo (e-clo e) 'val (tbl-keys (e-val e)) 'lam (? (tblp (e-lam e)) (tbl-keys (e-lam e)) (e-lam e))))
 ini (\ i (\ e m (insx e m i (e-nom e) (\ e m (hom m)))))
 ana (\ x ((cev (env () () () (ns)) 0 x (ini i-ret))))
 (,
  (test 'comp-em (= 3 ((emi i-immv (emx 3 (emi i-ret (hom 3)))))))
  (test 'comp-qt (-> (li 1) (\ y (= y (ana (li '` y))))))
  (test 'comp-ap (= 6 (ana (li + 1 2 3))))
  (test 'comp-sq (: box (li 0) inc (\(*! box (+ 1 (*: box))))
   (= 3 (ana (li ', (li inc) (li inc) (li inc))))))
  (test 'comp-de (&&
   (-> 123 (\ x
    (-> (ana (li ': '_123 x)) (\ y
     (-> _123 (\ z (= 123 x y z)))))))
   (= 3 (ana '(: a (\ 1) b (\ 2) c (\(+(a)(b))) (c))))))
  (test 'comp-sy (= _123 (ana '_123)))
  (test 'comp-co (&& (= 1 (ana '(? () 0 1)));false
                     (= 0 (ana '(? 1 0 ())));true
                     (nilp (ana '(? () 1)));even
                     (= 1 (ana '(? () (? () 1 0);nested
                                      (? () 0 1))))))
  (test 'comp-la (&&
   (= 3 (ana '((\(+((\ 1))((\ 2)))))))
   (= 6 ((ana '(\ a b ((\ c (+ c b 1)) a))) 3 2))))
  ana
 )))
 (e compiler))))

(: eva (boot ev))

; hurray a new language
(: quine ((\ q ((eva q) q)) '(\ i (li i (li '` i))))
   ;eval (eva compiler)
   )

(test 'quine (= quine (ev quine) (eva quine)))

(: math
   '(: fib (\ n ;; double recursive fibonacci function
        (? (< n 3) 1 (+ (fib (- n 1)) (fib (- n 2)))))
       ack (\ m n ;; ackermann function
        (? (< m 1) (+ n 1)
         (ack (- m 1) (? (> n 0) (ack m (- n 1)) 1))))
     (, (test 'fib32 (= 2178309 (fib 32)))
        (test 'ack3,9 (= 4093 (ack 3 9)))))
 (eva math))
