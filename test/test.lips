;; here's some functions for doing tests with
(: test (\ n v (. (? v 'ok 'NO) n)))

(: type (\ x (?
  (homp x) 'hom
  (nump x) 'num
  (symp x) 'sym
  (twop x) 'two
  (strp x) 'str
  (tblp x) 'tbl
           'nil)))

;; here's some data constructors
(: li (\ . . .) ; dot only has special meaning following another argument, which can be dot
   ++ (\ a b(?(twop a)(::(*: a)(++(:* a)b))b)) ; append
   iota (\ n x .
     (: .i (\ m n (? (< m n) (:: m (.i (+ m 1) n))))
       (? (nilp x) (.i 0 n) (.i n (*: x)))))
   rho (\ n xs .
     ;; like in APL
     ;; (rho 0 1 2) = ()
     ;; (rho 1 1 2) = (li 1 2)
     ;; (rho 2 1 2) = (li 1 2 1 2)
     ;; (rho 2 (rho 2 0)) = (li (li 0 0) (li 0 0))
     (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
       (?(> n 0)(rho.l n xs)))))

; hurray a new language
(: quine ((\ q ((ev q) q)) '(\ i (li i (li '` i))))
  (test 'ev-q (= (ev quine) quine)))

(: list-len (\ l (? (twop l) (+ 1 (list-len (:* l))) 0))
   de-str (\ s
     (: de-str.l (\ s n
        (? (= n (str-len s)) ()
           (:: (str-get s n) (de-str.l s (+ n 1)))))
        (de-str.l s 0))))

; strings are supposed to work
(test 'strings (&&
  (: l (de-str "hello person")
     (&& (= 12 (list-len l)) (= (*: l) 104)))
  (= "a" (str 97))
  (= "asdf" "asdf")
  (nilp (= "asdf" "asd"))
  (= "" (str 0 0 2 0))))

; here's a function for iterating over ranges
(: from (\ m n f (? (< m n) (, (f m) (from (+ m 1) n f)))))

; hash tables are mysterious
(: hasht (\ n
  (: d (tbl) (, (from 0 (+ n 1) (\ m (tbl-set d m m)))
                (tbl-get d n))))
  (test 'hashes (= 99 (hasht 99))))


(test 'continuations
  ;; grow the call stack then call a continuation
  (: loop (\ m n c (? (= m n) (c m) (, (loop (+ 1 m) n c) m)))
    (= 12 (ccc (\ k (loop 0 12 k))))))

(test 'closures
  ;; if the compiler gets too smart we'll need a better test.
  (: math (\ x y z
     (: a(\ n(\ m((i +)((i *)m n)z)))
        b(\ f(\ x(f x)))
        i(\ x x)
        ((b(a x))y)))
    (= 22 (math 4 5 2))))

(: id (\ x x)
  (test 'user-functions
    (&& (= 36 ((id ap) * (rho 2 1 2 3)))
        (= 3  ((id &&) 1 2 3))
        (= 15 ((id +) 1 2 3 4 5))
        (= 1  ((id ||) 1 2 3)))))

(: box (:: 0 ())
   get *: set *!
   ct (\ x (,(set box (+ 1 (get box))) x))
   (test 'shortcut-eval
     (&& (&& (nilp (&& (ct 1) (ct 2) (ct ()) (ct 3)))
             (= (get box) 3))
         (&& (|| (ct ()) (ct ()) (ct 1) (ct 2))
             (= (get box) 6)))))

(: fib ;; double recursive fibonacci function
   (\ n (? (< n 3) 1 (+ (fib (- n 1)) (fib (- n 2)))))

   ack ;; ackermann function
   (\ m n
     (? (< m 1) (+ n 1)
       (ack (- m 1) (? (> n 0) (ack m (- n 1)) 1))))

   (, (test 'fib32 (= 2178309 (fib 32)))
      (test 'ack3,9 (= 4093 (ack 3 9)))
      ))


(: emm (\ f x k ((\ f x k (, (f k x) k)) f x (hom-seek k -1)))
   emi (\ i k (emm hom-set-i i k))
   emx (\ x k (emm hom-set-x x k))
   hom-fin (\ k (: .hf (\ j k (? (= 0 (hom-get-i k))
                                 (hom-set-x (hom-seek k 1) j)
                                 (.hf j (hom-seek k 1))))
                   (.hf k k))))

(test 'mini-comp
  (= 3 ((emi i-immv (emx 3 (emi i-ret (hom 3)))))))

(: map (\ f x (? (twop x) (:: (f (*: x)) (map f (:* x)))))
   foldl(\ z f x (? (twop x) (foldl (f z (*: x)) f (:* x)) z))
   foldr (\ z f x (? (twop x) (f (*: x) (foldr z f (:* x))) z))
   foldl1 (\ f x (foldl (*: x) f (:* x)))
   foldr1  (\ f x (? (twop (:* x)) (f (*: x) (foldr1 f (:* x)))
                                   (*: x)))
   at (\ l n (? (< n 1) (*: l) (at (:* l) (- n 1))))
   atn (\ n (\ l (at l n)))
   flip (\ f (\ x y (f y x)))
   -> (\ x f (f x))
   snoc  (\ l x (? (twop l) (:: (*: l) (snoc (:* l) x))
                            (:: x l)))
   idx
     (: .l (\ l x n (? (twop l) (? (= x (*: l)) n (.l (:* l) x (+ n 1))) -1))
       (\ l x (.l l x 0)))
   len (\ l (? (twop l) (+ 1 (len (:* l))) 0)))

(test 'functionals
  (&& (= (foldr 1 + (li 2 3))
         (foldr1 + (li 1 2 3))
         (foldl 1 + (li 2 3))
         (foldl1 + (li 1 2 3)))
      (= (li 1 2 3)
         (map (\ x (+ 1 x)) (iota 3))
         (snoc ((flip snoc) 2 (li 1)) 3)
         (foldr () :: (iota 1 4)))))

(: env (\ a p n
     (: .l (\ a n
       (? (twop a)
          (? (&& (twop (:* a))
                 (= '. (*: (:* a))))
             (:: (- (+ n 1)) (li (*: a)))
             ((\ r (:: (*: r) (:: (*: a) (:* r))))
              (.l (:* a) (+ n 1))))
          (:: n a)))
       (-> (.l a 0) (\ b (: d (tbl)
          (, (tbl-set d
               'arg (:* b) 'loc ()
               'clo ()     'par p
               'lam (tbl)  'nom n
               'val (tbl)  'sig (*: b))
             d))))))
   gtk (\ k (\ d (tbl-get d k)))
   e-arg (gtk 'arg) e-loc (gtk 'loc)
   e-clo (gtk 'clo) e-par (gtk 'par)
   e-lam (gtk 'lam) e-nom (gtk 'nom)
   e-val (gtk 'val) e-sig (gtk 'sig)
   inst (\ e m i k (emi i (k e (+ m 1))))
   insx (\ e m i x k (emi i (emx x (k e (+ m 2)))))
   ini  (\ e m (insx e m i-ret (e-nom e) (flip hom)))
   imm  (\ e m x k (insx e m i-immv x k))
   cev  (\ e m x k ((? (twop x) c2 (symp x) cy imm) e m x k))
   ana (\ x (cev (env () () ()) 0 x ini))
   c2 (\ e m x k (: z (*: x) y (:* x) (?
     (= z '`) (imm e m (? (twop y) (*: y)) k)
     (= z '?) (cco e m y k)
     (= z ':) (cde e m x k)
     (= z '\) (cla e m x k)
     (= z ',) (cse e m y k)
              (cap e m x k))))
   toplp (\ e (nilp (e-par e)))
   look (\ e y (?
     (tbl-has (e-val e) y) (li 'here (tbl-get (e-val e) y))
     (toplp e) (li 'wait (e-val e))
     (>= (idx (e-lam e) y) 0) (li 'wait (e-val e))
     (>= (idx (e-loc e) y) 0) (li 'loc e)
     (>= (idx (e-arg e) y) 0) (li 'arg e)
     (>= (idx (e-clo e) y) 0) (li 'clo e)
     (look (e-par e) y)))
   desug (\ d (li (li '\ (li ', (init d) (last d)))))
   init (\ l (? (twop (:* l)) (:: (*: l) (init (:* l)))))
   last (\ l (? (twop (:* l)) (last (:* l)) (*: l)))

   cca (\ e m x k (-> (k e (+ m 2)) (\ q
     (? (nilp (= i-ret (hom-get-i q))) (emi i-call (emx x q))
        (= x (len (e-arg e))) (emi i-loop q)
                              (emi i-recur (emx x q))))))
   cap (\ e m x k (:
     capi (\ e m x k
       (? (nilp x) (k e m)
         (capi e m (:* x) (\ e m
           (cev e m (*: x) (\ e m (inst e m i-push k)))))))
     (capi e m (:* x) (\ e m
       (cev e m (*: x) (\ e m
         (cca e m (len (:* x)) k)))))))

   cse (\ e m x k
    (? (nilp x) (k e m)
      (cev e m (*: x) (\ e m
        (cse e m (:* x) k)))))

   cder (\ e m x k
     (? (nilp x) (k e m)
       (cev e m (*: (:* x)) (\ e m
         (cdeb e m (*: x) (\ e m
           (cder e m (:* (:* x)) k)))))))
   cdeb (\ e m x k
     (? (toplp e) (insx e m i-tbind x k)
                  (insx e m i-setl (idx (e-loc e) x) k)))
   cde (\ e m x k (? (nilp (:* x))
                       (imm e m nil k)
                     (= 1 (% (len (:* x)) 2))
                       (cev e m (desug x) k)
                     (cder e m (:* x) k ))))
