(:
  evaluator '(:- eval
;; functions for working with variable scope records
    (toplp c) (nilp (parof c)) (parof c) (tget 0 c 'par)
    (stkof c) (tget 0 c 'stk)  (argof c) (tget 0 c 'arg)
    (impof c) (tget 0 c 'imp)  (lamof c) (tget 0 c 'lam)
    (arity c) (+ (llen (argof c)) (llen (impof c)))
    (cpush c k v) (, (tset c k (X v (zget c k))) v)
    (cpop c k) (: s (zget c k) _ (tset c k (B s)) (A s))
    (cpeek c k) (A (zget c k))
    (scop par arg imp) (:
     t (tnew 0)
     _ (tset t 'par par)
     _ (tset t 'arg arg)
     _ (tset t 'imp imp)
     t)
;; thread initializer
    (thd0 c n) (:
     k (thd (+ 2 n))    ; full initial thread
     k (seek (+ 1 n) k) ; go to last writeable address
     k (p0 (arity c) k) ; write return instruction
     k (p1 i_ret k)
     k)
;; import a variable into this scope
    (import c v)
     (? (not (toplp c)) (cpush c 'imp v))
    p0 poke
    (p1 x k) (poke x (seek -1 k))
    (em1 i k n) (p1 i (k (+ 1 n)))
    (em2 i x k n) (p1 i (p1 x (k (+ 2 n))))
    (em_ap k n) (:
     j (k (+ 1 n))
     i (peek j)
     (? (= i i_ret) (p0 i_tap j)
                    (p1 i_ap j)))
    (em_apn n k m) (:
     j (k (+ 2 m))
     i (peek j)
     (? (= i i_ret) (p1 i_tapn (p0 n j))
                    (p1 i_apn (p1 n j))))
    imm (em2 i_imm)
    (stkidx d x)
      (: imp (impof d)
         ii  (lidx x imp)
       (? (<= 0 ii) ii
        (: ai (lidx x (argof d))
         (? (<= 0 ai) (+ (llen imp) ai)
                      -1))))

    (eval x) (:
     c (scop 0 (L 0) 0)
     (ana c x (thd0 c) 0 0))

    (ana c x)
     (? (symp x)  (ana_sym c x)
        (atomp x) (imm x)
        (: a (A x) b (B x) (?
         (= a '` ) (imm (A b))
         (= a '? ) (ana_if  c b)
         (= a '\ ) (ana_lam c b)
         (= a ': ) (ana_let c b)
         (= a ', ) (ana_seq c b)
         (atomp b) (ana c a)
         (: m (tget 0 macros a) (? m
          (ana c (m b))
          (ana_ap c a b))))))

    ;ana_if is a bit complicated
    (ana_if c b) (:-
     (: a0 (pop 'end)
        a1 (ana_if_r b)
        a2 (push 'end)
      (<=< a0 a1 a2))
     ; where
     (pop y k n) (: j (k n) (, (cpop c y) j))
     (push y k n) (cpush c y (k n))
     (ana_if_r b) (?
      (atomp b) (imm 0)
      (atomp (B b))
       (: a0 (ana c (A b))
          a1 (peek_end c)
        (<=< a0 a1))
      (: a0 (ana c (A b))
         a1 (pop_alt c)
         a2 (ana c (AB b))
         a3 (peek_end c)
         a4 (push 'alt)
         a5 (ana_if_r (BB b))
       (<=< a0 a1 a2 a3 a4 a5)))

     (pop_alt c k n) (:
      j (k (+ 2 n))
      alt (cpop c 'alt)
      j (p1 alt j)
      (p1 i_cond j))

     (peek_end c k n) (:
      j (k (+ 3 n))
      a (cpeek c 'end)
      i (peek a)
      (?  (|| (= i i_ret) (= i i_tap))
           (p1 i
            (p1 (peek (seek 1 a))
             j))
          (= i i_tapn)
           (p1 i
            (p1 (peek (seek 1 a))
             (p1 (peek (seek 2 a))
              j)))
          (p1 i_jump
           (p1 a
            j)))))

    (ana_apl n c b) (:
     (loop c b)
      (? (atomp b) id
       (: a0 (ana c (A b))
          a1 em_ap
          a2 (loop c (B b))
        (<=< a0 a1 a2)))
     _ (cpush c 'stk n)
     a (loop c b)
     _ (cpop c 'stk)
     a)

    (ana_ap c f b) (: a0 (ana c f)
                      a1 (ana_apl 0 c b)
                    (<=< a0 a1))
    ; ana_seq is recursive but pretty simple
    (ana_seq c x)
     (? (atomp x) (imm 0)
      (co (ana c (A x))
          (? (atomp (B x)) id
           (co (em1 i_drop1)
               (ana_seq c (B x))))))
   (ana_sym c x) (:- (ana_sym_r c)
    (ana_sym_r d)
     (? (nilp d) ; outside all lexical scopes?
         (: a0 (sym 0)
            y (tget a0 globals x) ; check global scope
          (? (!= y a0) (imm y) ; if it's there use that
           (, (import c x) ; if it's not there... do something
              (em2 i_free_variable x))))
       ; else...
      (: lam (lamof d)
         stk (stkof d)
         lfd (assq x lam)
       (? lfd ; local function def? ;; ana_sym_local_fn
            (: a1 (em2 i_lazy_bind lfd)
               a2 (ana_apl 0 c (BB lfd))
             (<=< a1 a2))
         (memq x stk) ; is it bound on a let stack in this scope?
          (? (= c d) (em2 i_ref (lidx x stk))
                     (, (import c x)
                        (cata_var c x)))
        (<= 0 (stkidx d x)) ; is it bound as a closure or argument variable?
         (, (? (!= c d) (import c x))
            (cata_var c x))
        ; else recur
        (ana_sym_r (parof d)))))

    (cata_var c x) (:
     i (llen (stkof c))
     (\ j m (:
      k (j (+ 2 m))
      i (+ i (stkidx c x))
      k (p1 i k)
      k (p1 i_ref k)
      k))))

    ; ana_ll isn't too bad
    (ana_ll c imp exp) (:
     arg (init exp)
     x (last exp)
     d (scop c arg imp)
     k0 (ana d x (thd0 d))
     ar (arity d)
     k (trim ((? (> ar 1) (em2 i_curry ar) id) k0 0))
     (X k (impof d)))

    ; ana_lam is small because it uses ana_ll which ana_let also uses
    (ana_lam c b) (?
     (atomp b)     (imm 0)
     (atomp (B b)) (ana c (A b))
     (ana c (ana_ll c 0 b)))

    ; ana_let is the worst :[
    (ana_let c b) (?
     (atomp b)     (imm 0)
     (atomp (B b)) (ana c (A b))
     (loop1 c (scop c (argof c) (impof c)) 0 0 (A b) (AB b) (BB b)))

     ;; l1 pass nom def and value expressions to l2
     ; l1 collects bindings and passes them with the body expression to l2
     (loop1 c q noms defs nom def rest) (:
      nd (desug nom def)
      nom (A nd) def (B nd)
      noms (X nom noms) defs (X def defs)
      (? (atomp rest)     (loop2 c q noms defs nom      rest)
         (atomp (B rest)) (loop2 c q noms defs (A rest) rest)
         (loop1 c q noms defs (A rest) (AB rest) (BB rest))))

     ;; l2 pass noms defs exp with revised lambda defs to l3
     ; l2 finds closures for all local functions and passes a lambda expression for the body to l3
     (loop2 c q noms defs exp rest) (:

      lams (:- (loop 0 noms defs)
            (loop a n d) (?
             (atomp n) a
             (nilp (lambp (A d))) (loop a (B n) (B d))
             (: k (A n)
                v (ana_ll q 0 (BA d)) ; first compile pass ..
                a (X (X k v) a)
              (loop a (B n) (B d)))))

      (close l) (:- (cl 0 l l l)
        (cl n l l1 l2) (?
         (&& l1 l2 (!= l1 l2) (memq (AA l1) (BB (A l2))))
          (:- (loop n (BB (A l1)))
           (loop n v)
            (? (nilp v) (cl n l l1 (B l2))
             (: var (A v)
                vars (B (BA l2))
                n (? (memq var vars) n
                   (, (set_cdr (BA l2) (X var vars))
                      (+ 1 n)))
                (loop n (B v)))))
         l2 (cl n l l1 (B l2))
         l1 (cl n l (B l1) l)
         n (cl 0 l l l)
         l))

      lams (close lams)
      lnoms (map A lams)
      (lamdel lnoms) (map (\ ll (X (A ll) (X (AB ll) (foldl (BB ll) (flip ldel) lnoms)))))
      clams (lamdel lnoms lams)
      llam (X '\ (cat noms (L exp))) ;; construct reversed lambda expression
      (loop3 c q (rev noms) (rev defs) clams llam rest))

     ;; l3 collect defs and apply
     (loop3 c q noms defs clams llam rest) (:
       _ (tset q 'lam clams)
       (loop nds) (? (nilp nds) id
                   (: nd (A nds) n (A nd) d (B nd)
                      d (? (nilp (lambp d)) d (: qa (assq n clams)
                                                 x (ana_ll q (BB qa) (B d))
                                                 _ (set_cdr qa x)
                                                 x))
                      a1 (ana c d)
                      a2 (? (&& (toplp c) (atomp rest)) (em2 i_defglob n) id)
                      a3 (loops n (B nds))
                      (<=< a1 a2 a3)))
       (loops n nds) (, (cpush c 'stk n)
                        (loop nds))
       s0 (stkof c)
       n (llen noms)
       a1 (ana c llam)
       a2 (loops -1 (zip noms defs))
       a3 (? (> n 1) (em_apn n) em_ap)
       _ (tset c 'stk s0)
       (<=< a1 a2 a3))

    (set_cdr p x) (, (poke x (seek 3 p)) x) # don't do this :<
    (lambp x) (? (twop x) (= '\ (A x)))
    (desug n d) (? (atomp n) (X n d)
                   (desug (A n) (X '\ (cat (B n) (L d))))))
  eval (ev evaluator)
(assert
 (= 1 (eval 1))
 (= 0 (eval '(,)))
 (= 1 (eval '(, 1)))
 (= 7 (eval '(, 1 2 3 4 5 6 7)))
 (= 'a (eval 'a))
 (= ''a (eval '''a))
 (= 'a (eval '(, 1 2 a)))
 (= 0 (eval '(?)))
 (= 9 (eval '(? 9)))
 (= 0 (eval '(:)))
 (= 9 (eval '(: (+ 5 4))))
 (= 0 (eval '(\ )))
 (= 3 (eval '(\ (? (: (, 1 2 3))))))
 (= -1 (eval '(- 1 2)))
 (= 1 (eval (L - 2 1)))
 (= 12 (eval '(* 3 (+ 3 1))))
 (= 2 (eval '(? 0 1 2)))
 (= 5 (eval '(? (= 1 5) 1 (= 2 5) 2 (= 3 5) 3 (= 4 5) 4 (= 5 5) 5)))
 (= '(1 2 3) (eval '(L 1 2 3)))
 (= 15 (eval '(\ a (* 3 (+ 2 3))) 0))
 (= 15 (eval '(\ a ((\ a (* 3 (+ 2 3))) 0)) 0))
 (= 9 (eval '(\ a a) 9))
 (= 9 (eval '((\ a a) 9)))
 (= 9 (eval '((\ a b (+ b a)) 4) 5))
 (= 6 (eval '((\ a b (- b a)) 10) 16))
 (= 9 (eval '(\ a b (? b (* a 3) (+ a 2))) 3 1))
 (= 9 (eval '(: a 2 a (+ 3 a) (+ 4 a))))
 (= 9 (eval '(: a 9 a)))
 (= 7 (eval '(: a 9 b 7)))
 (= 9 a)
 (= 7 b)
 (= 3 (eval '(: a 9 3)))
 (= 3 (eval '(: a 9 (+ a)) -6))
 (= 4 (eval '(: a 2 (+ a a))))
 (= 9 (eval '(: a 4 b 5 (+ a b))))
 (= 48 (eval '(: a 9 b 3 c 8 (* c (- a b)))))
 (= 48 (eval '(: a 9 b (- a 6) c (* 8 (- a b)) c)))
 (= '(1 3 5) (eval '(: (evens m) (? (atomp m) 0 (odds (B m))) (odds n) (? (atomp n) 0 (X (A n) (evens (B n)))) (odds '(1 2 3 4 5 6)))))
 (= 7 (eval '(: a 1 b 3 c 2 (f x) (+ a x) (g x) (f (* b x)) (g c))))
 (= '(4 3 2 1) (eval '(: (f o i) (? i (f (X (A i) o) (B i)) o) (f 0)) '(1 2 3 4)))
 (= 0 (eval '(\ x (: (f n) (- x n))) 5 5))
 (= 44 (eval '(\ x y z (: q z (f r) (- (* x (+ y r)) q))) 5 9 6 1))
 (= 9 (eval '(\ n (: t (tnew 0) (, (tset t 'k n) (tget 0 t)))) 9 'k))
 (= 44 (eval evaluator evaluator '(\ x y z (: q z (f r) (- (* x (+ y r)) q))) 5 9 6 1))
 (= '(3 4) (eval '(: (a x l) (? l (? (= x (AA l)) (A l) (a x (B l))))) 3 '((1 2) (2 3) (3 4) (4 5))))
))
