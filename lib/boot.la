(: macros (tbl))
; to bootstrap first we define an expression that when
; eval'd defines the standard environment and compiler, and
; redefines eval. then we eval it twice. the first time
; everything is compiled by the bootstrap system, the second
; time by the (bootstrapped) live system.
(: prelude '(,
  (: `'` ?'? :': ,', \'\ ~~ '(0) ~ nilp

     (AA x) (A (A x)) (AB x) (A (B x))
     (BA x) (B (A x)) (BB x) (B (B x))

     ; functional programmings
     (I x) x id I
     (K x) (\ x) const K
     (co xs .) (foldl1 xs (\ m f (\ x . (f (ap m x)))))
     ((flip f) x y) (f y x)
     ((cu f x .) y .) (ap f (append x y))
     (map f x) (? (twop x) (X (f (A x)) (map f (B x))) x)
     (map- x f) (? (twop x) (X (f (A x)) (map- (B x) f)) x)
     (append a b) (? (twop a) (X (A a) (append (B a) b)) b)

     (flat-map x f) (? (twop x) (append (f (A x)) (flat-map (B x) f)))
     ; logic
     (&& l .) (all id l)
     (|| l .) (any id l)
     (each x f) (? x (, (f (A x)) (each (B x) f)))
     (all p l) (? l (? (p (A l)) (all p (B l))) -1)
     (any p l) (? l (? (p (A l)) -1 (any p (B l))))
     (part p l) (foldr l ~~ (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))

     ; data constructors
     (L . .) .
     (Q x) (L ` x)

     ; tables
     (set x .) (foldl x (tbl) (\ t x (, (tset t x -1) t)))

     ; numbers
     (inc x) (+ x 1)
     (dec x) (- x 1)

     ; lists
     (at l n) (? (< n 1) (A l) (at (B l) (- n 1)))
     (filter x p) (foldr x () (\ x m (? (p x) (X x m) m)))
     (foldr x z f) (? (twop x) (f (A x) (foldr (B x) z f)) z)
     (foldl x z f) (? (twop x) (foldl (B x) (f z (A x)) f) z)
     (foldl1  x f) (foldl (B x) (A x) f)
     (foldr1  x f) (?
      (twop (B x))
       (f (A x) (foldr1 (B x) f))
      (A x))
     (zip f a .) (? (? a (all id a))
      (X (ap f (map- a A)) (ap zip (X f (map- a B)))))
     (snoc l x) (? l (X (A l) (snoc (B l) x)) (L x))
     (randn n) (% (abs (rand)) n)
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (memq x k) (? x (? (= k (A x)) x (memq (B x) k)))
     (assq k x) (? x (? (= (AA x) k) (A x) (assq k (B x))))
     (del l k) (filter l (\ x (~ (= x k))))
     (idx l x)
      (: (loop l x n)
          (? l (? (= x (A l)) n (loop (B l) x (+ n 1))))
       (loop l x 0))
     (len l) (foldl l 0 inc)

     )

; FIXME the bootstrap compiler should be able to use macros.
  (tset macros
   '::: (:
    (defm n x .) (X ',
     (X (L tset macros (Q n) (A x))
      (? (B x) (ap defm (B x)))))
    defm)
   'literal ev
   'AA (\ x (L A (L A x))) 'AB (\ x (L A (L B x)))
   'BA (\ x (L B (L A x))) 'BB (\ x (L B (L B x)))
   'AAA (\ x (L A (L A (L A x)))) 'AAB (\ x (L A (L A (L B x))))
   'ABA (\ x (L A (L B (L A x)))) 'ABB (\ x (L A (L B (L B x))))
   'BAA (\ x (L B (L A (L A x)))) 'BAB (\ x (L B (L A (L B x))))
   'BBA (\ x (L B (L B (L A x)))) 'BBB (\ x (L B (L B (L B x))))
   'char (\ x (schr x 0))
   '&& (\ x . (? x ((: (& x) (? (B x) (L ? (A x) (& (B x))) (A x))) x) 1))
   '|| (\ x . ((: (| x) (? x (: q (sym) (L ': q (A x) (L ? q q (| (B x))))))) x))
   '>>= (\ x . (? (> (len x) 1) (X (last x) (init x))
                                (: y (sym) (L \ y (X y x)))))
   'case (\ x a . (:
     y (sym)
     (loop a)
      (? a (? (~ (B a)) (A a)
       (L ? (L '= y (A a)) (A (B a))
        (loop (B (B a))))))
    (L ': y x (loop a)))))
  )

  )
; this is the compiler source that's eval'd by stage 1, then
; again by itself to produce the final eval function. you can't
; use any macros in here, because stage 1 doesn't know about
; macros.
(: egg '(, (:
   ; XXX be systematic about this
   pure (set
    L X A B Q + - * / % & | ^ << >> I K flip inc dec co
    = ~ <= >= < > cu const snoc init last memq at idx len
    twop nilp symp nump tblp strp homp
    && || scat slen schr ssub str)

   ; these enable extra partial evaluation for functions
   ; with certain algebraic properties. the nullary case for
   ; any grouplike function has to return its structure's
   ; identity element.
   abelians (set && || + *) ; arguments can be combined freely
   monoids (set scat append) ; pairs of consecutive arguments can be combined in place

   (homp-strict x) (? (homp x) (~ (= i-disp (peek x))))


 ; instruction fusion table
 fuse (:

  ; a common case is to rewrite the last emitted
  ; instruction or value according to an exact table
  ; of values
  ((f1 g xs .) i p)
   ((\ a q
    ((: (loop x) (?
     (~ x)       (poke i p)
     (= a (A x)) (pokef (AB x) q)
     (loop (BB x)))) xs))(g p) (seek p 1))

  ; for idempotent instructions
  (idem i h) (? (= i (peek h)) h (poke i h))

  ; for specialized indexed instructions
  (argn xs .) (ap f1 (X peek ((: (loop n xs)
    (? xs (X n (X (A xs) (loop (+ n 1) (B xs)))))) 0 xs)))

  ; for specialized branch instructions ;
  ; takes an argument for each branch case
  (br2 b c) (f1 peek i-br1 b i-br0 c)

  (tbl
   ; this along with "return forwarding" in branches is how
   ; tail calls get optimized.
   i-call (\ i h (? (= i-ret (peek (seek h 1)))
    (poke i-rec (poke (peek h) (seek h 1)))
    (poke i h)))
   i-argn (argn i-arg0 i-arg1 i-arg2 i-arg3)
   i-sl1n (argn i-sl10 i-sl11 i-sl12 i-sl13)
   i-clon (argn i-clo0 i-clo1 i-clo2 i-clo3)
   i-lt (br2 i-brl i-brl2)
   i-lteq (br2 i-brle i-brle2)
   i-gt (br2 i-brg i-brg2)
   i-gteq (br2 i-brge i-brl)
   i-eq (br2 i-bre i-brn)
   i-nilp_ (f1 peek i-br1 i-br0 i-br0 i-br1)
   i-imm (f1 peek 0 i-imm0 1 i-imm1 2 i-imm2 -1 i-immn1)
   i-idmo idem
   i-idtwo idem
   i-idno idem
   i-idtbl idem
   ))

 ; special function compiler table
 ; each entry has type (hom m e) k x
 inliners (:

  (rw-monoidal f m x) (:
   (fold f m x) (? (~ x) (L m)
    (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
     (: z (fold f m (B x)) (X (A z) (X y (B z))))))
   (? (= (f) (A (: j (fold f m x)))) (B j) j))

  ; for ordered comparison
  ((ordered i) x k) (?
   ; FIXME this is pretty bad ... also it's wrong now that nil = 0
   ; it would be much simpler just to use the framed version for arity > 2
   (~ x) (imm 0 k)
   (~ (B x)) (imm -1 k)
   (preval (A x) (:
    (fold k x y)
     (preval x (xc i (? (~ y) (push2 k)
      (xc i-br0 (peek2 (xc i-push
       (fold k (A y) (B y))))))))
    (xc i-push (pop2 (fold k (AB x) (BB x)))))))

  ((abelian f i) x k) ((\ x
   (preval (A x) (consumes 'num (binop 'num i k (B x))))) (rw-monoidal f (f) x))

  ; for operations with a defined arity
  (typed i ret-type arg-types .) (: arity (len arg-types) (\ x k (?
   (< (len x) arity) (nope 'wrong 'arity ': (len x) 'of arity)
   (: (fo k z) (co (preval (AA z) (consumes (BA z) k)) (B z))
      (co k z) (? z (fo (xc i-push k) z) k)
      l (xc i (produces ret-type k))
      z (zip X x arg-types)
    (? z (fo l z) l)))))

  (binop t i k x)
   (: (loop t i k x)
       (xc i-push (preval (A x) (consumes t (xc i (binop t i k (B x))))))
    (? x (loop t i k x) (produces t k)))

  ((bitshift f i) x k) (:
   y (rw-monoidal + 0 (B x))
   z (? (nump (A x)) (rw-monoidal f (A x) y) (X (A x) y))
   (preval (A z) (consumes 'num (binop 'num i k (B z)))))

  (tbl
   id (\ x k (preval (A x) k))
   + (abelian + i-add)
   - (\ x k (?
    (~ x) (imm 0 k)
    (~ (B x)) ((typed i-neg 'num 'num) x k)
    (: y (rw-monoidal + 0 (B x))
       z (? (nump (A x)) (rw-monoidal - (A x) y) (X (A x) y))
     (? z (preval (A z) (consumes 'num (binop 'num i-sub k (B z)))) (imm 0 k)))))
   * (abelian * i-mul)
   / (\ x k (?
    (~ x) (imm 1 k)
    (~ (B x)) (preval (A x) (consumes 'num k))
    (: b (rw-monoidal * 1 (B x))
       c (? (nump (A x)) (rw-monoidal / (A x) b) (X (A x) b)))
     (preval (A c) (consumes 'num (binop 'num i-quot k (B c))))
    (imm 1 k)))

   & (abelian & i-band)
   | (abelian | i-bor)
   ^ (abelian ^ i-bxor)
   >> (bitshift >> i-sar)
   << (bitshift << i-sal)

   A (typed i-car 0 'two)
   B (typed i-cdr 0 'two)
   X (typed i-cons 'two 0 0)
   L (\ x k (:
    (loop x k) (? (~ x) k
     (loop (B x)
      (xc i-push
       (preval (A x)
        (xc i-cons
         (produces 'two k))))))
    (imm 0 (loop x k))))


   poke (typed i-poke 'hom 0 'hom)

   tget (typed i-tget 0    'tbl 0)
   tset (typed i-tset 0    'tbl 0 0)
   tlen (typed i-tlen 'num 'tbl)
   thas (typed i-thas 'num 'tbl 0)

   < (ordered i-lt) <= (ordered i-lteq)
   >= (ordered i-gteq) > (ordered i-gt)
   = (\ x k (?

    (|| (~ x)
     (? (: q (map- (filter x qtd) unq))
        (: r (A q) (any (\ v (~ (= v r))) (B q)))))
     (imm 0 k)

    (~ (B x)) (imm 1 k)

    (preval (A x) (xc i-push (:
     (fold k x y) (:
      l (preval x (xc i-eq (? (~ y) k
         (xc i-br0 (peek2 (fold k (A y) (B y)))))))
      (? y (xc i-dupl l) l))
     (pop2 (fold (push2 k) (AB x) (BB x))))))))

   nilp (typed i-nilp_ 'num 0)
   twop (typed i-twop_ 'num 0)
   homp (typed i-homp_ 'num 0)
   nump (typed i-nump_ 'num 0)
   symp (typed i-symp_ 'num 0)
   strp (typed i-strp_ 'num 0)
   tblp (typed i-tblp_ 'num 0)
   )))
 ; new let expn makes sure ^^^ exist at toplevel & don't cause closures below
 (:

 ; this function creates a new lexical environment.
 ; if the second argument (the parent scope) is nil,
 ; then the expression is compiled in the global scope.
 (env a p n)  (:
  (asig a n) (?
   (~ a) (X n a)
   (? (B a) (= '. (AB a))) (X (- (+ n 1)) (L (A a)))
   (: r (asig (B a) (+ n 1)) (X (A r) (X (A a) (B r)))))
  b (asig a 0)
  (tbl 'arg (B b) 'par p
       'nom n 'def (tbl)
       'val (tbl) 'sig (A b)))

 (toplp e) (nilp (e 'par))


 ; this function is used in several places to look for a
 ; variable's value, or failing that to find where it's bound.
 (look e y) (?
  (thas (e 'val) y)
   (X 'here ((e 'val) y))
  ; toplevel bindings are special. if it's already defined
  ; we usually want to bind early, but we also want to allow
  ; redefinition, so in that case bind late.
  (toplp e) (?
   (? (thas _ns y) (~ (thas (e 'def) y)))
    (X 'here (_ns y))
   (X 'wait _ns))
  (memq (e 'clo) y) (X 'clo e)
  (memq (e 'dfr) y) (X 'wait (e 'val))
  (memq (e 'loc) y) (X 'loc e)
  (memq (e 'arg) y) (X 'arg e)
  (look (e 'par) y))

 ; ltu : compile a lambda expression.
 ; depending on if it encloses any variables, a lambda
 ; expression may or may not have a value at compile time. this
 ; function returns either a function or a pair. in the latter
 ; case A is the list of variables it encloses and B is the
 ; "prototype" thread that expects those variables to be
 ; available in the closure. the enclosing scope generates a
 ; constructor for the closure, which is composed with the
 ; prototype to create an "instance".
 (ltu e nom l) (:
  (loc k) (: loc (f 'loc)
   (? (~ loc) k (poke i-setloc (poke (len loc) k))))
  (ar k) (: i (f 'sig) (?
   (> i 0) (pokef i-arity (poke i k))
   (< i 0) (poke i-varg (poke (- (- i) 1) k))
   k))

  n (? (B l) (B l) ~~)
  anom (? (: en (e'nom)) (X nom en) nom)
  f (env (init n) e anom)
  x (weak-eval f (last n))

  (?
   ; if the function is nonvariadic and all it does is apply
   ; a second known function to its exact list of arguments,
   ; then it's an alias for the second function.
   (? (>= (f 'sig) 0)
      (? (twop x) (? (homp-strict (A x)) (= (B x) (f 'arg)))))
    (A x)
   ; otherwise compile it
   (? (: k (hfin (ar (loc ((preval x ini) 4 f))))
         clo (f 'clo)) ; free variables or no ?
    (X clo k)
    k)))

 ; first compiler moiety : " weak evaluator "
 ; 1. construct the local scope of the function
 ; 2. desugaring, macroexpansion, and partial evaluation
 ;    (constant folding, dead code elimination, etc), which has
 ;    some preliminary "static type checking" as a side effect
 ; it populates the local variables list and the known values
 ; dictionary in the function environment, and returns an
 ; expression with the same value (under eval) as the input,
 ; but pre-evaluated "as much as possible". to tell if an
 ; expression was fully evaluated, check if the image is
 ; quoted.
 (qtd x) (? (twop x) (= (A x) '`) (nilp (symp x)))
 (unq x) (? (twop x) (AB x) x)
 (quote x) (? (|| (symp x) (twop x)) (Q x) x)

 (weak-eval e x)  (:
  ; function symbol sugar ; handles any level of nesting
  (desug-\ x) (? (~ (twop (A x))) x
   (desug-\ (X (AA x)
    (X (X '\ (snoc (BA x) (AB x)))(BB x)))))

  (desug-: y) (? y (,
   (? (qtd (: x (desug-\ y) a (AB x)))
       (tset (e 'val) (A x) (unq a))
      (, (tset (e 'def) (A x) a)
         (walk a)))
   (desug-: (BB x))))

  (walk x) (? (twop x) (: head (A x) (?
   (|| (= head '\) (= head '`)) 0
   (= head ':) (? (= 1 (% (len x) 2)) (desug-: (B x)))
   (each x walk))))

  (, (walk x) (resolve e) (weakest-eval e x)))

 ; this is a huge complicated procedure for "resolving
 ; the addresses" of sets of mutually recursive inner functions
 ; at compile time, so they can be as efficient as toplevel
 ; definitions whenever that's possible. it constructs the
 ; maximum set S of function variables whose definitions
 ; have no free variables not in S. then it arranges for
 ; references to functions in S to get resolved (with
 ; optimizations etc) later, which lets the compiler generate
 ; appropriate code without having a function address yet.
 (resolve e)
  ; only bother with any of this if there are inner defs
  (? (: ks (tkeys (: def (e 'def)))) (:
  ; step one: pass over each inner def for this function and
  ; try to rewrite and evaluate it. if this succeeds, add it
  ; to the known values. otherwise, if the definition is for
  ; a function, collect it into a list.
  (ev-def kvs) (? kvs (?
   (thas (e 'val) (: kv (A kvs) k (A kv)))
    (ev-def (B kvs))
   (: qq (weakest-eval e (B kv)) bb (ev-def (B kvs)) (?
    (qtd (tset (e 'def) k qq))
     (, (tset (e 'val) k (unq qq))
        (tdel (e 'def) k) bb)
    (? (twop qq) (= '\ (A qq)))
     (X (X k qq) bb)
    bb))))

  ; step two: now we have a list of function name/definition
  ; pairs. try and compile each one; if it succeeds, add it to
  ; the known values. otherwise collect the name, definition,
  ; and list of free variables into a list.
  (co-def kvs) (? kvs (: kv (A kvs) rr (co-def (B kvs)) (?
   (twop (: i (ltu e (: k (A kv)) (: v (B kv)))))
    (X (X k (X (A i) v)) rr)
   (, (tset (e 'val) k i)
      (tdel (e 'def) k) rr))))

  ; step three: reject from the list all definitions that
  ; depend on values that won't be available until runtime.
  ; membership in the list is regarded as proof that the
  ; function is available now, so any time a function is
  ; rejected we start over again as it may have been
  ; referenced by a previously accepted function.
  (rm-dep kvs) (rm-dep-r kvs kvs 0)
  (rm-dep-r i kvs q) (:
   (chk i vs) (? (~ vs) 1 (: v (A vs) (?
    (|| (any (\ j (= (A j) v)) i) (thas (e 'val) v))
     (chk i (B vs)))))
   (? (~ kvs) q (?
    (chk i (AB (: kv (A kvs))))
     (rm-dep-r i (B kvs) (X kv q))
    (rm-dep (del i kv)))))

  ; step four ( the last one ) : now we have the desired
  ; set of functions. remove them from the scope's local
  ; variables and add them to a list of deferred values, then
  ; recompile them. since we know each of these functions has
  ; no free variables that aren't being deferred, this time
  ; ltu will definitely return a function, which is stored in
  ; the known value set.
  (co-dfr kvs) (?
   (~ kvs) (tset e'loc (tkeys (e'def)))
   (, (tdel (e 'def) (: kv (A kvs) k (A kv)))
      (tset e 'dfr (X k (e 'dfr)))
      (co-dfr (B kvs))
      (tset (e 'val) k (ltu e k (BB kv)))))

  (co-dfr (rm-dep (co-def (ev-def
   (map- (tset e'loc ks) (\ k (X k (def k))))))))))

 (weakest-eval e x) (:
  (wk-X e x) (:

   ; static arity check : omit the check in the called function
   (check-arity x) (: z (A x) (?
    (~ (? (homp z) (= i-arity (peek z)))) x
    (? (>= (len (B x)) (peek (seek z 1)))
     (X (seek z 2) (B x)) ; this call is ok, skip the check
     (nope'wrong'arity)))) ; oops wrong arity

   (wk-: e x) (:
    (nom s) (? (twop s) (nom (A s)) s)
    (sug d) (L (L '\ (L ', (init d) (last d))))
    (loop e x) (? x (:
     y (nom (A x))
     ll (loop e (BB x))
     (X y (X ((e 'def) y) ll))))
    (? (B x) (? (= 0 (% (len x) 2)) (sug x)
                (X : (loop e (B x))))))

   ; FIXME
   ; this is kind of a half-hearted optimization.
   ; we should ALWAYS be doing this, but without
   ; variable renaming we can only be sure it's
   ; safe in this case.
   (wk-\ e l) (:
    (letrec? l) (? (B l)
     (? (twop (: x (last l)))
      (? (= (A x) ':) (= 1 (% (len (B x)) 2)))))
    (letrec-rw l) (: m (last l)
     (snoc (init l) (L , (init m) (last m))))
    (? (letrec? l) (letrec-rw l) l))

   (wk-monoid f i l) (:
    (fold j x y) (?
     y (? (qtd x) (fold (f j (unq x)) (A y) (B y))
        (: z (X x (fold i (A y) (B y)))
         (? (= i j) z (X j z))))
     (qtd x) ((\ x (? (= i x) 0 (L x)))
              (f j (unq x)))
     (= i j) (L x)
     (L j x))
    (? l (X f (fold i (A l) (B l))) (quote i)))

   (wk-? e x) (:
    (rec e x) (?
     (~ x) (L 0)
     (~ (B x)) (L (weakest-eval e (A x)))
     (~ (qtd (: a (weakest-eval e (A x)))))
      (X a (X (weakest-eval e (A (B x))) (rec e (BB x))))
     (unq a) (L (weakest-eval e (AB x)))
     (rec e (BB x)))
    (? (: r (rec e x)) (? (B r) (X ? r) (A r))))

   (wk-, e x) (:
    (loop e x) (? (~ (B x)) (L (weakest-eval e (A x))) (:
     z (loop e (B x))
     y (weakest-eval e (A x))
     (? (|| (symp y) (qtd y)) z (X y z))))
    (? (: y (B x)) (: z (loop e y)
                    (? (B z) (X ', z) (A z)))))

   a (A x) (?
    (= '` a) (? (B x) x)
    (= '\ a) (wk-\ e x)
    (= ': a) (wk-: e x)
    (= '? a) (wk-? e (B x))
    (= ', a) (wk-, e x)
    ; oh boy ...
    (? (: mac (macros a)) (weakest-eval e (ap mac (B x)))
     (: z (map- x (\ x (weakest-eval e x))) q (A z) r (B z) (?
      (~ (pure q)) (check-arity z)
      (all qtd r) (quote (ap q (map- r unq)))
      (monoids q) (wk-monoid q (q) r)
      (abelians q) (:
       ff (part qtd r)
       fg (ap q (map- (A ff) unq))
       (X q (? (= fg (q)) (B ff) (X fg (B ff)))))
      (check-arity z))))))

  (wk-sym e x) (: l (look e x) (?
   (= (A l) 'here) (quote (B l))
   (~ (thas (: defs (e 'def)) x)) x
   (: dd (weakest-eval e (tdel defs x))
    (? (~ (qtd (tset defs x dd))) x (,
     (tdel (e 'def) x)
     (tset (e 'val) x (unq dd))
     dd)))))

 (? (twop x) (wk-X e x) (symp x) (wk-sym e x) x))

 ; second moiety : " analyzing evaluator "
 ; generates code to produce the value of the expression
 ; produced by the first moiety.

 ((xc i k) m e) (pokef i (k (+ m 1) e))
 ((xd x k) m e) (poke x (k (+ m 1) e))

 (pokef i h) ((? (: q (fuse i)) q poke) i h)

 (imm x k) (:
  (type-sym x) (?
   (nump x) 'num (twop x) 'two
   (symp x) 'sym (strp x) 'str
   (tblp x) 'tbl (homp x) 'hom)
  (xc i-imm (xd x (produces (type-sym x) k))))

 ; these make functions that do certain side effects
 ; with env stack structures during code generation:
 ; either manipulate the stack or embed the item at the
 ; top into the thread.
 (((pushr s) k) m e) (: q (k m e) (A (tset e s (X q (e s)))))
 (((popr  s) k) m e) (: q (k m e) (, (tset e s (B (e s))) q))
 (((peekr s) k) m e) (: q (k (+ m 1) e) (poke (A (e s)) q))

 push1 (pushr 's1) push2 (pushr 's2)
 pop1  (popr  's1) pop2  (popr  's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 ; these functions are for type checking
 (consumes t k) (? (~ t) k
  (xc (? (= t 'two) i-idtwo (= t 'num) i-idno
         (= t 'hom) i-idmo (= t 'tbl) i-idtbl
         (nope 'consumes)) k))

 (produces t k) (:
  (subtype? a b) (|| (= a b)
   (&& (= b 'hom) (nilp (= a 'num))))
  (con i) (?
   (= i i-idmo) 'hom (= i i-idno) 'num
   (= i i-idtwo) 'two (= i i-idtbl) 'tbl)
  (pro t h)
   (? (nilp (: q (con (peek h)))) h
      (subtype? t q) (pro t (seek h 1))
      (nope 'type 'error ': t 'for q))
  (? (nilp t) k (\ m e (pro t (k m e)))))


 (preval x k) (:
  (pre-X x k) (:
   (pre-? x k) (:
    (loop x k) (:
     (fin m e) (:
      thd (k (+ m 2) e)
      ex (A (e 's2))
      i (peek ex)
      (? (= i i-ret) (poke i thd) ; forward return instructions
       (pokef i-jump ; otherwise jump somewhere ...
        (poke (? (= i i-jump) (peek (seek ex 1)) ex) thd))))
     (? (~ (B x)) (preval (A x) fin)
      (preval (A x) (pop1 (xc i-br1 (peek1
       (loop (BB x) (push1 (preval (AB x) fin)))))))))
    (pop2 (loop x (push2 k))))

   ((pre-\ x k) m e) (:
    (nom e k) ; try to pick a name for this function
     (: i (peek k) (?
      (= i i-deftop) (A (peek (seek k 1))) ; maybe we're about to set a global?
      (= i i-defsl1) (at (e 'loc) (peek (seek k 1))))) ; or a local

    (clo-thd e x k) (:
     (loop x k) (? (~ x) k
      (loop (B x) (preval (A x) (xc i-push k))))
     (k m) (poke i-take (poke (len x) (hom m)))
     ((loop x k) 2 e))

    l ((produces 'hom k) (+ m 2) e)
    y (ltu e (nom e l) x)
    (? (twop y)
        (pokef (? (e 'loc) i-encl1 i-encl0)
         (poke (X (B y) (clo-thd e (A y) k)) l))
       (pokef i-imm (poke y l))
     ))

   (pre-, x k) (? x (preval (A x) (pre-, (B x) k)) k)
   (pre-ap a b k) (:
    (loop x k) (? (~ x) k
     (loop (B x) (preval (A x) (xc i-push k))))
    (? (? (qtd a) (: q (inliners (unq a)))) (q b k)
     (loop b (preval a (consumes 'hom ; tail call optimization is handled by instruction fusion
      (xc i-call (xd (len b) k))))))) ; here is where you would do it instead

   ((pre-: x k) m e) (:
   ; the rewrite ensures the : expression is always an even form.
    (loop x k) (? (~ x) k (:
     l (loop (BB x) k)
     m (? (~ (|| (toplp e) (memq (e 'loc) (A x)))) l
          (toplp e) (xc i-deftop (xd (X _ns (A x)) l))
          (xc i-defsl1 (xd (idx (e 'loc) (A x)) l)))
     (? (= 'here (A (: v (look e (A x)))))
      (imm (B v) m) (preval (AB x) m))))

    ((loop x k) m e))

   (: z (A x) (?
    (= z '`) (imm (AB x) k)
    (= z '?) (pre-? (B x) k)
    (= z ':) (pre-: (B x) k)
    (= z '\) (pre-\ x k)
    (= z ',) (pre-, (B x) k)
    (pre-ap z (B x) k))))

  ((pre-sym x k) m e) (:
   ; TODO subsume runtime type check
   (late d) (pokef i-late (poke (X d x) (k (+ m 2) e)))

   s (A (: r (look e x))) (?
    (= s 'here) ((imm (B r) k) m e)
    (= s 'wait) (late (B r))
    (= e (B r)) (
     (xc (? (= s 'arg) i-argn (= s 'loc) i-sl1n (= s 'clo) i-clon)
      (xd (idx (e s) x) k)) m e)
    (, (: l (len (e 'clo)))
       (tset e 'clo (snoc (e 'clo) x))
       ((xc i-clon (xd l k)) m e))))

  ((? (twop x) pre-X (symp x) pre-sym imm) x k))

 (ini m e) ((xc i-ret (xd (e 'nom) hom)) m e)
 (ev x) (: e (env 0 0 0) (((preval (weak-eval e x) ini) 0 e) x))
  ;; end of compiler namespace ; now return the eval function
;  ev ; comment this line to define internals at toplevel
  )))
; bootstrap

(ev prelude)
(tset _ns 'ev (ev egg))
(ev prelude)
(tset _ns 'ev (ev egg))
(tset macros 'imm ev)

; " drop privileges "
(:; dels (cu (flip each) (cu tdel _ns))
;   locs '(egg poke macros hom seek peek hfin _ns)
;   insns (filter (tkeys _ns) (\ k (= "i-" (ssub (ynom k) 0 2))))
  (,
    (tdel _ns 'egg)
    (tdel _ns 'macros)
;    (tdel _ns '_ns)
;    (dels insns)
;    (dels locs)
  )
)
;ev
(:
 ((diag f) x) (f x x)

 ; strings
 (strip-prefix p s)
  (? (= p (ssub s 0 (: a (slen p)))) (ssub s a (slen s)))
 (chars s)
  (: (loop s n)
      (? (< n (slen s))
       (X (schr s n) (loop s (+ n 1))))
   (loop s 0))
 (puts s)
  (: (loop s n)
   (? (< n (slen s))
    (, (putc (schr s n))
       (loop s (+ n 1))))
   (loop s 0))
  (endl) (putc 10)
 (iota n x .)
  (: (loop m n) (? (< m n) (X m (loop (+ m 1) n)))
   (? (~ x) (loop 0 n) (loop n (A x))))
 (rho n xs .)
  (: (loop n x) (? (= n 1) x (append x (loop (- n 1) x)))
   (? (> n 0) (loop n xs))))
