(: true -1 ~~ '(()) ~ nilp)

(:
 prelu '(,
  (:
     ; data constructors
     (L . .) .
     (Q x) (L '` x)

     (AA x) (A (A x)) (AB x) (A (B x))
     (BA x) (B (A x)) (BB x) (B (B x))

     ; functional programmings
     (id x) x
     ;(const x) (\ x) ; the "clean" definition uses a closure; more efficient to just make a thread!
     (const x) (poke i-imm (poke x (poke i-ret (poke 'const (hom 4)))))
     (co xs .) (foldl1 xs (\ m f (\ x . (f (ap m x)))))
     ((flip f) x y) (f y x)
     ((cu f x .) y .) (ap f (append x y))
     (map x f) (? (twop x) (X (f (A x)) (map (B x) f)) x)
     (append a b) (? (twop a) (X (A a) (append (B a) b)) b)
     (cat xs .) (foldr xs 0 append)

     ; logic
     (all l p) (? l (? (p (A l)) (all (B l) p)) true)
     (any l p) (? l (? (p (A l)) true (any (B l) p)))
     ; && and || are also macros
     (&& l .) (all l id)
     (|| l .) (any l id)

     (each x f) (? x (, (f (A x)) (each (B x) f)))
     (part p l) (foldr l ~~ (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))

     ; tables
     (set x .) (foldl x (tbl) (\ t x (, (tset t x true) t)))

     ; numbers
     (inc x) (+ x 1) (dec x) (- x 1)

     ; lists
     (at l n) (? (< n 1) (A l) (at (B l) (- n 1)))
     (filter x p) (foldr x () (\ x m (? (p x) (X x m) m)))
     (foldr x z f) (? (twop x) (f (A x) (foldr (B x) z f)) z)
     (foldl x z f) (? (twop x) (foldl (B x) (f z (A x)) f) z)
     (foldl1  x f) (foldl (B x) (A x) f)
     (foldr1  x f) (?
      (twop (B x))
       (f (A x) (foldr1 (B x) f))
      (A x))
     (zip f a .) (? (all a id)
      (X (ap f (map a A)) (ap zip (X f (map a B)))))
     (len l) (foldl l 0 inc)
     (snoc l x) (? l (X (A l) (snoc (B l) x)) (L x))
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (memq x k) (? x (? (= k (A x)) x (memq (B x) k)))
     (del l k) (filter l (\ x (nilp (= x k))))
     (idx l x)
      ((: (loop l x n)
           (? l (? (= x (A l)) n (loop (B l) x (+ n 1)))))
       l x 0))

  (tset macros
   '::: (:
    (defm n x .) (X ',
     (X (L tset macros (L '` n) (A x))
      (? (B x) (ap defm (B x)))))
    defm)
   'literal ev
   'AA (\ x (L A (L A x))) 'AB (\ x (L A (L B x)))
   'BA (\ x (L B (L A x))) 'BB (\ x (L B (L B x)))
   'AAA (\ x (L A (L A (L A x)))) 'AAB (\ x (L A (L A (L B x))))
   'ABA (\ x (L A (L B (L A x)))) 'ABB (\ x (L A (L B (L B x))))
   'BAA (\ x (L B (L A (L A x)))) 'BAB (\ x (L B (L A (L B x))))
   'BBA (\ x (L B (L B (L A x)))) 'BBB (\ x (L B (L B (L B x))))
   'char (\ x (schr x 0))
   '&& (\ x . (? x ((: (& x) (? (B x) (L '? (A x) (& (B x))) (A x))) x) true))
   '|| (\ x . (: q (sym) (foldr x 0 (\ x m (L (L '\ q (L '? q q m)) x)))))
   '>>= (\ x . (X (last x) (init x)))
   ':where (\ x dfns . (X ': (snoc dfns x)))
   ))

; this is the compiler source that's eval'd by stage 1, then
; again by itself to produce the final eval function. you can't
; use any macros in here, because stage 1 doesn't know about
; macros.
 egg '(:
   ; XXX be systematic about this!
   ; obviously we should be able to tell a function is pure
   ; if it's composed of pure functions/operations ...
   pure (set
    L X A B Q + - * / % & | ^ << >> id const flip co
    = ~ <= >= < > cu snoc init last memq at idx len
    twop nilp symp nump tblp strp homp append
    && || scat slen schr ssub str)

   ; these enable extra partial evaluation for functions
   ; with certain algebraic properties. the nullary case for
   ; any grouplike function has to return its structure's
   ; identity element.
   abelians (set && || + * | &) ; arguments can be combined freely
   monoids (set scat) ; pairs of consecutive arguments can be combined in place


 ; instruction fusion table
 fuse (:

  ; a common case is to rewrite the last emitted
  ; instruction or value according to an exact table
  ; of values
  ((f1 xs .) i p) (:
   (loop i p a x) (?
    (nilp x) (poke i p)
    (= a (A x)) (pokef (AB x) (seek p 1))
    (loop i p a (BB x)))
   (loop i p (peek p) xs))

  ; for idempotent instructions
  (idem i h) (? (= i (peek h)) h (poke i h))

  ; for specialized indexed instructions
  (argn xs .) (ap f1 ((: (loop n xs)
    (? xs (X n (X (A xs) (loop (+ n 1) (B xs)))))) 0 xs))

  ; for specialized branch instructions ;
  ; takes an argument for each branch case
  (br2 b c) (f1 i-br1 b i-br0 c)

  (tbl
   ; this along with "return forwarding" in branches is how
   ; tail calls get optimized.
   i-call (\ i h (? (= i-ret (peek (seek h 1)))
    (poke i-rec (poke (peek h) (seek h 1)))
    (poke i h)))
   i-argn (argn i-arg0 i-arg1 i-arg2 i-arg3)
   i-sl1n (argn i-sl10 i-sl11 i-sl12 i-sl13)
   i-clon (argn i-clo0 i-clo1 i-clo2 i-clo3)
   i-lt (br2 i-brl i-brl2)
   i-lteq (br2 i-brle i-brle2)
   i-gt (br2 i-brg i-brg2)
   i-gteq (br2 i-brge i-brl)
   i-eq (br2 i-bre i-brn)
   i-nilp_ (f1 i-br1 i-br0 i-br0 i-br1)
   i-imm (f1 0 i-imm0 1 i-imm1 2 i-imm2 -1 i-immn1)
   i-idmo idem
   i-idtwo idem
   i-idno idem
   i-idtbl idem))

 ; special function compiler table
 ; each entry has type ((value) m e) k x
 inliners (:

  (rw-monoidal f m x) (:
   (fold f m x) (? (nilp x) (L m)
    (? (quoted? (A x)) (fold f (f m (unquote (A x))) (B x))
     (: z (fold f m (B x)) (X (A z) (X (A x) (B z))))))
   (? (= (f) (A (: j (fold f m x)))) (B j) j))

  ; for comparison operators
  ((compar f i) x k) (?
   (|| (nilp x) (nilp (B x))) (imm true k)
   (nilp (BB x))
    (co-ev (A x) (emc i-push (co-ev (AB x) (emc i k))))
   (co-apply f x k))

  ((abelian f i) x k) (: y (rw-monoidal f (f) x)
   (co-ev (A y) (consumes 'num (binop 'num i k (B y)))))

  ; for operations with a defined arity
  (typed i ret-type arg-types .) (\ x k (?
   (< (len x) (len arg-types)) (nope 'wrong 'arity ': (len x) 'of (len arg-types))
   (: (fo k z) (co (co-ev (AA z) (consumes (BA z) k)) (B z))
      (co k z) (? z (fo (emc i-push k) z) k)
      l (emc i (produces ret-type k))
      z (zip X x arg-types)
    (? z (fo l z) l))))

  (binop t i k x)
   (: (loop t i k x)
       (emc i-push
        (co-ev (A x)
         (consumes t
          (emc i (binop t i k (B x))))))
    (? x (loop t i k x) (produces t k)))

  ((bitshift f i) x k) (:
   y (rw-monoidal + 0 (B x))
   z (? (nump (A x)) (rw-monoidal f (A x) y) (X (A x) y))
   (co-ev (A z) (consumes 'num (binop 'num i k (B z)))))

  (tbl
   id (\ x k (co-ev (A x) k))
   + (abelian + i-add)
   - (\ x k (?
    (nilp x) (imm 0 k)
    (nilp (B x)) ((typed i-neg 'num 'num) x k)
    (: y (rw-monoidal + 0 (B x))
       z (? (nump (A x)) (rw-monoidal - (A x) y) (X (A x) y))
     (? z (co-ev (A z) (consumes 'num (binop 'num i-sub k (B z)))) (imm 0 k)))))
   * (abelian * i-mul)
   / (\ x k (?
    (nilp x) (imm 1 k)
    (nilp (B x)) (co-ev (A x) (consumes 'num k))
    (: b (rw-monoidal * 1 (B x))
       c (? (nump (A x)) (rw-monoidal / (A x) b) (X (A x) b)))
     (co-ev (A c) (consumes 'num (binop 'num i-quot k (B c))))
    (imm 1 k)))

   & (abelian & i-band)
   | (abelian | i-bor)
   ^ (abelian ^ i-bxor)
   >> (bitshift >> i-sar)
   << (bitshift << i-sal)

   A (typed i-car 0 'two)
   B (typed i-cdr 0 'two)
   X (typed i-cons 'two 0 0)
   L (\ x k (:
    (loop x k) (? (nilp x) k
     (loop (B x)
      (emc i-push
       (co-ev (A x)
        (emc i-cons
         (produces 'two k))))))
    (imm 0 (loop x k))))


   poke (typed i-poke 'hom 0 'hom)

   tget (typed i-tget 0    'tbl 0)
   tset (typed i-tset 0    'tbl 0 0)
   tlen (typed i-tlen 'num 'tbl)
   thas (typed i-thas 'num 'tbl 0)

   < (compar < i-lt) <= (compar <= i-lteq)
   >= (compar >= i-gteq) > (compar > i-gt)
   = (compar = i-eq)

   ; FIXME these should be variadic
   nilp (typed i-nilp_ 'num 0)
   twop (typed i-twop_ 'num 0)
   homp (typed i-homp_ 'num 0)
   nump (typed i-nump_ 'num 0)
   symp (typed i-symp_ 'num 0)
   strp (typed i-strp_ 'num 0)
   tblp (typed i-tblp_ 'num 0))) ; end inliners

 (pokef i h) (>>= i h (fuse i) (\ i h q ((? q q poke) i h)))
 ((emc i k) m e) (pokef i (k (+ m 1) e))
 ((emd x k) m e) (poke x (k (+ m 1) e))


 ; this function creates a new lexical environment.
 ; if the second argument (the parent scope) is nil,
 ; then the expression is compiled in the global scope.
 (env arg par nom)  (:
  (ary-sig a n) (?
   (nilp a) (X n a)
   (? (B a) (= '. (AB a))) (X (- (+ n 1)) (L (A a)))
   (: r (ary-sig (B a) (+ n 1)) (X (A r) (X (A a) (B r)))))
  sig-arg (ary-sig arg 0)
  (tbl 'arg (B sig-arg) 'par par 'nom nom ;'lam (tbl)
       'def (tbl) 'val (tbl) 'sig (A sig-arg)))

 (toplp e) (nilp (e 'par))

 ; this function is used in several places to look for a
 ; variable's value, or failing that to find where it's bound.
 (look e y) (?
  (thas (e 'val) y) (X 'here ((e 'val) y))
  (toplp e)
   ; toplevel bindings are special. if it's already defined
   ; we usually want to bind early, but we also want to allow
   ; redefinition, so in that case bind late.
   (? (&& (thas _ns y) (nilp (thas (e 'def) y)))
    (X 'here (_ns y))
    (X 'wait _ns))
  (memq (e 'loc) y) (X 'loc e)
  (memq (e 'arg) y) (X 'arg e)
  (memq (e 'clo) y) (X 'clo e)
  (memq (e 'dfr) y) (X 'wait (e 'val))
  (look (e 'par) y))

 ; ltu : compile a lambda expression.
 ; depending on if it encloses any variables, a lambda
 ; expression may or may not have a value at compile time. this
 ; function returns either a function or a pair. in the latter
 ; case A is the list of variables it encloses and B is the
 ; "prototype" thread that expects those variables to be
 ; available in the closure. the enclosing scope generates a
 ; constructor for the closure, which is composed with the
 ; prototype to create an "instance".
 (ltu lx-scope nom b0) (:
  ((w/locals k) m e) (>>= (k (+ m 2) e) (\ k (?
   (e 'loc) (pokef i-setloc (poke (len (e 'loc)) k))
   k)))
  ((w/arity k) m e) (>>= (k (+ m 2) e) (e 'sig) (\ k sig (?
   (> sig 0) (pokef i-arity (poke sig k))
   (< sig 0) (pokef i-varg (poke (- (- sig) 1) k))
   k)))

  args-body (? b0 b0 ~~)
  full-name (?
   (nilp nom) (lx-scope 'nom)
   (lx-scope 'nom) (X nom (lx-scope 'nom))
   nom)
  fn-scope (env (init args-body) lx-scope full-name)
  body (weak-ev fn-scope (last args-body))

  (?
   (&& (>= (fn-scope 'sig) 0) ; if the function is nonvariadic
       (twop body) ; and the body just applies
       (homp (A body)) (quoted? (A body)) ; a second known function
       (= (B body) (fn-scope 'arg))) ; to its exact argument list
    (A body) ; then it's an alias for the second function.
   ; otherwise compile it!
   (, (: out (hfin
           ((w/arity (w/locals (co-ev body (ini full-name))))
            0 fn-scope)))
    (? (fn-scope 'clo) ; are there closure variables?
        (X (fn-scope 'clo) out) ; if so return a pair of the vars and the thread.
       out)))) ; otherwise return the fully compiled function.

 (quoted? x) (? (twop x) (= (A x) '`) (nilp (symp x)))
 (unquote x) (? (twop x) (AB x) x)
 (quote x) (? (|| (symp x) (twop x)) (L '` x) x)
 (lambda? x) (&& (twop x) (= '\ (A x)))
 ; first compiler moiety : " weak evaluator "
 ; 1. construct the local scope of the function
 ; 2. desugaring, macroexpansion, and partial evaluation
 ;    (constant folding, dead code elimination, etc), which has
 ;    some preliminary "static type checking" as a side effect
 ; it populates the local variables list and the known values
 ; dictionary in the function environment, and returns an
 ; expression with the same value (under eval) as the input,
 ; but pre-evaluated "as much as possible". to tell if an
 ; expression was fully evaluated, check if the image is
 ; quoted.

 ; partial evaluator
 (weak-ev e x)  (:
  ; desugars a *leading* function symbol in a dfns list.
  (desug-fn-sym dfns) (? (nilp (twop (A dfns))) dfns
   (desug-fn-sym (X (AA dfns)
    (X (X '\ (snoc (BA dfns) (AB dfns)))(BB dfns)))))

  (scan-let dfns) (? dfns (>>= (desug-fn-sym dfns) (\ dfns (,
   (scan (tset (e 'def) (A dfns) (AB dfns)))
   (scan-let (BB dfns))))))

  ; scan an expression for variable definitions.
  (scan x) (?
   (nilp (twop x)) 0 ; skip atoms
   (= '` (: head (A x))) 0 ; skip quotations
   (= '\ head) 0 ;(co-lam- e 0 x) ; skip lambdas FIXME really?
   (= ': head) ; descend into *even* let expressions
    (? (= 0 (% (len (B x)) 2)) (scan-let (B x)))
   (each x scan)) ; otherwise recur on subexpressions.

  (wev x) (:
   (rw-sym x) (?
    (= (A (: l (look e x))) 'here) (quote (B l))
    (&& (thas (: defs (e 'def)) x)
        (quoted? (tset defs x (wev (tdel defs x)))))
     (tset (e 'val) x (unquote (tdel defs x)))
    x)

   (rw-list x) (:
    ; FIXME optimization
    ; static arity check : omit the check in the called function.
    ; assumes the arity check, if present, is the 1st instruction.
    (check-arity x) (: z (A x) (?
     (nilp (&& (homp z) (= i-arity (peek z)))) x
     (? (>= (len (B x)) (peek (seek z 1)))
      (X (seek z 2) (B x)) ; this call is ok, skip the check
      (, (ap z (B x)) ; oops wrong arity, call the function to get an error
         0)))) ; avoid a tail call to get a more informative backtrace

    (rw-let x) (:
     (nom s) (? (twop s) (nom (A s)) s)
     (sug d) (L (L '\ (L ', (init d) (last d))))
     (loop e x) (? x (:
      y (nom (A x))
      ll (loop e (BB x))
      (X (L ': y ((e 'def) y)) ll)))
     (? (= 1 (% (len (B x)) 2)) (sug x)
        (X ', (loop e (B x)))))

    (rw-lambda l) (:
     ; FIXME an oddly specific and bad optimization.
     ; it rewrites a lambda expression of the form
     ;   (\ args (: vars vals xpn)) 
     (letrec? l) (? (B l)
      (? (twop (: x (last l)))
       (? (= (A x) ':) (= 1 (% (len (B x)) 2)))))
     ; to the form
     ;   (\ args (, (: vars vals) xpn))
     (rw-letrec l) (: m (last l)
      (snoc (init l) (L ', (init m) (last m))))
     ; which (currently) generates slightly more
     ; efficient code. effectively we should ALWAYS
     ; be doing this, but without variable renaming
     ; this is the only case where we can be sure
     ; it's safe in this case. so, we do it here.
     (? (letrec? l) (rw-letrec l) l))

    (rw-monoid f i l) (:
     ; XXX is this even right?
     (fold j x y) (?
      y (? (quoted? x) (fold (f j (unquote x)) (A y) (B y))
           (: z (X x (fold i (A y) (B y))) (? (= i j) z (X j z))))
      (quoted? x) (? (= i (: y (f j (unquote x)))) 0 (L y))
      (= i j) (L x)
      (L j x))
     (? l (X f (fold i (A l) (B l))) (quote i)))

    (rw-cond x) (:
     (rec x) (?
      (nilp x) 0
      (nilp (B x)) (wev (A x))
      (nilp (quoted? (: a (wev (A x)))))
       (L '? a (wev (A (B x))) (rec (BB x)))
      (unquote a) (wev (AB x))
      (rec (BB x)))
     (rec (B x)))

    (rw-begin x) (? (B x) (:
     (loop x) (? (nilp (B x)) (L (wev (A x)))
      (>>= x (loop (B x)) (wev (A x)) (\ x z y
       (? (? (symp y) true (quoted? y)) z (X y z)))))
     (? (B (: z (loop (B x)))) (X ', z) (A z))))

    (?
     ; special forms
     (= '` (: a (A x))) (? (twop (B x)) x)
     (= '\ a) (rw-lambda x)
     (= ': a) (rw-let x)
     (= '? a) (rw-cond x)
     (= ', a) (rw-begin x)
     ; is it a macro ?
     (: macro (macros a)) (wev (ap macro (B x)))
     ; nope, it's a function call.
     (: z (map x wev) q (A z) r (B z) (?
      ; if it's pure & its arguments are all here then we can call it now.
      (&& (pure q) (all r quoted?))
       (quote (ap q (map r unquote)))
      ; if it's an abelian operator we may be able to partially apply it
      (abelians q) (:
       ff (part quoted? r)
       fg (ap q (map (A ff) unquote))
       (X q (? (= fg (q)) (B ff) (X fg (B ff)))))
      ; or if it's monoidal ...
      (monoids q) (rw-monoid q (q) r)
      ; otherwise we can at least try and check the arity.
      (check-arity z)))))

   (? (twop x) (rw-list x) (symp x) (rw-sym x) x))

  ; this is a huge complicated procedure for "resolving
  ; the addresses" of sets of mutually recursive inner functions
  ; at compile time, so they can be as efficient as toplevel
  ; definitions whenever that's possible. it constructs the
  ; maximum set S of function variables whose definitions
  ; have no free variables not in S. then it arranges for
  ; references to functions in S to get resolved (with
  ; optimizations etc) later, which lets the compiler generate
  ; appropriate code without having a function address yet.
  (resolve-dfns) (: def (e 'def) val (e 'val)
    ; step one: pass over each inner def for this function and
    ; try to rewrite and evaluate it. if this succeeds, add it
    ; to the known values. otherwise, if the definition is for
    ; a function, collect it into a list.
    (re-ev-dfns dfns) (? dfns (:
     coll (re-ev-dfns (B dfns))
     nom (AA dfns) defn (wev (BA dfns))
     (? (quoted? (tset def nom defn))
         (, (tset val nom (unquote defn))
            (tdel def nom) coll)
        (lambda? defn) (X (X nom defn) coll)
        coll)))

    ; step two: now we have a list of function name/definition
    ; pairs. try and compile each one; if it succeeds, add it to
    ; the known values. otherwise collect the name, definition,
    ; and list of free variables into a list.
    (re-co-dfns dfns) (? dfns (:
     coll (re-co-dfns (B dfns))
     co (, ;(.'resolve'ltu (e'nom))
           (ltu e (: nom (AA dfns)) (B (: body (BA dfns)))))
     (?  (twop co) ; if ltu returns a pair there are closure vars; collect the name & def
          (X (X nom (X (A co) body)) coll)
         (, (tdel def nom) ; otherwise it's a fully-compiled thread so add it to the known values.
            (tset val nom co)
            coll))))

    ; step three: reject from the list all definitions that
    ; depend on values that won't be available until runtime.
    ; membership in the list is regarded as proof that the
    ; function is available now, so any time a function is
    ; rejected we start over again as it may have been
    ; referenced by a previously accepted function.
    (re-rm-deps dfns) (re-rm-deps-r dfns dfns ())
    (re-rm-deps-chk maybes vs) (?
     (nilp vs) true
     (|| (thas val (: v (A vs)))
         (any maybes (\ j (= (A j) v))))
      (re-rm-deps-chk maybes (B vs)))
    (re-rm-deps-r maybes dfns coll) (?
     (nilp dfns) coll
     (re-rm-deps-chk maybes (AB (: dfn (A dfns))))
      (re-rm-deps-r maybes (B dfns) (X dfn coll))
     (re-rm-deps (del maybes dfn)))

    ; step four ( the last one ) : now we have the desired
    ; set of functions. remove them from the scope's local
    ; variables and add them to a list of deferred values, then
    ; recompile them. since we know each of these functions has
    ; no free variables that aren't being deferred, this time
    ; ltu will definitely return a function, which is stored in
    ; the known value set.
    (re-co-dfrs dfns) (?
     (nilp dfns) (tset e 'loc (tkeys def)) ; we're done, set the local variable list
     (, (tdel def (: dfn (A dfns) nom (A dfn)))
        (tset e 'dfr (X nom (e 'dfr)))
        (re-co-dfrs (B dfns))
        (tset val nom (ltu e nom (B (BB dfn))))))

    (re-co-dfrs
     (re-rm-deps
      (re-co-dfns
       (re-ev-dfns
        (map (tset e 'loc (tkeys def))
         (\ k (X k (def k)))))))))

  (, (scan x) (resolve-dfns) (wev x)))



 ; second moiety : " analyzing evaluator "
 ; generates code to produce the value of the expression
 ; produced by the first moiety.

 (imm x k) (:
  type-sym (?
   (nump x) 'num (twop x) 'two
   (symp x) 'sym (strp x) 'str
   (tblp x) 'tbl 'hom)
  (emc i-imm (emd x (produces type-sym k))))

 ; these functions are for type checking
 (consumes t k) (? (nilp t) k (:
  type-check (?
   (= t 'two) i-idtwo (= t 'num) i-idno
   (= t 'hom) i-idmo (= t 'tbl) i-idtbl
   (nope'consumes':'what'is'a t))
  (emc type-check k)))

 (produces t k) (:
  (subtype? a b)
   ; currently fixnums are their own thing & every
   ; other kind of data also counts as a hom.
   (|| (= a b) (&& (= b 'hom) (nilp (= a 'num))))
  (con i) (? (= i i-idmo) 'hom (= i i-idno) 'num
             (= i i-idtwo) 'two (= i i-idtbl) 'tbl)
  (pro t h) (?
   (nilp (: q (con (peek h)))) h
   (subtype? t q) (pro t (seek h 1))
   (nope'produces':'type'error': t'for q))
  (? (nilp t) k (\ m e (pro t (k m e)))))

 (co-apply fn args k) (foldl args
  (co-ev fn (consumes 'hom (emc i-call (emd (len args) k))))
  (\ k x (co-ev x (emc i-push k))))

 ; these make functions that do certain side effects
 ; with env stack structures during code generation:
 ; either manipulate the stack or embed the item at the
 ; top into the thread.
 ((pushr s k) m e) (>>= e s (k m e) (\ e s q (A (tset e s (X q (e s))))))
 ((popr  s k) m e) (>>= e s (k m e) (\ e s q (, (tset e s (B (e s))) q)))
 ((peekr s k) m e) (>>= (e s) (k (+ m 1) e) (\ r q (poke (A r) q)))

 (co-ev x k) ((? (twop x) co-list (symp x) co-sym imm) x k)

 ((co-sym x k) m e) ((?
  ; FIXME this mutates the environment by populating closure
  ; variables ; we should have already done that by now!
  (= (: s (A (: r (look e x)))) 'here) (imm (B r) k)
  (= s 'wait) (emc i-late (emd (X (B r) x) k)) ; TODO subsume runtime type check
  (= e (B r))
   (emc (? (= s 'arg) i-argn (= s 'loc) i-sl1n (= s 'clo) i-clon)
    (emd (idx (e s) x) k))
  (, (: l (len (e 'clo)))
     ;(.'clo'add (e'nom) x)
     (tset e 'clo (snoc (e 'clo) x))
     (emc i-clon (emd l k)))) m e)

 (co-list x k) (: z (A x) (?
  (= '` z) (imm (AB x) k)
  (= '? z) (co-cond (AB x) (A (BB x)) (AB (BB x)) k)
  (= ': z) (co-let (B x) k)
  (= '\ z) (co-lambda (B x) k)
  (= ', z) (co-begin (B x) k)
  (co-ap z (B x) k)))

 (co-begin x k) (? x (co-ev (A x) (co-begin (B x) k)) k)
 (co-ap fn args k) (:
  q (inliners (? (quoted? fn) (unquote fn) fn))
  (?  q (q args k) (co-apply fn args k)))

 ((co-let x k) m e) (? (nilp x) (k m e) (:
  ; the rewrite ensures the : expression is 2-ary.
  q (? (nilp (|| (toplp e) (memq (e 'loc) (A x)))) k
       (toplp e) (emc i-deftop (emd (X _ns (A x)) k))
       (emc i-defsl1 (emd (idx (e 'loc) (A x)) k)))
  v (look e (A x))
  ((? (= 'here (A v)) (imm (B v) q) (co-ev (AB x) q)) m e)))

 ((co-lambda x k) m e) (:
  (nom e k) ; try to pick a name for this function
   (: i (peek k) (?
    (= i i-deftop) (A (peek (seek k 1))) ; maybe we're about to set a global?
    (= i i-defsl1) (at (e 'loc) (peek (seek k 1))))) ; or a local

  (clo-thd e x) (:
   (loop x k) (? x (loop (B x) (co-ev (A x) (emc i-push k))) k)
   ((loop x (emc i-take (emd (len x) (emc i-ret hom)))) 0 e))

  l ((produces 'hom k) (+ m 2) e)
  y (ltu e (nom e l) x)
  (? (twop y) ; this means there's a closure.
      (poke (? (e 'loc) i-encl1 i-encl0)
       (poke (X (B y) (clo-thd e (A y))) l))
     (pokef i-imm (poke y l))))

 (co-cond ant con alt k) (:
  ((fin k) m e) (:
   thd (k (+ m 2) e)
   ex (A (e 's2))
   i (peek ex)
   (? (= i i-ret) (poke i thd) ; forward return instructions
    (poke i-jump ; otherwise jump somewhere ...
     (poke (? (= i i-jump) (peek (seek ex 1)) ex) thd))))
  (popr 's2
   (co-ev ant (popr 's1
    (emc i-br1 (peekr 's1
     (co-ev alt (fin (pushr 's1
      (co-ev con (fin (pushr 's2 k))))))))))))

 (ini nom) (,
  ;(.'ini nom)
  (emc i-ret (emd nom hom)))
 (ev x) (>>= x (env 0 0 0) (: (ana x e)
  (((co-ev (weak-ev e x) (ini 'ev)) 0 e) x)))
 ) ; end egg ; now bootstrap
 (, (ev prelu) (ev egg)
    ((ev 'ev) prelu) ((ev 'ev) egg)))

; " drop privileges "
; leave these in for now while we work on the compiler
;(tdel _ns 'poke seek peek hom hfin '_ns 'macros)
; delete instructions
; (ap tdel (X _ns (filter (tkeys _ns) (\ k (= "i-" (ssub (ynom k) 0 2))))))

(:
 ((diag f) x) (f x x)
 I id K const
 (flat-map x f) (? (twop x)
  (append (f (A x)) (flat-map (B x) f)))

 (assq k x) (? x (? (= (AA x) k) (A x) (assq k (B x))))
 (rev l) (foldl l () (\ a b (X b a)))
 (find l p) (? l (? (p (A l)) (A l) (find (B l) p)))
 (transp x) (ap zip (X L x))
 (sample l) (at l (randn (len l)))
 (intercal i l) (:
  (loop i l m) (? (nilp m) l (append l (append i (intercal i m))))
  (? l (loop i (A l) (B l))))
 (even x) (? (= 0 (& x 1)))
 (odd x) (? (= 1 (& x 1)))
 (abs x) (? (< x 0) (- x) x)
 (randn n) (% (abs (rand)) n)
 ; strings
 (chars s) (>>= s 0 (slen s) (: (loop s n l)
  (? (< n l) (X (schr s n) (loop s (+ n 1) l)))))
 (puts s) (each (chars s) putc)
 (iota n x .)
  (: (loop m n) (? (< m n) (X m (loop (+ m 1) n)))
   (? (nilp x) (loop 0 n) (loop n (A x))))
 (rho n xs .)
  (: (loop n x) (? (= n 1) x (append x (loop (- n 1) x)))
   (? (> n 0) (loop n xs))))

; (c0-x e x k) (:
;  ((c0-sym x k) m) (>>= (k (+ m 2)) (\ k (?
;   (= (: s (A (: r (look e x)))) 'here) (pokef i-imm (poke (B r) k))
;   (= s 'wait) (pokef i-late (poke (X (B r) x) k)) ; TODO subsume runtime type check
;   (pokef (? (= s 'arg) i-argn (= s 'loc) i-sl1n (= s 'clo) i-clon)
;    (poke (idx (e s) x) k)))))
;  (c0-list x k) (: z (A x) (?
;   (= '` z) (imm (? (B x) (AB x)) k)
;   (= '? z) (c0-cond (B x) k)
;   (= ': z) (c0-let (B x) k)
;   (= '\ z) (c0-lambda x k)
;   (= ', z) (c0-begin (B x) k)
;   (c0-ap z (B x) k)))
;  (c0-begin x k) (? x (c0-x e (A x) (c0-begin (B x) k)) k)
;  (c0-ap fn args k) (foldl args
;   (c0-x e fn (consumes 'hom (emc i-call (emd (len args) k))))
;   (\ k x (c0-ev e x (emc i-push k))))
;  ((? (twop x) c0-list (symp x) c0-sym imm) x k))

