(: ; some definitions that don't depend on the compiler.
  macros (tbl) ; only accessed directly in this file
  ; define some higher-order functions to generate threads
  ; directly instead of using closures
  (const x) (poke i-imm (poke x (poke i-ret (poke 'const (hom 4)))))
)
; to bootstrap first we define an expression that when
; eval'd defines the standard environment and compiler, and
; redefines eval. then we eval it twice. the first time
; everything is compiled by the bootstrap system, the second
; time by the (bootstrapped) live system.
(: prelude '(,
  (: ~~ '(0) ~ nilp

     (AA x) (A (A x)) (AB x) (A (B x))
     (BA x) (B (A x)) (BB x) (B (B x))

     ; functional programmings
     (id x) x
     ;(const x) (\ x)
     (co xs .) (foldl1 xs (\ m f (\ x . (f (ap m x)))))
     ((flip f) x y) (f y x)
     ((cu f x .) y .) (ap f (append x y))
     (map x f) (? (twop x) (X (f (A x)) (map (B x) f)) x)
     (append a b) (? (twop a) (X (A a) (append (B a) b)) b)
     (cat xs .) (foldr xs 0 append)
     (flat-map x f) (? (twop x) (append (f (A x)) (flat-map (B x) f)))

     ; logic
     ; && and || are also macros
     (&& l .) (all id l)
     (|| l .) (any id l)

     (all p l) (? l (? (p (A l)) (all p (B l))) -1)
     (any p l) (? l (? (p (A l)) -1 (any p (B l))))
     (each x f) (? x (, (f (A x)) (each (B x) f)))
     (part p l) (foldr l ~~ (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))

     ; data constructors
     (L . .) .
     (Q x) (L '` x)

     ; tables
     (set x .) (foldl x (tbl) (\ t x (, (tset t x -1) t)))

     ; numbers
     (inc x) (+ x 1)
     (dec x) (- x 1)

     ; lists
     (at l n) (? (< n 1) (A l) (at (B l) (- n 1)))
     (filter x p) (foldr x () (\ x m (? (p x) (X x m) m)))
     (foldr x z f) (? (twop x) (f (A x) (foldr (B x) z f)) z)
     (foldl x z f) (? (twop x) (foldl (B x) (f z (A x)) f) z)
     (foldl1  x f) (foldl (B x) (A x) f)
     (foldr1  x f) (?
      (twop (B x))
       (f (A x) (foldr1 (B x) f))
      (A x))
     (zip f a .) (? (? a (all id a))
      (X (ap f (map a A)) (ap zip (X f (map a B)))))
     (snoc l x) (? l (X (A l) (snoc (B l) x)) (L x))
     (randn n) (% (abs (rand)) n)
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (memq x k) (? x (? (= k (A x)) x (memq (B x) k)))
     (assq k x) (? x (? (= (AA x) k) (A x) (assq k (B x))))
     (del l k) (filter l (\ x (nilp (= x k))))
     (idx l x)
      (: (loop l x n)
          (? l (? (= x (A l)) n (loop (B l) x (+ n 1))))
       (loop l x 0))
     (len l) (foldl l 0 inc)

     )

; FIXME the bootstrap compiler should be able to use macros.
  (tset macros
   '::: (:
    (defm n x .) (X ',
     (X (L tset macros (Q n) (A x))
      (? (B x) (ap defm (B x)))))
    defm)
   'literal ev
   'AA (\ x (L A (L A x))) 'AB (\ x (L A (L B x)))
   'BA (\ x (L B (L A x))) 'BB (\ x (L B (L B x)))
   'AAA (\ x (L A (L A (L A x)))) 'AAB (\ x (L A (L A (L B x))))
   'ABA (\ x (L A (L B (L A x)))) 'ABB (\ x (L A (L B (L B x))))
   'BAA (\ x (L B (L A (L A x)))) 'BAB (\ x (L B (L A (L B x))))
   'BBA (\ x (L B (L B (L A x)))) 'BBB (\ x (L B (L B (L B x))))
   'char (\ x (schr x 0))
   '&& (\ x . (? x ((: (& x) (? (B x) (L '? (A x) (& (B x))) (A x))) x) -1))
   '|| (\ x . (foldr x 0 (\ x m (L (L '\ 'q (L '? 'q 'q m)) x))))
   '>>= (\ x . (? (> (len x) 1) (X (last x) (init x))
                                (: y (sym) (L '\ y (X y x)))))
   ))

  )
; this is the compiler source that's eval'd by stage 1, then
; again by itself to produce the final eval function. you can't
; use any macros in here, because stage 1 doesn't know about
; macros.
(:
egg0 '(:
   ; XXX be systematic about this
   pure (set
    L X A B Q + - * / % & | ^ << >> id const flip co
    = ~ <= >= < > cu snoc init last memq at idx len
    twop nilp symp nump tblp strp homp append
    && || scat slen schr ssub str)

   ; these enable extra partial evaluation for functions
   ; with certain algebraic properties. the nullary case for
   ; any grouplike function has to return its structure's
   ; identity element.
   abelians (set && || + * | &) ; arguments can be combined freely
   monoids (set scat) ; pairs of consecutive arguments can be combined in place

   (homp-strict x) (? (homp x) (nilp (= i-disp (peek x))))

 ; instruction fusion table
 fuse (:

  ; a common case is to rewrite the last emitted
  ; instruction or value according to an exact table
  ; of values
  ((f1 xs .) i p)
   ((\ a q
    ((: (loop x) (?
     (nilp x) (poke i p)
     (= a (A x)) (pokef (AB x) q)
     (loop (BB x)))) xs)) (peek p) (seek p 1))

  ; for idempotent instructions
  (idem i h) (? (= i (peek h)) h (poke i h))

  ; for specialized indexed instructions
  (argn xs .) (ap f1 ((: (loop n xs)
    (? xs (X n (X (A xs) (loop (+ n 1) (B xs)))))) 0 xs))

  ; for specialized branch instructions ;
  ; takes an argument for each branch case
  (br2 b c) (f1 i-br1 b i-br0 c)

  (tbl
   ; this along with "return forwarding" in branches is how
   ; tail calls get optimized.
   i-call (\ i h (? (= i-ret (peek (seek h 1)))
    (poke i-rec (poke (peek h) (seek h 1)))
    (poke i h)))
   i-argn (argn i-arg0 i-arg1 i-arg2 i-arg3)
   i-sl1n (argn i-sl10 i-sl11 i-sl12 i-sl13)
   i-clon (argn i-clo0 i-clo1 i-clo2 i-clo3)
   i-lt (br2 i-brl i-brl2)
   i-lteq (br2 i-brle i-brle2)
   i-gt (br2 i-brg i-brg2)
   i-gteq (br2 i-brge i-brl)
   i-eq (br2 i-bre i-brn)
   i-nilp_ (f1 i-br1 i-br0 i-br0 i-br1)
   i-imm (f1 0 i-imm0 1 i-imm1 2 i-imm2 -1 i-immn1)
   i-idmo idem
   i-idtwo idem
   i-idno idem
   i-idtbl idem))

 ; special function compiler table
 ; each entry has type ((value) m e) k x
 inliners (:

  (rw-monoidal f m x) (:
   (fold f m x) (? (nilp x) (L m)
    (? (quoted? (A x)) (fold f (f m (unquote (A x))) (B x))
     (: z (fold f m (B x)) (X (A z) (X (A x) (B z))))))
   (? (= (f) (A (: j (fold f m x)))) (B j) j))

  ; for comparison operators
  ((compar f i) x k) (?
   (? (nilp x) 1 (nilp (B x))) (imm -1 k)
   (nilp (BB x))
    (co-ev (A x) (emc i-push (co-ev (AB x) (emc i k))))
   (co-apply f x k))

  ((abelian f i) x k) (: y (rw-monoidal f (f) x)
   (co-ev (A y) (consumes 'num (binop 'num i k (B x)))))

  ; for operations with a defined arity
  (typed i ret-type arg-types .) (\ x k (?
   (< (len x) (len arg-types)) (nope 'wrong 'arity ': (len x) 'of (len arg-types))
   (: (fo k z) (co (co-ev (AA z) (consumes (BA z) k)) (B z))
      (co k z) (? z (fo (emc i-push k) z) k)
      l (emc i (produces ret-type k))
      z (zip X x arg-types)
    (? z (fo l z) l))))

  (binop t i k x)
   (: (loop t i k x)
       (emc i-push
        (co-ev (A x)
         (consumes t
          (emc i (binop t i k (B x))))))
    (? x (loop t i k x) (produces t k)))

  ((bitshift f i) x k) (:
   y (rw-monoidal + 0 (B x))
   z (? (nump (A x)) (rw-monoidal f (A x) y) (X (A x) y))
   (co-ev (A z) (consumes 'num (binop 'num i k (B z)))))

  (tbl
   id (\ x k (co-ev (A x) k))
   + (abelian + i-add)
   - (\ x k (?
    (nilp x) (imm 0 k)
    (nilp (B x)) ((typed i-neg 'num 'num) x k)
    (: y (rw-monoidal + 0 (B x))
       z (? (nump (A x)) (rw-monoidal - (A x) y) (X (A x) y))
     (? z (co-ev (A z) (consumes 'num (binop 'num i-sub k (B z)))) (imm 0 k)))))
   * (abelian * i-mul)
   / (\ x k (?
    (nilp x) (imm 1 k)
    (nilp (B x)) (co-ev (A x) (consumes 'num k))
    (: b (rw-monoidal * 1 (B x))
       c (? (nump (A x)) (rw-monoidal / (A x) b) (X (A x) b)))
     (co-ev (A c) (consumes 'num (binop 'num i-quot k (B c))))
    (imm 1 k)))

   & (abelian & i-band)
   | (abelian | i-bor)
   ^ (abelian ^ i-bxor)
   >> (bitshift >> i-sar)
   << (bitshift << i-sal)

   A (typed i-car 0 'two)
   B (typed i-cdr 0 'two)
   X (typed i-cons 'two 0 0)
   L (\ x k (:
    (loop x k) (? (nilp x) k
     (loop (B x)
      (emc i-push
       (co-ev (A x)
        (emc i-cons
         (produces 'two k))))))
    (imm 0 (loop x k))))


   poke (typed i-poke 'hom 0 'hom)

   tget (typed i-tget 0    'tbl 0)
   tset (typed i-tset 0    'tbl 0 0)
   tlen (typed i-tlen 'num 'tbl)
   thas (typed i-thas 'num 'tbl 0)

   < (compar < i-lt) <= (compar <= i-lteq)
   >= (compar >= i-gteq) > (compar > i-gt)
   = (compar = i-eq)

   nilp (typed i-nilp_ 'num 0)
   twop (typed i-twop_ 'num 0)
   homp (typed i-homp_ 'num 0)
   nump (typed i-nump_ 'num 0)
   symp (typed i-symp_ 'num 0)
   strp (typed i-strp_ 'num 0)
   tblp (typed i-tblp_ 'num 0)
   )))
egg1 '
 ; new let expn makes sure ^^^ exist at toplevel & don't cause closures below
 (:
 (pokef i h) ((\ i h q ((? q q poke) i h)) i h (fuse i))
 ((emc i k) m e) (pokef i (k (+ m 1) e))
 ((emd x k) m e) (poke x (k (+ m 1) e))


 ; this function creates a new lexical environment.
 ; if the second argument (the parent scope) is nil,
 ; then the expression is compiled in the global scope.
 (env a p n)  (:
  (asig a n) (?
   (nilp a) (X n a)
   (? (B a) (= '. (AB a))) (X (- (+ n 1)) (L (A a)))
   (: r (asig (B a) (+ n 1)) (X (A r) (X (A a) (B r)))))
  b (asig a 0)
  (tbl 'arg (B b) 'par p 'nom n
       'def (tbl) 'val (tbl) 'sig (A b)))

 (toplp e) (nilp (e 'par))


 ; this function is used in several places to look for a
 ; variable's value, or failing that to find where it's bound.
 (look e y) (?
  (thas (e 'val) y)
   (X 'here ((e 'val) y))
  ; toplevel bindings are special. if it's already defined
  ; we usually want to bind early, but we also want to allow
  ; redefinition, so in that case bind late.
  (toplp e) (?
   (? (thas _ns y) (nilp (thas (e 'def) y)))
    (X 'here (_ns y))
   (X 'wait _ns))
  (memq (e 'clo) y) (X 'clo e)
  (memq (e 'dfr) y) (X 'wait (e 'val))
  (memq (e 'loc) y) (X 'loc e)
  (memq (e 'arg) y) (X 'arg e)
  (look (e 'par) y))

 ; ltu : compile a lambda expression.
 ; depending on if it encloses any variables, a lambda
 ; expression may or may not have a value at compile time. this
 ; function returns either a function or a pair. in the latter
 ; case A is the list of variables it encloses and B is the
 ; "prototype" thread that expects those variables to be
 ; available in the closure. the enclosing scope generates a
 ; constructor for the closure, which is composed with the
 ; prototype to create an "instance".
 (ltu e nom l) (:
  (loc loc k) (? (nilp loc) k
   (poke i-setloc (poke (len loc) k)))
  (ar sig k) (?
   (> sig 0) (pokef i-arity (poke sig k))
   (< sig 0) (pokef i-varg (poke (- (- sig) 1) k))
   k)

  n (? (B l) (B l) ~~)
  anom (? (: en (e 'nom)) (X nom en) nom)
  f (env (init n) e anom)
  n0 (last n)
  x (scan f n0)

  (?
   ; if the function is nonvariadic and all it does is apply
   ; a second known function to its exact list of arguments,
   ; then it's an alias for the second function.
   (? (>= (f 'sig) 0)
      (? (twop x) (? (homp-strict (A x)) (= (B x) (f 'arg)))))
    (A x)
   ; otherwise compile it
   ; the 4 initial words are for the combined instruction
   ; output of (ar) and (loc)
   (: k (hfin (ar (f 'sig) (loc (f'loc) ((co-ev x (ini anom)) 4 f))))
    (? (: clo (f 'clo)) (X clo k) k))))

 ; first compiler moiety : " weak evaluator "
 ; 1. construct the local scope of the function
 ; 2. desugaring, macroexpansion, and partial evaluation
 ;    (constant folding, dead code elimination, etc), which has
 ;    some preliminary "static type checking" as a side effect
 ; it populates the local variables list and the known values
 ; dictionary in the function environment, and returns an
 ; expression with the same value (under eval) as the input,
 ; but pre-evaluated "as much as possible". to tell if an
 ; expression was fully evaluated, check if the image is
 ; quoted.
 (quoted? x) (? (twop x) (= (A x) '`) (nilp (symp x)))
 (unquote x) (? (twop x) (AB x) x)
 (quote x) (? (|| (symp x) (twop x)) (Q x) x)

 (scan e x)  (:
 (wev x) (:
  (wk-X x) (:

   ; FIXME optimization
   ; static arity check : omit the check in the called function
   (check-arity x) (: z (A x) (?
    (nilp (? (homp z) (= i-arity (peek z)))) x
    (? (>= (len (B x)) (peek (seek z 1)))
     (X (seek z 2) (B x)) ; this call is ok, skip the check
     (nope'wrong'arity)))) ; oops wrong arity

   (wk-: x) (:
    (nom s) (? (twop s) (nom (A s)) s)
    (sug d) (L (L '\ (L ', (init d) (last d))))
    (loop e x) (? x (:
     y (nom (A x))
     ll (loop e (BB x))
     (X y (X ((e 'def) y) ll))))
    (? (B x) (? (= 0 (% (len x) 2)) (sug x)
                (X ': (loop e (B x))))))

   ; FIXME optimization
   ; this is kind of a half-hearted optimization.
   ; we should ALWAYS be doing this, but without
   ; variable renaming we can only be sure it's
   ; safe in this case.
   (wk-\ l) (:
    (letrec? l) (? (B l)
     (? (twop (: x (last l)))
      (? (= (A x) ':) (= 1 (% (len (B x)) 2)))))
    (letrec-rw l) (: m (last l)
     (snoc (init l) (L ', (init m) (last m))))
    (? (letrec? l) (letrec-rw l) l))

   (wk-monoid f i l) (:
    (fold j x y) (?
     y (? (quoted? x) (fold (f j (unquote x)) (A y) (B y))
        (: z (X x (fold i (A y) (B y)))
         (? (= i j) z (X j z))))
     (quoted? x) ((\ x (? (= i x) 0 (L x)))
              (f j (unquote x)))
     (= i j) (L x)
     (L j x))
    (? l (X f (fold i (A l) (B l))) (quote i)))

   (wk-? x) (:
    (rec x) (?
     (nilp x) ~~
     (nilp (B x)) (L (wev (A x)))
     (nilp (quoted? (: a (wev (A x)))))
      (X a (X (wev (A (B x))) (rec (BB x))))
     (unquote a) (L (wev (AB x)))
     (rec (BB x)))
    ((\ r (? r (? (B r) (X '? r) (A r)))) (rec x)))

   (wk-, x) (:
    (loop x) (? (nilp (B x)) (L (wev (A x)))
     ((\ x z y (? (? (symp y) 1 (quoted? y)) z (X y z)))
      x (loop (B x)) (wev (A x))))
    (? (B x) (? (B (: z (loop (B x)))) (X ', z) (A z))))

   a (A x) (?
    (= '` a) x
    (= '\ a) (wk-\ x)
    (= ': a) (wk-: x)
    (= '? a) (wk-? (B x))
    (= ', a) (wk-, x)
    ; oh boy ...
    (? (: mac (macros a)) (wev (ap mac (B x)))
     (: z (map x wev) q (A z) r (B z) (?
      (abelians q) (:
       ff (part quoted? r)
       fg (ap q (map (A ff) unquote))
       (X q (? (= fg (q)) (B ff) (X fg (B ff)))))
      (monoids q) (wk-monoid q (q) r)
      (? (pure q) (all quoted? r))
       (quote (ap q (map r unquote)))
      (check-arity z))))))

  (wk-sym x) ((\ x l (?
   (= (A l) 'here) (quote (B l))
   (nilp (thas (: defs (e 'def)) x)) x
   (: dd (wev (tdel defs x))
    (? (nilp (quoted? (tset defs x dd))) x (,
     (tdel (e 'def) x)
     (tset (e 'val) x (unquote dd))
     dd))))) x (look e x))
  (? (twop x) (wk-X x) (symp x) (wk-sym x) x)
  
 )
  ; function symbol sugar ; handles any level of nesting
  (desug-\ x) (? (nilp (twop (A x))) x
   (desug-\ (X (AA x)
    (X (X '\ (snoc (BA x) (AB x)))(BB x)))))

  (desug-: y) (? y (,
   (? (quoted? (: x (desug-\ y) a (AB x)))
       (tset (e 'val) (A x) (unquote a))
      (, (tset (e 'def) (A x) a)
         (walk a)))
   (desug-: (BB x))))

  (walk x) (? (twop x) (: head (A x) (?
   (|| (= '\ head) (= head '`)) 0
   (= head ':) (? (= 1 (% (len x) 2)) (desug-: (B x)))
   (each x (\ x (walk x))))))
  ; this is a huge complicated procedure for "resolving
  ; the addresses" of sets of mutually recursive inner functions
  ; at compile time, so they can be as efficient as toplevel
  ; definitions whenever that's possible. it constructs the
  ; maximum set S of function variables whose definitions
  ; have no free variables not in S. then it arranges for
  ; references to functions in S to get resolved (with
  ; optimizations etc) later, which lets the compiler generate
  ; appropriate code without having a function address yet.
  (resolve)
   ; only bother with any of this if there are inner defs
   (? (: ks (tkeys (: def (e 'def)))) (:
   ; step one: pass over each inner def for this function and
   ; try to rewrite and evaluate it. if this succeeds, add it
   ; to the known values. otherwise, if the definition is for
   ; a function, collect it into a list.
   (ev-def kvs) (? kvs (?
    (thas (e 'val) (: kv (A kvs) k (A kv)))
     (ev-def (B kvs))
    (: qq (wev (B kv)) bb (ev-def (B kvs)) (?
     (quoted? (tset (e 'def) k qq))
      (, (tset (e 'val) k (unquote qq))
         (tdel (e 'def) k) bb)
     (? (twop qq) (= '\ (A qq)))
      (X (X k qq) bb)
     bb))))
 
   ; step two: now we have a list of function name/definition
   ; pairs. try and compile each one; if it succeeds, add it to
   ; the known values. otherwise collect the name, definition,
   ; and list of free variables into a list.
   (co-def kvs) (? kvs (: kv (A kvs) rr (co-def (B kvs)) (?
    (twop (: i (ltu e (: k (A kv)) (: v (B kv)))))
     (X (X k (X (A i) v)) rr)
    (, (tset (e 'val) k i)
       (tdel (e 'def) k) rr))))
 
   ; step three: reject from the list all definitions that
   ; depend on values that won't be available until runtime.
   ; membership in the list is regarded as proof that the
   ; function is available now, so any time a function is
   ; rejected we start over again as it may have been
   ; referenced by a previously accepted function.
   (rm-dep kvs) (rm-dep-r kvs kvs 0)
   (rm-dep-r i kvs q) (:
    (chk i vs) (? (nilp vs) 1 (: v (A vs) (?
     (|| (any (\ j (= (A j) v)) i) (thas (e 'val) v))
      (chk i (B vs)))))
    (? (nilp kvs) q (?
     (chk i (AB (: kv (A kvs))))
      (rm-dep-r i (B kvs) (X kv q))
     (rm-dep (del i kv)))))
 
   ; step four ( the last one ) : now we have the desired
   ; set of functions. remove them from the scope's local
   ; variables and add them to a list of deferred values, then
   ; recompile them. since we know each of these functions has
   ; no free variables that aren't being deferred, this time
   ; ltu will definitely return a function, which is stored in
   ; the known value set.
   (co-dfr kvs) (?
    (nilp kvs) (tset e'loc (tkeys (e'def)))
    (, (tdel (e 'def) (: kv (A kvs) k (A kv)))
       (tset e 'dfr (X k (e 'dfr)))
       (co-dfr (B kvs))
       (tset (e 'val) k (ltu e k (BB kv)))))
 
   (co-dfr (rm-dep (co-def (ev-def
    (map (tset e'loc ks) (\ k (X k (def k))))))))))

  (, (walk x) (resolve) (wev x)))



 ; second moiety : " analyzing evaluator "
 ; generates code to produce the value of the expression
 ; produced by the first moiety.

 (imm x k) (:
  (type-sym x) (?
   (nump x) 'num (twop x) 'two
   (symp x) 'sym (strp x) 'str
   (tblp x) 'tbl (homp x) 'hom)
  (emc i-imm (emd x (produces (type-sym x) k))))


 ; these functions are for type checking
 (consumes t k) (? (nilp t) k
  (emc (? (= t 'two) i-idtwo (= t 'num) i-idno
          (= t 'hom) i-idmo (= t 'tbl) i-idtbl
          (nope 'consumes)) k))

 (produces t k) (:
  (subtype? a b) (? (= a b) -1
   (? (= b 'hom) (nilp (= a 'num))))
  (con i) (?
   (= i i-idmo) 'hom (= i i-idno) 'num
   (= i i-idtwo) 'two (= i i-idtbl) 'tbl)
  (pro t h)
   ((\ t h q (? (nilp q) h
                (subtype? t q) (pro t (seek h 1))
                (nope 'type 'error ': t 'for q)))
    t h (con (peek h)))
  (? (nilp t) k (\ m e (pro t (k m e)))))

 (co-apply fn args k) (:
  (loop x k) (? (nilp x) k
   (loop (B x) (co-ev (A x) (emc i-push k))))
  (loop args (co-ev fn (consumes 'hom ; tail call optimization is handled by instruction fusion
   (emc i-call (emd (len args) k)))))) ; here is where you would do it instead

 ; these make functions that do certain side effects
 ; with env stack structures during code generation:
 ; either manipulate the stack or embed the item at the
 ; top into the thread.
 ((pushr s k) m e) ((\ e s q (A (tset e s (X q (e s))))) e s (k m e))
 ((popr  s k) m e) ((\ e s q (, (tset e s (B (e s))) q)) e s (k m e))
 ((peekr s k) m e) ((\ r q (poke (A r) q)) (e s) (k (+ m 1) e))

 (co-ev x k) ((? (twop x) co-X (symp x) co-sym imm) x k)
 ((co-sym x k) m e) ((?
  (= (: s (A (: r (look e x)))) 'here) (imm (B r) k)
  (= s 'wait) (emc i-late (emd (X (B r) x) k)) ; TODO subsume runtime type check
  (= e (B r))
   (emc (? (= s 'arg) i-argn (= s 'loc) i-sl1n (= s 'clo) i-clon)
    (emd (idx (e s) x) k))
  (, (: l (len (e 'clo)))
     (tset e 'clo (snoc (e 'clo) x))
     (emc i-clon (emd l k)))) m e)
 (co-X x k) ((\ x k z (?
  (= '` z) (imm (? (twop (B x)) (AB x)) k)
  (= '? z) (co-? (B x) k)
  (= ': z) (co-: (B x) k)
  (= '\ z) (co-\ x k)
  (= ', z) (co-, (B x) k)
  (co-ap z (B x) k))) x k (A x))

 (co-, x k) (? x (co-ev (A x) (co-, (B x) k)) k)
 (co-ap fn args k) (?
  (: q (inliners (? (quoted? fn) (unquote fn) fn))) (q args k)
  (co-apply fn args k))

 ((co-: x k) m e) (:
 ; the rewrite ensures the : expression is always an even form.
  (loop e x k) (? (nilp x) k (:
   l (loop e (BB x) k)
   q (? (nilp (|| (toplp e) (memq (e 'loc) (A x)))) l
        (toplp e) (emc i-deftop (emd (X _ns (A x)) l))
        (emc i-defsl1 (emd (idx (e 'loc) (A x)) l)))
   (? (= 'here (A (: v (look e (A x)))))
    (imm (B v) q)
    (co-ev (AB x) q))))

  ((loop e x k) m e))
 ((co-\ x k) m e) (:
  (nom e k) ; try to pick a name for this function
   (: i (peek k) (?
    (= i i-deftop) (A (peek (seek k 1))) ; maybe we're about to set a global?
    (= i i-defsl1) (at (e 'loc) (peek (seek k 1))))) ; or a local

  (clo-thd e x k) (:
   (loop x k) (? (nilp x) k
    (loop (B x) (co-ev (A x) (emc i-push k))))
   (k m) (poke i-take (poke (len x) (hom m)))
   ((loop x k) 2 e))

  l ((produces 'hom k) (+ m 2) e)
  y (ltu e (nom e l) x)
  (? (twop y) (,
;      (. (B y)'encloses(A y))
      (poke (? (e 'loc) i-encl1 i-encl0)
       (poke (X (B y) (clo-thd e (A y) k)) l)))
     (pokef i-imm (poke y l))))

 (co-? x k) (:
  (loop x k) (:
   (fin m e) (:
    thd (k (+ m 2) e)
    ex (A (e 's2))
    i (peek ex)
    (? (= i i-ret) (poke i thd) ; forward return instructions
     (poke i-jump ; otherwise jump somewhere ...
      (poke (? (= i i-jump) (peek (seek ex 1)) ex) thd))))
   (? (nilp (B x)) (co-ev (A x) fin)
    (co-ev (A x) (popr 's1 (emc i-br1 (peekr 's1
     (loop (BB x) (pushr 's1 (co-ev (AB x) fin)))))))))
  (popr 's2 (loop x (pushr 's2 k))))

 (ini nom) (emc i-ret (emd nom hom))
 (ev x) (: 
  (analyze e x) (((co-ev (scan e x) (ini 0)) 0 e))
  (analyze (env 0 0 0) x))))

; bootstrap
(ev prelude)
(ev egg0)
(ev egg1)
(ev prelude)
(ev egg0)
(ev egg1)

; " drop privileges "
(:; dels (cu (flip each) (cu tdel _ns))
;   locs '(egg poke macros hom seek peek hfin _ns)
;   insns (filter (tkeys _ns) (\ k (= "i-" (ssub (ynom k) 0 2))))
  (,
    (tdel _ns 'egg)
    (tdel _ns 'macros)
;    (tdel _ns '_ns)
;    (dels insns)
;    (dels locs)
  )
)
;ev
(:
 ((diag f) x) (f x x)
 I id K const

 ; strings
 (strip-prefix p s)
  (? (= p (ssub s 0 (: a (slen p)))) (ssub s a (slen s)))
 (chars s)
  (: (loop s n)
      (? (< n (slen s))
       (X (schr s n) (loop s (+ n 1))))
   (loop s 0))
 (puts s)
  (: (loop s n)
   (? (< n (slen s))
    (, (putc (schr s n))
       (loop s (+ n 1))))
   (loop s 0))
  (endl) (putc 10)
 (iota n x .)
  (: (loop m n) (? (< m n) (X m (loop (+ m 1) n)))
   (? (nilp x) (loop 0 n) (loop n (A x))))
 (rho n xs .)
  (: (loop n x) (? (= n 1) x (append x (loop (- n 1) x)))
   (? (> n 0) (loop n xs))))
