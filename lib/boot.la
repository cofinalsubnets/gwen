(: true -1 ~~ '(()) ~ nilp)

(:
 prelu '(,
  (:
     ; data constructors
     (L . .) .
     (Q x) (L '` x)

     ; functional programmings
     (id x) x
     ;(const x) (\ x) ; the "clean" definition uses a closure; more efficient to just make a thread!
     (const x) (poke i-imm (poke x (poke i-ret (poke 'const (hom 4)))))
     (co xs .) (foldl1 xs (\ m f (\ x . (f (ap m x)))))
     ((flip f) x y) (f y x)
     ((cu f x .) y .) (ap f (append x y))
     (map x f) (? (twop x) (X (f (A x)) (map (B x) f)) x)
     (append a b) (? (twop a) (X (A a) (append (B a) b)) b)
     (cat xs .) (foldr xs 0 append)

     ; logic
     (all l p) (? l (? (p (A l)) (all (B l) p)) true)
     (any l p) (? l (? (p (A l)) true (any (B l) p)))
     ; && and || are also macros
     (&& l .) (all l id)
     (|| l .) (any l id)

     (each x f) (? x (, (f (A x)) (each (B x) f)))
     (part p l) (foldr l ~~ (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))

     ; tables
     (set x .) (foldl x (tbl) (\ t x (, (tset t x true) t)))

     ; numbers
     (inc x) (+ x 1) (dec x) (- x 1)

     ; lists
     (at l n) (? (< n 1) (A l) (at (B l) (- n 1)))
     (filter x p) (foldr x () (\ x m (? (p x) (X x m) m)))
     (foldr x z f) (? (twop x) (f (A x) (foldr (B x) z f)) z)
     (foldl x z f) (? (twop x) (foldl (B x) (f z (A x)) f) z)
     (foldl1  x f) (foldl (B x) (A x) f)
     (foldr1  x f) (?
      (twop (B x))
       (f (A x) (foldr1 (B x) f))
      (A x))
     (zip f a .) (? (all a id)
      (X (ap f (map a A)) (ap zip (X f (map a B)))))
     (len l) (foldl l 0 inc)
     (snoc l x) (? l (X (A l) (snoc (B l) x)) (L x))
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))
     (memq x k) (? x (? (= k (A x)) x (memq (B x) k)))
     (del l k) (filter l (\ x (nilp (= x k))))
     (idx l x)
      ((: (loop l x n)
           (? l (? (= x (A l)) n (loop (B l) x (+ n 1)))))
       l x 0))

  (tset macros
   '::: (:
    (defm n x .) (X ',
     (X (L tset macros (L '` n) (A x))
      (? (B x) (ap defm (B x)))))
    defm)
   'literal ev
   'AA (\ x (L A (L A x))) 'AB (\ x (L A (L B x)))
   'BA (\ x (L B (L A x))) 'BB (\ x (L B (L B x)))
   'AAA (\ x (L A (L A (L A x)))) 'AAB (\ x (L A (L A (L B x))))
   'ABA (\ x (L A (L B (L A x)))) 'ABB (\ x (L A (L B (L B x))))
   'BAA (\ x (L B (L A (L A x)))) 'BAB (\ x (L B (L A (L B x))))
   'BBA (\ x (L B (L B (L A x)))) 'BBB (\ x (L B (L B (L B x))))
   'char (\ x (schr x 0))
   '&& (\ x . (? x ((: (& x) (? (B x) (L '? (A x) (& (B x))) (A x))) x) true))
   '|| (\ x . (: q (sym) (foldr x 0 (\ x m (L (L '\ q (L '? q q m)) x)))))
   '>>= (\ x . (X (last x) (init x)))
   ':where (\ x dfns . (X ': (snoc dfns x)))
   ))

; this is the compiler source that's eval'd by stage 1, then
; again by itself to produce the final eval function. you can't
; use any macros in here, because stage 1 doesn't know about
; macros.
 egg '(:
   ; XXX be systematic about this
   pure (set
    L X A B Q + - * / % & | ^ << >> id const flip co
    = ~ <= >= < > cu snoc init last memq at idx len
    twop nilp symp nump tblp strp homp append
    && || scat slen schr ssub str)

   ; these enable extra partial evaluation for functions
   ; with certain algebraic properties. the nullary case for
   ; any grouplike function has to return its structure's
   ; identity element.
   abelians (set && || + * | &) ; arguments can be combined freely
   monoids (set scat) ; pairs of consecutive arguments can be combined in place


 ; instruction fusion table
 fuse (:

  ; a common case is to rewrite the last emitted
  ; instruction or value according to an exact table
  ; of values
  ((f1 xs .) i p) (:
   (loop i p a x) (?
    (nilp x) (poke i p)
    (= a (A x)) (pokef (AB x) (seek p 1))
    (loop i p a (BB x)))
   (loop i p (peek p) xs))

  ; for idempotent instructions
  (idem i h) (? (= i (peek h)) h (poke i h))

  ; for specialized indexed instructions
  (argn xs .) (ap f1 ((: (loop n xs)
    (? xs (X n (X (A xs) (loop (+ n 1) (B xs)))))) 0 xs))

  ; for specialized branch instructions ;
  ; takes an argument for each branch case
  (br2 b c) (f1 i-br1 b i-br0 c)

  (tbl
   ; this along with "return forwarding" in branches is how
   ; tail calls get optimized.
   i-call (\ i h (? (= i-ret (peek (seek h 1)))
    (poke i-rec (poke (peek h) (seek h 1)))
    (poke i h)))
   i-argn (argn i-arg0 i-arg1 i-arg2 i-arg3)
   i-sl1n (argn i-sl10 i-sl11 i-sl12 i-sl13)
   i-clon (argn i-clo0 i-clo1 i-clo2 i-clo3)
   i-lt (br2 i-brl i-brl2)
   i-lteq (br2 i-brle i-brle2)
   i-gt (br2 i-brg i-brg2)
   i-gteq (br2 i-brge i-brl)
   i-eq (br2 i-bre i-brn)
   i-nilp_ (f1 i-br1 i-br0 i-br0 i-br1)
   i-imm (f1 0 i-imm0 1 i-imm1 2 i-imm2 -1 i-immn1)
   i-idmo idem
   i-idtwo idem
   i-idno idem
   i-idtbl idem))

 ; special function compiler table
 ; each entry has type ((value) m e) k x
 inliners (:

  (rw-monoidal f m x) (:
   (fold f m x) (? (nilp x) (L m)
    (? (quoted? (A x)) (fold f (f m (unquote (A x))) (B x))
     (: z (fold f m (B x)) (X (A z) (X (A x) (B z))))))
   (? (= (f) (A (: j (fold f m x)))) (B j) j))

  ; for comparison operators
  ((compar f i) x k) (?
   (? (nilp x) 1 (nilp (B x))) (imm true k)
   (nilp (BB x))
    (co-ev (A x) (emc i-push (co-ev (AB x) (emc i k))))
   (co-apply f x k))

  ((abelian f i) x k) (: y (rw-monoidal f (f) x)
   (co-ev (A y) (consumes 'num (binop 'num i k (B y)))))

  ; for operations with a defined arity
  (typed i ret-type arg-types .) (\ x k (?
   (< (len x) (len arg-types)) (nope 'wrong 'arity ': (len x) 'of (len arg-types))
   (: (fo k z) (co (co-ev (AA z) (consumes (BA z) k)) (B z))
      (co k z) (? z (fo (emc i-push k) z) k)
      l (emc i (produces ret-type k))
      z (zip X x arg-types)
    (? z (fo l z) l))))

  (binop t i k x)
   (: (loop t i k x)
       (emc i-push
        (co-ev (A x)
         (consumes t
          (emc i (binop t i k (B x))))))
    (? x (loop t i k x) (produces t k)))

  ((bitshift f i) x k) (:
   y (rw-monoidal + 0 (B x))
   z (? (nump (A x)) (rw-monoidal f (A x) y) (X (A x) y))
   (co-ev (A z) (consumes 'num (binop 'num i k (B z)))))

  (tbl
   id (\ x k (co-ev (A x) k))
   + (abelian + i-add)
   - (\ x k (?
    (nilp x) (imm 0 k)
    (nilp (B x)) ((typed i-neg 'num 'num) x k)
    (: y (rw-monoidal + 0 (B x))
       z (? (nump (A x)) (rw-monoidal - (A x) y) (X (A x) y))
     (? z (co-ev (A z) (consumes 'num (binop 'num i-sub k (B z)))) (imm 0 k)))))
   * (abelian * i-mul)
   / (\ x k (?
    (nilp x) (imm 1 k)
    (nilp (B x)) (co-ev (A x) (consumes 'num k))
    (: b (rw-monoidal * 1 (B x))
       c (? (nump (A x)) (rw-monoidal / (A x) b) (X (A x) b)))
     (co-ev (A c) (consumes 'num (binop 'num i-quot k (B c))))
    (imm 1 k)))

   & (abelian & i-band)
   | (abelian | i-bor)
   ^ (abelian ^ i-bxor)
   >> (bitshift >> i-sar)
   << (bitshift << i-sal)

   A (typed i-car 0 'two)
   B (typed i-cdr 0 'two)
   X (typed i-cons 'two 0 0)
   L (\ x k (:
    (loop x k) (? (nilp x) k
     (loop (B x)
      (emc i-push
       (co-ev (A x)
        (emc i-cons
         (produces 'two k))))))
    (imm 0 (loop x k))))


   poke (typed i-poke 'hom 0 'hom)

   tget (typed i-tget 0    'tbl 0)
   tset (typed i-tset 0    'tbl 0 0)
   tlen (typed i-tlen 'num 'tbl)
   thas (typed i-thas 'num 'tbl 0)

   < (compar < i-lt) <= (compar <= i-lteq)
   >= (compar >= i-gteq) > (compar > i-gt)
   = (compar = i-eq)

   ; FIXME these should be variadic
   nilp (typed i-nilp_ 'num 0)
   twop (typed i-twop_ 'num 0)
   homp (typed i-homp_ 'num 0)
   nump (typed i-nump_ 'num 0)
   symp (typed i-symp_ 'num 0)
   strp (typed i-strp_ 'num 0)
   tblp (typed i-tblp_ 'num 0)
   ))
 ; new let expn makes sure ^^^ exist at toplevel & don't cause closures below
 (pokef i h) (>>= i h (fuse i) (\ i h q ((? q q poke) i h)))
 ((emc i k) m e) (pokef i (k (+ m 1) e))
 ((emd x k) m e) (poke x (k (+ m 1) e))


 ; this function creates a new lexical environment.
 ; if the second argument (the parent scope) is nil,
 ; then the expression is compiled in the global scope.
 (env arg par nom)  (:
  (ary-sig a n) (?
   (nilp a) (X n a)
   (? (B a) (= '. (AB a))) (X (- (+ n 1)) (L (A a)))
   (: r (ary-sig (B a) (+ n 1)) (X (A r) (X (A a) (B r)))))
  sig-arg (ary-sig arg 0)
  (tbl 'arg (B sig-arg) 'par par 'nom nom
       'def (tbl) 'val (tbl) 'sig (A sig-arg)))

 (toplp e) (nilp (e 'par))


 ; this function is used in several places to look for a
 ; variable's value, or failing that to find where it's bound.
 (look e y) (?
  (thas (e 'val) y) (X 'here ((e 'val) y))
  (toplp e)
   ; toplevel bindings are special. if it's already defined
   ; we usually want to bind early, but we also want to allow
   ; redefinition, so in that case bind late.
   (? (&& (thas _ns y) (nilp (thas (e 'def) y)))
    (X 'here (_ns y))
    (X 'wait _ns))
  (memq (e 'loc) y) (X 'loc e)
  (memq (e 'arg) y) (X 'arg e)
  (memq (e 'clo) y) (X 'clo e)
  (memq (e 'dfr) y) (X 'wait (e 'val))
  (look (e 'par) y))

 ;(co-lam- e nom xpn) (, (tset (e 'lam) xpn (ltu e nom xpn)))

 ; ltu : compile a lambda expression.
 ; depending on if it encloses any variables, a lambda
 ; expression may or may not have a value at compile time. this
 ; function returns either a function or a pair. in the latter
 ; case A is the list of variables it encloses and B is the
 ; "prototype" thread that expects those variables to be
 ; available in the closure. the enclosing scope generates a
 ; constructor for the closure, which is composed with the
 ; prototype to create an "instance".
 (ltu out-scope nom b0) (:
  ((w/locals k) m e) (>>= (k (+ m 2) e) (\ k (?
   (e 'loc) (pokef i-setloc (poke (len (e 'loc)) k))
   k)))
  ((w/arity k) m e) (>>= (k (+ m 2) e) (e 'sig) (\ k sig (?
   (> sig 0) (pokef i-arity (poke sig k))
   (< sig 0) (pokef i-varg (poke (- (- sig) 1) k))
   k)))

  args-body (? (B b0) (B b0) ~~)
  full-name (?
   (nilp nom) (out-scope 'nom)
   (out-scope 'nom) (X nom (out-scope 'nom))
   nom)
  in-scope (env (init args-body) out-scope full-name)
  body (weak-eval in-scope (last args-body))

  (?
   (&& (>= (in-scope 'sig) 0) ; if the function is nonvariadic
       (twop body) ; and the body just applies
       (homp-strict (A body)) ; a second known function
       (= (B body) (in-scope 'arg))) ; to its exact argument list
    (A body) ; then it's an alias for the second function.
   ; otherwise compile it!
   (: out (hfin
           ((w/arity (w/locals (co-ev body (ini full-name))))
            0 in-scope))
    (? (in-scope 'clo) ; are there closure variables?
        (X (in-scope 'clo) out) ; if so return a pair of the vars and the thread.
       out)))) ; otherwise return the fully compiled function.

 ; first compiler moiety : " weak evaluator "
 ; 1. construct the local scope of the function
 ; 2. desugaring, macroexpansion, and partial evaluation
 ;    (constant folding, dead code elimination, etc), which has
 ;    some preliminary "static type checking" as a side effect
 ; it populates the local variables list and the known values
 ; dictionary in the function environment, and returns an
 ; expression with the same value (under eval) as the input,
 ; but pre-evaluated "as much as possible". to tell if an
 ; expression was fully evaluated, check if the image is
 ; quoted.
 (quoted? x) (? (twop x) (= (A x) '`) (nilp (symp x)))
 (unquote x) (? (twop x) (AB x) x)
 (quote x) (? (|| (symp x) (twop x)) (L '` x) x)
 (homp-strict x) (&& (homp x) (nilp (= i-disp (peek x))))
 (weak-eval e x)  (:
  ; function symbol sugar ; handles any level of nesting
  (desug-lambda x) (? (nilp (twop (A x))) x
   (desug-lambda (X (AA x)
    (X (X '\ (snoc (BA x) (AB x)))(BB x)))))

  (desug-define y) (? y (,
   (? (quoted? (: x (desug-lambda y) a (AB x)))
       (tset (e 'val) (A x) (unquote a))
      (, (tset (e 'def) (A x) a)
         (walk a)))
   (desug-define (BB x))))

  (walk x) (? (twop x) (: head (A x) (?
   (|| (= '\ head) (= head '`)) 0
   (= head ':) (&& (= 1 (% (len x) 2)) (desug-define (B x)))
   (each x walk))))

  (wev x) (:
   (rw-list x) (:
    ; FIXME optimization
    ; static arity check : omit the check in the called function.
    ; assumes the arity check, if present, is the 1st instruction.
    (check-arity x) (: z (A x) (?
     (nilp (&& (homp z) (= i-arity (peek z)))) x
     (? (>= (len (B x)) (peek (seek z 1)))
      (X (seek z 2) (B x)) ; this call is ok, skip the check
      (, (ap z (B x)) ; oops wrong arity, call the function to get an error
         0)))) ; avoid tail call for more informative backtrace

    (rw-define x) (:
     (nom s) (? (twop s) (nom (A s)) s)
     (sug d) (L (L '\ (L ', (init d) (last d))))
     (loop e x) (? x (:
      y (nom (A x))
      ll (loop e (BB x))
      (X y (X ((e 'def) y) ll))))
     (? (B x) (? (= 0 (% (len x) 2)) (sug x)
                 (X ': (loop e (B x))))))

    (rw-lambda l) (:
     ; FIXME an oddly specific and bad optimization.
     ; it rewrites a lambda expression of the form
     ;   (\ args (: vars vals xpn)) 
     (letrec? l) (? (B l)
      (? (twop (: x (last l)))
       (? (= (A x) ':) (= 1 (% (len (B x)) 2)))))
     ; to the form
     ;   (\ args (, (: vars vals) xpn))
     (rw-letrec l) (: m (last l)
      (snoc (init l) (L ', (init m) (last m))))
     ; which (currently) generates slightly more
     ; efficient code. effectively we should ALWAYS
     ; be doing this, but without variable renaming
     ; this is the only case where we can be sure
     ; it's safe in this case. so, we do it here.
     (? (letrec? l) (rw-letrec l) l))

    (rw-monoid f i l) (:
     (fold j x y) (?
      y (? (quoted? x) (fold (f j (unquote x)) (A y) (B y))
         (: z (X x (fold i (A y) (B y)))
          (? (= i j) z (X j z))))
      (quoted? x) (? (= i (: y (f j (unquote x))) 0 (L y)))
      (= i j) (L x)
      (L j x))
     (? l (X f (fold i (A l) (B l))) (quote i)))

    (rw-cond x) (:
     (rec x) (?
      (nilp x) ~~
      (nilp (B x)) (L (wev (A x)))
      (nilp (quoted? (: a (wev (A x)))))
       (X a (X (wev (A (B x))) (rec (BB x))))
      (unquote a) (L (wev (AB x)))
      (rec (BB x)))
     (? (: r (rec x)) (? (B r) (X '? r) (A r))))

    (rw-begin x) (:
     (loop x) (? (nilp (B x)) (L (wev (A x)))
      (>>= x (loop (B x)) (wev (A x)) (\ x z y
       (? (? (symp y) true (quoted? y)) z (X y z)))))
     (? (B x) (? (B (: z (loop (B x)))) (X ', z) (A z))))

    (?
     ; special forms
     (= '` (: a (A x))) x
     (= '\ a) (rw-lambda x)
     (= ': a) (rw-define x)
     (= '? a) (rw-cond (B x))
     (= ', a) (rw-begin x)
     ; is it a macro ?
     (: macro (macros a)) (wev (ap macro (B x)))
     ; nope, it's a function call.
     ; if it's pure & its arguments are all here then we can call it now.
     (&& (pure (: z (map x wev) q (A z))) (all (: r (B z)) quoted?))
      (quote (ap q (map r unquote)))
     ; if it's an abelian operator we may be able to partially apply it
     (abelians q) (:
      ff (part quoted? r)
      fg (ap q (map (A ff) unquote))
      (X q (? (= fg (q)) (B ff) (X fg (B ff)))))
     ; or if it's monoidal ...
     (monoids q) (rw-monoid q (q) r)
     ; otherwise we can at least try and check the arity.
     (check-arity z)))

   (rw-sym x) (?
    (= (A (: l (look e x))) 'here) (quote (B l))
    (nilp (&& (thas (: defs (e 'def)) x)
              (quoted? (tset defs x (: dfn (wev (tdel defs x)))))))
     x
    (, (tdel defs x)
       (tset (e 'val) x (unquote dfn))
       dfn))
   (? (twop x) (rw-list x) (symp x) (rw-sym x) x))

  ; this is a huge complicated procedure for "resolving
  ; the addresses" of sets of mutually recursive inner functions
  ; at compile time, so they can be as efficient as toplevel
  ; definitions whenever that's possible. it constructs the
  ; maximum set S of function variables whose definitions
  ; have no free variables not in S. then it arranges for
  ; references to functions in S to get resolved (with
  ; optimizations etc) later, which lets the compiler generate
  ; appropriate code without having a function address yet.
  (rslv)
   ; only bother with any of this if there are inner defs
   (? (: noms (tkeys (e 'def))) (: def (e 'def) val (e 'val)
    ; step one: pass over each inner def for this function and
    ; try to rewrite and evaluate it. if this succeeds, add it
    ; to the known values. otherwise, if the definition is for
    ; a function, collect it into a list.
    (rslv-ev-dfns dfns) (? dfns (?
     (thas val (: nom (AA dfns))) (rslv-ev-dfns (B dfns))
     (quoted? (tset def nom (: coll (rslv-ev-dfns (B dfns))
                               body (wev (BA dfns)))))
      (, (tset val nom (unquote body))
         (tdel def nom) coll)
     (&& (twop body) (= '\ (A body)))
      (X (X nom body) coll)
     coll))

    ; step two: now we have a list of function name/definition
    ; pairs. try and compile each one; if it succeeds, add it to
    ; the known values. otherwise collect the name, definition,
    ; and list of free variables into a list.
    (rslv-co-dfns dfns) (? dfns (:
     coll (rslv-co-dfns (B dfns))
     co (, ;(.'resolve'ltu (e'nom))
           (ltu e (: nom (AA dfns)) (: body (BA dfns))))
     (?  (twop co) ; if ltu returns a pair there are closure vars; collect the name & def
          (X (X nom (X (A co) body)) coll)
         (, (tdel def nom) ; otherwise it's a fully-compiled thread so add it to the known values.
            (tset val nom co)
            coll))))

    ; step three: reject from the list all definitions that
    ; depend on values that won't be available until runtime.
    ; membership in the list is regarded as proof that the
    ; function is available now, so any time a function is
    ; rejected we start over again as it may have been
    ; referenced by a previously accepted function.
    (rslv-rm-deps dfns) (rslv-rm-deps-r dfns dfns ())
    (rslv-rm-deps-chk maybes vs) (?
     (nilp vs) true
     (|| (thas val (: v (A vs)))
         (any maybes (\ j (= (A j) v))))
      (rslv-rm-deps-chk maybes (B vs)))
    (rslv-rm-deps-r maybes dfns coll) (?
     (nilp dfns) coll
     (rslv-rm-deps-chk maybes (AB (: dfn (A dfns))))
      (rslv-rm-deps-r maybes (B dfns) (X dfn coll))
     (rslv-rm-deps (del maybes dfn)))

    ; step four ( the last one ) : now we have the desired
    ; set of functions. remove them from the scope's local
    ; variables and add them to a list of deferred values, then
    ; recompile them. since we know each of these functions has
    ; no free variables that aren't being deferred, this time
    ; ltu will definitely return a function, which is stored in
    ; the known value set.
    (rslv-co-dfrs dfns) (?
     (nilp dfns) (tset e 'loc (tkeys def)) ; we're done, set the local variable list
     (, (tdel def (: dfn (A dfns) nom (A dfn)))
        (tset e 'dfr (X nom (e 'dfr)))
        (rslv-co-dfrs (B dfns))
        (tset val nom (ltu e nom (BB dfn)))))

    (rslv-co-dfrs
     (rslv-rm-deps
      (rslv-co-dfns
       (rslv-ev-dfns
        (map (tset e 'loc noms)
         (\ k (X k (def k))))))))))

  (, (walk x)
     (rslv)
     (wev x)))



 ; second moiety : " analyzing evaluator "
 ; generates code to produce the value of the expression
 ; produced by the first moiety.

 (imm x k) (:
  type-sym (?
   (nump x) 'num (twop x) 'two
   (symp x) 'sym (strp x) 'str
   (tblp x) 'tbl 'hom)
  (emc i-imm (emd x (produces type-sym k))))

 ; these functions are for type checking
 (consumes t k) (? (nilp t) k (:
  type-check (?
   (= t 'two) i-idtwo (= t 'num) i-idno
   (= t 'hom) i-idmo (= t 'tbl) i-idtbl
   (nope'consumes':'what'is'a t))
  (emc type-check k)))

 (produces t k) (:
  (subtype? a b)
   ; currently fixnums are their own thing & every
   ; other kind of data counts as a hom.
   (|| (= a b) (&& (= b 'hom) (nilp (= a 'num))))
  (con i) (? (= i i-idmo) 'hom (= i i-idno) 'num
             (= i i-idtwo) 'two (= i i-idtbl) 'tbl)
  (pro t h) (?
   (nilp (: q (con (peek h)))) h
   (subtype? t q) (pro t (seek h 1))
   (nope'produces':'type'error': t'for q))
  (? (nilp t) k (\ m e (pro t (k m e)))))

 (co-apply fn args k) (:
  (loop x k) (? x (loop (B x) (co-ev (A x) (emc i-push k))) k)
  (loop args (co-ev fn (consumes 'hom
   ; tail call optimization is handled by instruction fusion
   (emc i-call ; here is where you could do it instead
    (emd (len args) k))))))

 ; these make functions that do certain side effects
 ; with env stack structures during code generation:
 ; either manipulate the stack or embed the item at the
 ; top into the thread.
 ((pushr s k) m e) (>>= e s (k m e) (\ e s q (A (tset e s (X q (e s))))))
 ((popr  s k) m e) (>>= e s (k m e) (\ e s q (, (tset e s (B (e s))) q)))
 ((peekr s k) m e) (>>= (e s) (k (+ m 1) e) (\ r q (poke (A r) q)))

 (co-ev x k) ((? (twop x) co-X (symp x) co-sym imm) x k)
 ((co-sym x k) m e) ((?
  (= (: s (A (: r (look e x)))) 'here) (imm (B r) k)
  (= s 'wait) (emc i-late (emd (X (B r) x) k)) ; TODO subsume runtime type check
  (= e (B r))
   (emc (? (= s 'arg) i-argn (= s 'loc) i-sl1n (= s 'clo) i-clon)
    (emd (idx (e s) x) k))
  (, (: l (len (e 'clo)))
     ;(.'clo'add (e'nom) x)
     (tset e 'clo (snoc (e 'clo) x))
     (emc i-clon (emd l k)))) m e)

 (co-X x k) (?
  (= '` (: z (A x)))
   (imm (? (twop (B x)) (AB x)) k)
  (= '? z) (co-cond (B x) k)
  (= ': z) (co-define (B x) k)
  (= '\ z) (co-lambda x k)
  (= ', z) (co-begin (B x) k)
  (co-ap z (B x) k))

 (co-begin x k) (? x (co-ev (A x) (co-begin (B x) k)) k)
 (co-ap fn args k) (?
  (: q (inliners (? (quoted? fn) (unquote fn) fn))) (q args k)
  (co-apply fn args k))

 ((co-define x k) m e) (:
 ; the rewrite ensures the : expression is always an even form.
  (loop e x k) (? (nilp x) k (:
   l (loop e (BB x) k)
   q (? (nilp (|| (toplp e) (memq (e 'loc) (A x)))) l
        (toplp e) (emc i-deftop (emd (X _ns (A x)) l))
        (emc i-defsl1 (emd (idx (e 'loc) (A x)) l)))
   (? (= 'here (A (: v (look e (A x)))))
    (imm (B v) q)
    (co-ev (AB x) q))))

  ((loop e x k) m e))

 ((co-lambda x k) m e) (:
  (nom e k) ; try to pick a name for this function
   (: i (peek k) (?
    (= i i-deftop) (A (peek (seek k 1))) ; maybe we're about to set a global?
    (= i i-defsl1) (at (e 'loc) (peek (seek k 1))))) ; or a local

  (clo-thd e x) (:
   (loop x k) (? x (loop (B x) (co-ev (A x) (emc i-push k))) k)
   ((loop x (emc i-take (emd (len x) (emc i-ret hom)))) 0 e))

  l ((produces 'hom k) (+ m 2) e)
  y (ltu e (nom e l) x)
  (? (twop y)
      (poke (? (e 'loc) i-encl1 i-encl0)
       (poke (X (B y) (clo-thd e (A y))) l))
     (pokef i-imm (poke y l))))

 (co-cond x k) (:
  (loop x k) (:
   (fin m e) (:
    thd (k (+ m 2) e)
    ex (A (e 's2))
    i (peek ex)
    (? (= i i-ret) (poke i thd) ; forward return instructions
     (poke i-jump ; otherwise jump somewhere ...
      (poke (? (= i i-jump) (peek (seek ex 1)) ex) thd))))
   (? (nilp (B x)) (co-ev (A x) fin)
    (co-ev (A x) (popr 's1 (emc i-br1 (peekr 's1
     (loop (BB x) (pushr 's1 (co-ev (AB x) fin)))))))))
  (popr 's2 (loop x (pushr 's2 k))))

 (ini nom) (,
  ;(.'ini nom)
  (emc i-ret (emd nom hom)))
 (ev x) (>>= (env 0 0 0) x (: (analyze e x)
  (((co-ev (weak-eval e x) (ini 'ev)) 0 e) x))))
(, ; bootstrap
  (ev prelu) (ev egg)
  (ev prelu) (ev egg)))

; " drop privileges "
; leave these in for now while we work on the compiler
;(tdel _ns 'poke seek peek hom hfin '_ns 'macros)
; delete instructions
; (ap tdel (X _ns (filter (tkeys _ns) (\ k (= "i-" (ssub (ynom k) 0 2))))))

(:
 ((diag f) x) (f x x)
 I id K const
 (AA x) (A (A x)) (AB x) (A (B x))
 (BA x) (B (A x)) (BB x) (B (B x))
 (flat-map x f) (? (twop x)
  (append (f (A x)) (flat-map (B x) f)))

 (assq k x) (? x (? (= (AA x) k) (A x) (assq k (B x))))
 (rev l) (foldl l () (\ a b (X b a)))
 (find l p) (? l (? (p (A l)) (A l) (find (B l) p)))
 (transp x) (ap zip (X L x))
 (sample l) (at l (randn (len l)))
 (intercal i l) (:
  (loop i l m) (? (nilp m) l (append l (append i (intercal i m))))
  (? l (loop i (A l) (B l))))
 (even x) (? (= 0 (& x 1)))
 (odd x) (? (= 1 (& x 1)))
 (abs x) (? (< x 0) (- x) x)
 (randn n) (% (abs (rand)) n)
 ; strings
 (chars s) (>>= s 0 (slen s) (: (loop s n l)
  (? (< n l) (X (schr s n) (loop s (+ n 1) l)))))
 (puts s) (each (chars s) putc)
 (iota n x .)
  (: (loop m n) (? (< m n) (X m (loop (+ m 1) n)))
   (? (nilp x) (loop 0 n) (loop n (A x))))
 (rho n xs .)
  (: (loop n x) (? (= n 1) x (append x (loop (- n 1) x)))
   (? (> n 0) (loop n xs))))
