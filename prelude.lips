(: lib '(,
  (: and (\ l (? l (? (A l) (and (B l))) 0))
     && (\ l . (and l))
     or (\ l (? l (: a (A l) (? a a (or (B l))))))
     || (\ l . (or l))
     L (\ . . .)
     cat (: append (\ a b (? a(X(A a)(append(B a)b))b))
      (\ a . (foldr a () append)))
     iota (\ n x .
      (: iota.l (\ m n (? (< m n) (X m (iota.l (+ m 1) n))))
       (? (nilp x) (iota.l 0 n) (iota.l n (A x)))))

     rho (\ n xs .
      (: rho.l(\ n x(?(= n 1)x(cat x(rho.l(- n 1)x))))
       (?(> n 0)(rho.l n xs))))

     foldl(\ x z f (? x (foldl (B x) (f z (A x)) f) z))
     foldr (\ x z f (? x (f (A x) (foldr (B x) z f)) z))
     foldl1 (\ x f (foldl (B x) (A x) f))
     foldr1  (\ x f (? (B x) (f (A x) (foldr1 (B x) f)) (A x)))
     map (\ x f (foldr x () (\ x m (X (f x) m))))

     |-> (\ xs . (: t (ap tbl xs)
                    @ (\ x (? (thas t x) (tget t x)
                              (fail)))))
     id (\ x x)
     const (\ x (\ x))
     each (\ x f (? x (,(f (A x)) (each (B x) f))))
     all (\ l p (? l (? (p (A l)) (all (B l) p)) 0))
     any (\ l p (? l (? (p (A l)) 0 (any (B l) p))))
     part (\ l p (foldr l '(()) (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m)))))))

     filter (\ x p (foldr x () (\ x m (? (p x) (X x m) m))))
     at (\ l n (? (< n 1) (A l) (at (B l) (- n 1))))
     flip (\ f (\ x y (f y x)))
     diag (\ f (\ x (f x x)))
     curry (\ f x . (\ y . (ap f (cat x y))))
     {set} (\ x . (: d (tbl) (, (each x (\ y (tset d y ()))) d)))

     snoc  (\ l x (? l (X (A l) (snoc (B l) x))
                       (L x)))
     init (\ l (? (B l) (X (A l) (init (B l)))))
     last (\ l (? (B l) (last (B l)) (A l)))

     memq (\ x k (? x (? (= k (A x)) x (memq (B x) k))))
     rev (\ l (foldl l () (\ r x (X x r))))
     ldel (\ l k (filter l (\ x (nilp (= x k)))))
     idx (\ l x
      ((: .l (\ l x n (? l (? (= x (A l)) n (.l (B l) x (+ n 1))) -1)))
       l x 0))
     len (\ l (? l (+ 1 (len (B l))) 0)))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: defm (\ n x . (,(tset macros n (: v (ev (A x))))
                           (? (B x) (ap defm (B x)) v))))
   'AA (\ x (X A (L (X A (L x))))) 'AB (\ x (X A (L (X B (L x)))))
   'BA (\ x (X B (L (X A (L x))))) 'BB (\ x (X B (L (X B (L x)))))
   'immediate (\ x (ev x))
   '&& (\ x . ((: & (\ x
     (? (B x) (L '? (A x) (& (B x))) (A x)))) x))
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a . (: y (gensym)
    (L ': y x ((: case.i (\ a
      (? a (? (B a) (L '? (L '= y (A a)) (A (B a))
                      (case.i (B (B a))))
                     (A a))))) a)))))))

(: egg '(: ev (ev '(:
 env (\ a p n (>>=
  ((: asig (\ a n
       (? a
        (? (? (B a) (= '. (AB a)))
         (X (- (+ n 1)) (L (A a)))
         (>>= (asig (B a) (+ n 1)) (\ r
          (X (A r) (X (A a) (B r))))))
        (X n a)))) a 0) (\ b
  (tbl 'arg (B b) 'par p
       'nom n
       'val (tbl) 'sig (A b)
       'def (tbl)))))

  t-c (immediate (|->
   'hom 0 'num 1 'two 2 'vec 3 'str 4
   'tbl 5 'sym 6 'nil 7 () 8))


 qtd (\ x (? (twop x) (= (A x) '`) (nilp (symp x))))
 unq (\ x (? (twop x) (AB x) x))
 emf (\ i h ((? (: q (tget fuse i)) q emi) i h))
 Im (\ x k (:
  t (? (homp x) 'hom (nump x) 'num
       (twop x) 'two (vecp x) 'vec
       (symp x) 'sym (strp x) 'str
       (tblp x) 'tbl)
  (Co i-immv (Da x (-> t k)))))

 Co (\ i k (\ e m (emf i (k e (+ m 1)))))
 Da (\ x k (\ e m (emx x (k e (+ m 1)))))

 ; these are for accessing stacks from inside the "compiler monad"
 pushr (\ s (\ k (\ e m (>>= (k e m)       (\ k (A (tset e s (X k (tget e s)))))))))
 popr  (\ s (\ k (\ e m (>>= (k e m)       (\ k (, (tset e s (B (tget e s))) k))))))
 peekr (\ s (\ k (\ e m (>>= (k e (+ m 1)) (\ k (emx (A (tget e s)) k))))))
 push1 (pushr 's1) push2 (pushr 's2)
 pop1 (popr 's1) pop2 (popr 's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 ; these functions are for type checking
 >- (\ t k (? (nilp t) k (:
  tcr (case t 'two i-idtwo 'num i-idnum
              'hom i-idhom 'tbl i-idtbl (fail))
  (Co tcr k))))

 -> (\ t k (\ e m (? (nilp t) (k e m)
                   (value-of-type e m t k))))

 value-of-type (\ e m t k (:
  match-for (\ t h (>>= t (consumes h) h (\ t u h (?
   (nilp u) h
   (= u t) (match-for t (hseek h 1))
   (fail)))))
  (match-for t (k e m))))

 consumes (\ h (: i (hgeti h) (case i
  i-idhom 'hom i-idnum 'num
  i-idtwo 'two i-idtbl 'tbl)))

 cde (\ e m x k (:
 ; the rewrite ensures the : expression is always an even form.
  loop (\ x k (? (nilp x) k (:
   l (loop (BB x) k)
   m (? (nilp (|| (toplp e) (< -1 (idx (tget e'loc)(A x))))) l
      (\ e m (? (toplp e) ((Co i-tbind (Da (A x) l)) e m)
                          ((Co i-setl (Da (idx (tget e'loc) (A x)) l)) e m))))
   (? (= 'here (A (: v (look e (A x)))))
    (Im (B v) m) (eval (AB x) m)))))

 ((loop x k) e m)))

 ev-if (\ x k (:
  loop (\ x k (:
   fin (\ e m (:
    thd (k e (+ m 2))
    ex (A (tget e's2))
    i (hgeti ex)
    (? (= i i-ret) (emf i thd) ; forward return instructions
     (emf i-jump ; otherwise jump somewhere ...
      (emx (? (= i i-jump) (hgetx (hseek ex 1)) ex) thd)))))
   (? (nilp (B x)) (eval (A x) fin)
    (eval (A x) (pop1 (Co i-branch (peek1
     (loop (BB x) (push1 (eval (AB x) fin))))))))))
  (pop2 (loop x (push2 k)))))

 quote (\ x (? (qtd x) x (L '` x)))

 wev (\ e x  (:

  wev-list (\ e x (:

   wev-arity (\ x (: z (A x) (?
    (nilp (? (homp z) (= i-arity (hgeti z)))) x
    (? (>= (len (B x)) (hgetx (hseek z 1)))
     (X (hseek z 2) (B x))
     (ap z (B x)))))) ; purposely cause an arity error

   wev-let (\ e x (:
    desug (\ d (L (L '\ (L ', (init d) (last d)))))
    loop (\ e x (? x
     (: ll (loop e (BB x))
      (X (A x) (X (tget (tget e'def) (A x)) ll)))))
    (? (B x) (? (= 0 (% (len x) 2)) (desug x)
                (X ': (loop e (B x)))))))

   wev-lam (\ e l (:
    trlamp (\ l (&& (B l) (: x (last l)
     (&& (twop x) (= (A x) ':) (= 0 (% (len x) 2))))))
    wev-lamm (\ l (: m (last l)
     (snoc (init l) (L ', (init m) (last m)))))
    (? (trlamp l) (wev-lamm l) l)))

   a (A x) (case a
    '` (? (B x) x)
    '\ (wev-lam e x)
    ': (wev-let e x)
    '? (wev-if e (B x))
    ', (wev-seq e x)
    (? (thas macros a)
        (wev e (ap (tget macros a) (B x)))
       (: z (map x (\ x (wev e x))) q (A z) r (B z) (?
        (nilp (thas pures q)) (wev-arity z)
        (all r qtd) (quote (ap q (map r unq)))
        (thas monoids q) (monofold q (tget monoids q) r)
        (thas abelians q) (:
         ff (part r qtd)
         fg (ap q (map (A ff) unq))
         (X q (? (= fg (tget abelians q)) (B ff)
               (X fg (B ff)))))
        (wev-arity z)))))))

  wev-if (\ e x (:
   wev-ifr (\ e x (?
    (nilp x) (L ())
    (nilp (B x)) (L (wev e (A x)))
    (nilp (qtd (: a (wev e (A x)))))
     (X a (X (wev e (A (B x))) (wev-ifr e (BB x))))
    (unq a) (L (wev e (AB x)))
    (wev-ifr e (BB x))))

   r (wev-ifr e x)
   (? r (? (B r) (X '? r) (A r)))))

  wev-sym (\ e x (: l (look e x) (?
   (= (A l) 'here) (quote (B l))
   (nilp (thas (: defs (tget e'def)) x)) x
   (: dd (wev e (tdel defs x))
    (? (nilp (qtd (tset defs x dd))) x (,
     (tdel (tget e'def) x)
     (tset (tget e'val) x (unq dd))
     dd))))))

  wev-seq (\ e x (:
   wev-seqr (\ e x (?
    (nilp (B x)) (L (wev e (A x)))
     (: z (wev-seqr e (B x))
        y (wev e (A x))
      (? (|| (symp y) (qtd y)) z (X y z)))))
   (? (: y (B x)) (: z (wev-seqr e y)
                   (? (B z) (X ', z) (A z))))))

 (? (twop x) (wev-list e x)
    (symp x) (wev-sym e x)
    (quote x))))

 toplp (\ e (nilp (tget e'par)))
 look (\ e y (?
  (thas (tget e 'val) y)
   (X 'here (tget (tget e'val) y))
  (toplp e)
   ; toplevel bindings are special. if it's already defined
   ; we usually want to bind early; but we also want to allow
   ; redefinition, so in that case bind late.
   (? (&& (thas ns y) (nilp (thas (tget e'def) y)))
    (X 'here (tget ns y))
    (X 'wait ns))
  (memq (tget e'clo) y) (X 'clo e)
  (memq (tget e'dfr) y) (X 'wait (tget e'val))
  (memq (tget e'loc) y) (X 'loc e)
  (memq (tget e'arg) y) (X 'arg e)
  (look (tget e'par) y)))

 ltu (\ e nom l (:
  with-locals (\ f k (? (: loc (tget f 'loc))
                        (emi i-prel (emx (len loc) k)) k))
  with-arity (\ f k (?
   (> (: i (tget f 'sig)) 0) (emf i-arity (emx i k))
   (< i 0) (emi i-vararg (emx (- (- i) 1) k))
   k))

  fx (: n (|| (B l) '(()))
        f (env (init n) e (X nom (tget e'nom)) nom)
        x (last n)
        (, (scan f x) (X f (wev f x))))

  f (A fx) x (B fx) (?
   ; if the function is nonvariadic and all it does is apply
   ; another known function to its exact list of arguments,
   ; then it's an alias for the second function
   (&& (twop x) (homp (A x)) (>= (tget f 'sig) 0) (= (B x) (tget f'arg)))
    (A x)
   (: k (hfin (with-arity f (with-locals f ((eval x ini) f 4))))
    (? (tget f 'clo) (X (tget f 'clo) k) k)))))

 scan (\ e x (:

  loop (\ e x (? x (,
   (? (qtd (: a (AB x)))
    (tset (tget e'val) (A x) (unq a))
    (tset (tget e'def) (A x) a))
   (rec e a)
   (loop e (BB x)))))

  rec (\ e x (? (twop x) (case (A x)
   '\ () '` ()
   ': (? (= 1 (% (len x) 2)) (loop e (B x)))
   (each x (\ x (rec e x))))))

  (, (rec e x) (resolve e))))

 ; this is a huge complicated procedure for "resolving
 ; the addresses" of mutually recursive functions at compile
 ; time, so they can call each other without closures. simple
 ; self-recursive functions are a special case of this.
 resolve (\ e (:

  ; step one: pass over each inner def for this function and
  ; try to rewrite and evaluate it. if this succeeds, add it
  ; to the known values. otherwise, if the definition is for
  ; a function, collect it into a list.
  coll-fns (\ e kvs (? kvs (?
   (thas (tget e'val) (: kv (A kvs) k (A kv)))
    (coll-fns e (B kvs))
   (: qq (wev e (B kv)) bb (coll-fns e (B kvs)) (?
    (qtd (tset (tget e'def) k qq))
     (, (tset (tget e'val) k (unq qq))
        (tdel (tget e'def) k)
        bb)
    (&& (twop qq) (= '\ (A qq)))
     (X (X k qq) bb)
    bb)))))

  pc2 (\ e kvs (? kvs (: kv (A kvs) rr (pc2 e (B kvs)) (?
   (homp (: i (ltu e (: k (A kv)) (: v (B kv)))))
    (, (tset (tget e'val) k i)
       (tdel (tget e'def) k)
       rr)
   (X (X k (X (A i) v)) rr)))))

  pkvs (\ e i vs (? (nilp vs) 1 (: v (A vs) (?
   (|| (any i (\ j (= (A j) v))) (thas (tget e'val) v))
    (pkvs e i (B vs))))))

  elis (\ e i kvs q (? (nilp kvs) q (?
   (pkvs e i (AB (: kv (A kvs))))
    (elis e i (B kvs) (X kv q))
   (>>= (ldel i kv) (\ j (elis e j j ()))))))


  rc2 (\ e kvs (? (nilp kvs)
   (tset e'loc (tkeys (tget e'def)))
   (, (tdel (tget e'def) (: kv (A kvs) k (A kv)))
      (tset e 'dfr (X k (tget e'dfr)))
      (rc2 e (B kvs))
      (tset (tget e'val) k (ltu e k (BB kv))))))

  ; only bother with this if there are inner defs
  (? (: ks (tkeys (: def (tget e'def))))
   (rc2 e (: pcs (pc2 e (coll-fns e (map
                  (tset e'loc ks)
                  (\ k (X k (tget def k))))))
           (elis e pcs pcs ()))))))

 ev-ap (\ a b k (:
  loop (\ x k (? (nilp x) k
   (loop (B x) (eval (A x) (Co i-push k)))))
  (? (&& (qtd a) (: q (tget inliners (unq a)))) (q b k)
   (loop b (eval a (>- 'hom (Co i-call (Da (len b) k))))))))

 ev-la (\ x k (:
  nom (\ e k (: i (hgeti k) (case i
   i-tbind (hgetx (hseek k 1))
   i-setl  (at (tget e'loc) (hgetx (hseek k 1))))))

  clo-thd (\ e x (:
   loop (\ x k (? (nilp x) k
    (loop (B x) (eval (A x) (Co i-push k)))))
   k (\ e m (emi i-take (emx (len x) (hom (+ m 2)))))
   ((loop x k) e 0)))

  (\ e m (:
   l ((-> 'hom k) e (+ m 2))
   y (ltu e (nom e l) x)
   (? (homp y) (emf i-immv (emx y l))
    (emi (? (tget e'loc) i-encll i-encln)
     (emx (X (B y) (clo-thd e (A y))) l)))))))

 ev-list (\ x k (:
  ,, (\ x k (? x (eval (A x) (,, (B x) k)) k))
  z (A x) (case z
   '` (Im (AB x) k)
   '? (ev-if (B x) k)
   ': (\ e m (cde e m (B x) k))
   '\ (ev-la x k)
   ', (,, (B x) k)
   (ev-ap z (B x) k))))

 ev-sym (\ x k (\ e m (:

  late (\ e m x d k (:
   h (k e (+ m 2))
   t (consumes h)
   (emf i-lbind (emx (X (t-c t) (X d x))
                  (? t (hseek h 1) h)))))

  s (A (: r (look e x))) (?
   (= s'here) ((Im (B r) k) e m)
   (= s'wait) (late e m x (B r) k)
   (= e (B r)) (case s
    'arg ((Co i-argn (Da (idx (tget e'arg) x) k)) e m)
    'loc ((Co i-locn (Da (idx (tget e'loc) x) k)) e m)
    'clo ((Co i-clon (Da (idx (tget e'clo) x) k)) e m))
   (, (: l (len (tget e'clo)))
      (tset e'clo(snoc (tget e'clo) x))
      ((Co i-clon (Da l k)) e m))))))

 eval (\ x k ((? (twop x) ev-list (symp x) ev-sym Im) x k))
 ini (\ e m ((Co i-ret (Da (tget e'nom) (\ e m (hom m)))) e m))
 ev (\ x (: e (env () () 'ev)
  (((eval (, (scan e x) (wev e x)) ini) e 0) x)))

 ; these data structures encode rules for partially evaluating
 ; different functions. right now the functions eligible for
 ; partial evaluation are hardcoded. but the compiler should
 ; be able to infer if a function is pure in many cases, and
 ; users should be able to provide their own monoid instances
 ; (or whatever).
 abelians (immediate (tbl && 1 || () + 0 * 1))
 monoids (immediate (tbl scat "" cat ()))
 pures (immediate ({set}
  L X A B + - * / % id flip cat iota rho |->
  snoc init last rev ldel memq at idx len
  homp nilp symp nump tblp strp twop vecp
  && || scat slen sget ssub str))

 fuse (:
  f1 (\ g xs . (\ i p (>>= (g p) (hseek p 1) (\ a q
   ((: loop (\ xs (? xs
     (? (= a (A xs)) (emi (AB xs) q) (loop (BB xs)))
     (emi i p)))) xs)))))

  argr (\ a b (f1 hgetx 0 a 1 b))
  br2 (\ b c (f1 hgeti i-branch b i-barnch c))
  (tbl
   i-argn (argr i-arg0 i-arg1)
   i-locn (argr i-loc0 i-loc1)
   i-clon (argr i-clo0 i-clo1)
   i-lt (br2 i-brlt i-brgteq) i-lteq (br2 i-brlteq i-brgt)
   i-gt (br2 i-brgt i-brlteq) i-gteq (br2 i-brgteq i-brlt)
   i-eq (br2 i-breq i-brne)
   i-nilpp (f1 hgeti i-branch i-barnch i-barnch i-branch)
   i-call (\ i h (case (hgeti (hseek h 1))
    i-ret (emi i-rec (emx (hgetx h) (hseek h 1)))
    (emi i h)))
   i-immv (f1 hgetx () i-unit 0 i-zero 1 i-one)))

 inliners (:
  monofold (\ f i l (:
   fold (\ f i j x y
    (? y (? (qtd x) (fold f i (f j (unq x)) (A y) (B y))
                    (: z (X x (fold f i i (A y) (B y)))
                     (? (= i j) z (X j z))))
       (qtd x) (>>= (f j (unq x)) (\ x (? (= i x)()(L x))))
       (= i j) (L x)
       (L j x)))
   (? l (X f (fold f i i (A l) (B l))) (quote i))))

  grp (\ f m id x (:
   fold (\ f m x (? (nilp x) (L m)
    (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
     (: z (fold f m (B x)) (X (A z) (X y (B z)))))))
   (? (= id (A (: j (fold f m x)))) (B j) j)))

  ordr (\ i (\ x k (?
   (nilp x) (Im 0 k)
   (eval (A x) (? (nilp (B x)) k
    (: fold (\ k x y
      (eval x (Co i (? (nilp y) (push2 k)
       (Co i-barnch (peek2 (Co i-push
        (fold k (A y) (B y)))))))))
     (Co i-push (pop2 (fold k (AB x) (BB x))))))))))

  abel (\ f z i (\ x k (>>= (grp f z z x) (\ x
   (eval (A x) (>- 'num (2f i k (B x))))))))

  0y (\ i t0 (\ x k (Co i (-> t0 k))))
  1y (\ i t0 t1 (\ x k
   (eval (A x) (>- t0 (Co i (-> t1 k))))))
  2y (\ i t0 t1 t2 (\ x k
   (eval (AB x) (>- t1 (Co i-push
    (eval (A x) (>- t0 (Co i (-> t2 k)))))))))
  2f (\ i k x
   (: go (\ i k x xs
       (Co i-push (eval x (>- 'num (Co i (2f i k xs))))))
    (? x (go i k (A x) (B x)) (-> 'num k))))

  3y (\ i t0 t1 t2 t3 (\ x k
    (eval (A (BB x)) (>- t2
     (Co i-push (eval (AB x) (>- t1
      (Co i-push (eval (A x) (>- t0
       (Co i-tset (-> t3 k))))))))))))
  ary (\ l m ((at l (len m)) m))
  (tbl
   id (\ x k (eval (A x) k))
   + (abel + 0 i-add)
   * (abel * 1 i-mul)
   - (\ x k
    (? (nilp x) (Im 0 k)
       (nilp (B x)) ((1y i-neg 'num 'num) x k)
       (: y (grp + 0 0 (B x))
          z (? (nump (A x)) (grp - (A x) 0 y) (X (A x) y))
        (? z (eval (A z) (>- 'num (2f i-sub k (B z))))
             (Im 0 k)))))
   L (\ x k (:
    loop (\ x k (? x (loop (B x) (Co i-push (eval (A x) (Co i-cons (-> 'two k))))) k))
    (Im () (loop x k))))
                
   / (\ x k
    (? (nilp x) (Im 1 k)
       (nilp (B x)) (eval (A x) (>- 'num k))
       (: b (grp * 1 1 (B x))
          c (? (nump (A x)) (grp / (A x) 1 b) (X (A x) b))
        (? c (eval (A c) (>- 'num (2f i-dqv k (B c))))
             (Im 1 k)))))
   <  (ordr i-lt) <= (ordr i-lteq) >= (ordr i-gteq) > (ordr i-gt)
   A (1y i-car 'two ())
   B (1y i-cdr 'two ())
   X (2y i-cons () () 'two)

   ;; be nice to the compiler
   emi  (2y i-emi 'num 'hom 'hom)
   emx  (2y i-emx () 'hom 'hom)
   tget (2y i-tget 'tbl () ())
   tset (3y i-tset 'tbl () () ())

   = (\ x k (?
    (? x (nilp (B x)) 0) (Im 0 k)
    (? (: q (map (filter x qtd) unq)) (: r (A q)
      (any (B q) (\ v (nilp (= v r))))))
     (Im () k)
    (eval (A x) (Co i-push (? (BB x)
     (: fold (\ k x y
       (Co i-dupl (eval x (Co i-eq (? y
        (Co i-barnch (peek2 (fold k (A y) (B y))))
        k)))))
      (pop2 (fold (push2 k) (AB x) (BB x))))
     (eval (AB x) (Co i-eq k)))))))

   nilp (1y i-nilpp () ())
   fail (0y i-fail ())))
 ev ; comment this line to define internals at toplevel
 ))))

; bootstrap
(ev lib) (ev egg) ; C -> prelips
(ev lib) (ev egg) ; prelips -> lips
(:     precompose (\ x .
      (ev(L'\'x(foldl x'x(\ m e(L(L'` e)m)))))))
; "drop privileges"
(each '(lib egg macros ns emi emx hom hseek hgeti hgetx hfin)
      (\ v (tdel ns v)))
