(: local-vars '(local-vars old-ev lib egg s0 s1 s2 macros ns emi emx hom hseek hgeti hom-get-x hfin)
   lib '(,
  ;; here's some data constructors
  (: and (\ l (? l (? (A l) (and (B l))) 0))
     && (\ l . (and l))
     or (\ l (? l (: a (A l) (? a a (or (B l))))))
     || (\ l . (or l))
     L (\ . . .) ; dot only has special meaning following another argument, which can be dot
     ++ (\ a b(?(twop a)(X(A a)(++(B a)b))b)) ; append
     iota (\ n x .
      (: iota.l (\ m n (? (< m n) (X m (iota.l (+ m 1) n))))
       (? (nilp x) (iota.l 0 n) (iota.l n (A x)))))
      rho (\ n xs .
       (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
        (?(> n 0)(rho.l n xs)))))

  ;; here's some of your standard Functinal Progming stuf
  (: map (\ f x (? x (X (f (A x)) (map f (B x)))))
     foldl(\ z f x (? x (foldl (f z (A x)) f (B x)) z))
     foldr (\ z f x (? x (f (A x) (foldr z f (B x))) z))
     foldl1 (\ f x (foldl (A x) f (B x)))
     foldr1  (\ f x (? (B x) (f (A x) (foldr1 f (B x)))
                             (A x)))
     id (\ x x)
     each (\ x f (? x (,(f (A x)) (each (B x) f))))
     all (\ p l (? l (? (p (A l)) (all p (B l))) 0))
     any (\ p l (? l (? (p (A l)) 0 (any p (B l)))))
     partition (\ p l (? (nilp l) '(())
      (: a (A l) m (partition p (B l))
       (? (p a) (X (X a (A m)) (B m))
                (X (A m) (X a (B m)))))))

     filter (\ f x (? x ((\ a y
      (? (f a) (X a y) y)) (A x) (filter f (B x)) )))
     at (\ l n (? (< n 1) (A l) (at (B l) (- n 1))))
     atn (\ n (\ l (at l n)))
     flip (\ f (\ x y (f y x)))
     set (\ x . (: d (tbl) (, (each x (\ y (tset d y ()))) d)))
     curry (\ f (\ x (\ y . (ap f (X x y))))))
  ;; and some list functions
  (: snoc  (\ l x (? (twop l) (X (A l) (snoc (B l) x))
                              (X x l)))
     init (\ l (? (B l) (X (A l) (init (B l)))))
     last (\ l (? (B l) (last (B l)) (A l)))

     rev (\ l (,
      (: rev.i (\ l m (? l (rev.i (B l) (X (A l) m)) m)))
      (rev.i l ())))
     ldel (\ l k (? l
      ((? (= k (A l)) id (\ m (X (A l) m)))
       (ldel (B l) k))))
     elem (\ l x (< -1 (idx l x)))
     ldiff (\ l m (?
      (nilp m) l
      (ldiff (ldel l (A m)) (B m))))
     idx (\ l x
      ((: .l (\ l x n (? (twop l) (? (= x (A l)) n (.l (B l) x (+ n 1))) -1)))
       l x 0))
     len (\ l (? (twop l) (+ 1 (len (B l))) 0)))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: defm (\ n x . (,(tset macros n (: v (ev (A x))))
                           (? (B x) (ap defm (B x)) v))))
   'AA (\ x (X A (X (X A (X x))))) 'AB (\ x (X A (X (X B (X x)))))
   'BA (\ x (X B (X (X A (X x))))) 'BB (\ x (X B (X (X B (X x)))))
   'immediate (\ x (L '` (ev x)))
   ; bind
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a .
    ((: case.i (\ x a
      (? a (? (B a) (L '? (L '= x (A a)) (A (B a))
                      (case.i x (B (B a))))
                     (A a))))) x a)))))

(: egg '(:
 env (\ a p n (>>=
  ((: asig (\ a n
       (? (twop a)
        (? (? (twop (B a)) (= '. (AB a)))
         (X (- (+ n 1)) (L (A a)))
         (>>= (asig (B a) (+ n 1)) (\ r
          (X (A r) (X (A a) (B r))))))
        (X n a)))) a 0) (\ b
  (tbl 'arg (B b) 'loc ()
       'clo ()     'par p
       'lam (tbl)  'nom n
       'val (tbl)  'sig (A b)))))

 qtd (\ x (? (twop x) (= (A x) '`) (nilp (symp x))))
 unq (\ x (? (twop x) (AB x) x))
 fuse (:
  f1 (\ g xs . (\ i p (>>= (g p) (hseek p 1) (\ a q
   ((: loop (\ xs (? xs
     (? (= a (A xs)) (emi (AB xs) q) (loop (BB xs)))
     (emi i p)))) xs)))))

  argr (\ a b (f1 hgetx 0 a 1 b))
  brr (\ b (f1 hgeti i-branch b))
  (tbl
   i-argn (argr i-arg0 i-arg1)
   i-locn (argr i-loc0 i-loc1)
   i-clon (argr i-clo0 i-clo1)
   i-lt (brr i-brlt) i-lteq (brr i-brlteq)
   i-gt (brr i-brgt) i-gteq (brr i-brgteq)
   i-eq (brr i-breq)
   i-nilpp (f1 hgeti i-branch i-barnch i-barnch i-branch)
   i-call (\ i h (>>= (hgeti (hseek h 1)) (\ j (case j
    i-ret (emi i-rec (emx (hgetx h) (hseek h 1)))
    (emi i h)))))
   i-immv (f1 hgetx () i-unit 0 i-zero 1 i-one)))

 emif (\ i h ((? (: q (tget fuse i)) q emi) i h))

 inst (\ e m i k (emif i (k e (+ m 1))))
 insx (\ e m i x k (emif i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x (-> (t-tag x) k)))
 immk (\ x k (code i-immv (data x (-> (t-tag x) k))))

 eval (\ x k ((? (twop x) ev-list (symp x) ev-sym immk) x k))
 code (\ i k (\ e m (inst e m i k)))
 data (\ x k (\ e m (emx x (k e (+ m 1)))))

 t-c (\ x (case x
  'hom 0 'num 1 'two 2 'vec 3 'oct 4
  'tbl 5 'sym 6 'nil 7 () 8 (fail)))

 late (\ e m x d k (>>= (k e (+ m 2)) (\ h
  (>>= (consumes h) (\ t
   (>>= (? t (hseek h 1) h) (\ h
    (emif i-lbind (emx (X (t-c t) (X d x)) h)))))))))

 ev-sym (\ x k (\ e m (:
  s (A (: r (look e x)))
  (case s
   'here (imm e m (B r) k)
   'wait  (late e m x (B r) k)
   (? (= e (B r))
    (case s 'arg (insx e m i-argn (idx (tget e'arg) x) k)
            'loc (insx e m i-locn (idx (tget e'loc) x) k)
            'clo (insx e m i-clon (idx (tget e'clo) x) k))
    (, (: l (len (tget e'clo)))
       (tset e'clo(snoc (tget e'clo) x))
       (insx e m i-clon l k)))))))

 toplp (\ e (nilp (tget e'par)))
 look (\ e y (?
  (thas (tget e 'val) y) (X 'here (tget (tget e 'val) y))
  (toplp e) (?
   ; if it's already defined then bind early unless we are
   ; redefining it.
   (? (thas ns y) (nilp (elem (tget e'loc) y)))
    (X 'here (tget ns y))
   (X 'wait ns))
  (elem (tget e'lam) y) (X 'wait (tget e 'val))
  (elem (tget e'loc) y) (X 'loc e)
  (elem (tget e'arg) y) (X 'arg e)
  (elem (tget e'clo) y) (X 'clo e)
  (look (tget e'par) y)))

 ; this function has a lot of arguments sorry...
 assert (\ e m t k (,
   (: type (\ t h
     ((\ t u (case u () h
                     t (type t (hseek h 1))
                     (fail)))
      t (consumes h))))
  (type t (k e m))))
 consumes (\ h (? (: c (tget t-checks (hgeti h))) c))
 >- (\ t k (? (: tc (tget t-checks t)) (code tc k) (fail)))
 -> (\ t k (\ e m (assert e m t k)))

 pushr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (A (tset e s (X k (tget e s)))))))))
 popr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (, (tset e s (B (tget e s))) k))))))
 peekr (\ s (\ k (\ e m (>>= (k e (+ m 1)) (\ k
  (emx (A (tget e s)) k))))))

 push1 (pushr 's1) push2 (pushr 's2)
 pop1 (popr 's1) pop2 (popr 's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 inliners (:
  grp (\ f m id x
   (: fold (\ f m x (? (nilp x) (X m)
             (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
                                  (>>= (fold f m (B x)) (\ z
                                   (X (A z) (X y (B z))))))))
    (? (= id (A (: j (fold f m x)))) (B j) j)))

  ordr (\ i (\ x k (?
   (nilp x) (immk 0 k)
   (eval (A x) (? (nilp (B x)) k
    (: fold (\ k x y
      (eval x (code i (? (nilp y) (push2 k)
       (code i-barnch (peek2 (code i-push
        (fold k (A y) (B y)))))))))
     (code i-push (pop2 (fold k (AB x) (BB x))))))))))
  bf0 (\ i k x
   (: bf (\ i k x xs
       (code i-push (eval x (>- 'num (code i (bf0 i k xs))))))
    (? x (bf i k (A x) (B x)) (-> 'num k))))

  abel (\ f z i (\ x k (>>= (grp f z z x) (\ x
   (eval (A x) (>- 'num (bf0 i k (B x))))))))

  (tbl
   + (abel + 0 i-add)
   * (abel * 1 i-mul)
   - (\ x k
    (? (nilp x)
        (immk 0 k)
       (nilp (B x))
        (eval (A x) (>- 'num (code i-neg (-> 'num k))))
       (: y (grp + 0 0 (B x))
          z (? (nump (A x)) (grp - (A x) 0 y) (X(A x)y))
        (? z (eval (A z) (>- 'num (bf0 i-sub k (B z))))
             (immk 0 k)))))
   / (\ x k
    (? (nilp x) (immk 1 k)
       (nilp (: a (B x)))
        (eval (A x) (>- 'num k))
      (: b (grp * 1 1 a)
         c (? (nump (A b)) (grp / (A x) 1 b) (X (A x) y))
       (? c (eval (A c) (>- 'num (bf0 i-dqv k (B c))))
            (immk 1 k)))))
   <  (ordr i-lt) <= (ordr i-lteq) >= (ordr i-gteq) > (ordr i-gt)
   A (\ x k (eval (A x) (>- 'two (code i-car k))))
   B (\ x k (eval (A x) (>- 'two (code i-cdr k))))
   X (\ x k (eval (? (: y (B x)) (A y))
             (code i-push (eval (A x)
              (code i-cons (-> 'two k))))))
 
   ;; be nice to the compiler
   emi (\ x k
    (eval (AB x) (>- 'hom
     (code i-push (eval (A x) (>- 'num
      (code i-emi (-> 'hom k))))))))
   emx (\ x k
    (eval (AB x) (>- 'hom
     (code i-push (eval (A x)
      (code i-emx (-> 'hom k)))))))
    tget (\ x k
     (eval (AB x) (code i-push
      (eval (A x) (>- 'tbl (code i-tget k))))))
 
    tset (\ x k
     (eval (A (BB x))
      (code i-push (eval (AB x)
       (code i-push (eval (A x) (>- 'tbl
        (code i-tset k))))))))

   = (\ x k (?
    (? (: q (map unq (filter qtd x))) (: r (A q)
      (any (\ v (nilp (= v r))) (B q))))
     (immk () k)
    (? x (nilp (B x)) 0) (immk 0 k)
    (eval (A x) (code i-push (? (BB x)
     (: fold (\ k x y
       (code i-dupl (eval x (code i-eq (? y
        (code i-barnch (peek2 (fold k (A y) (B y))))
        k)))))
      (pop2 (fold (push2 k) (AB x) (BB x))))
     (eval (AB x) (code i-eq k)))))))
 
    && (\ x k (?
     (nilp x) (immk 0 k)
     (any nilp x) (immk () k)
     (: fold (\ x y k 
       (eval x (? (nilp y) k (code i-barnch
        (peek2 (fold (A y) (B y) k))))))
      (pop2 (fold (A x) (B x) (push2 k))))))
   nilp (\ x k (eval (A x) (code i-nilpp k)))
   fail (\ x k (code i-fail k))))

 ev-ap (\ x k (:
  ev-api (\ x k (? (nilp x) k
   (ev-api (B x) (eval (A x) (code i-push k)))))
  (>>= (A x) (B x) (\ z x
   (? (: q (tget inliners z))
    (q x k)
   (ev-api x (eval z (>- 'hom (code i-call (data (len x) k))))))))))

 ev-seq (\ x k
  ((: ev-seqr (\ x k (? (nilp x) k (eval (A x) (ev-seqr (B x) k)))))
    (B x) k))

 cde (\ e m x k
 ; the rewrite ensures the : expression is always an even form.
  (: cder (\ x k (? (nilp x) k (>>= (cder (BB x) k) (\ k
     (? (|| (toplp e) (< -1 (idx (tget e 'loc) (A x))))
         (eval (AB x) (cdeb (A x) k))
        (eval (A x) k))))))
     cdeb (\ x k (\ e m (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (tget e 'loc) x) k))))
    ((cder (B x) k) e m)))

 ev-if (\ x k (:

  ccoprecon (\ k (\ e m
   (>>= (k e (+ m 2)) (\ x
    (>>= (A (tget e 's2)) (\ brx
     (: i (hgeti brx) (case i
      (? (= i i-ret) (emif i x)
       (emif i-jump
        (emx (? (= i i-jump) (hgetx (hseek brx 1)) brx) x)))))))))))

  ccor (\ x k (?
   (nilp (B x)) (eval (A x) (ccoprecon k))
   (eval (A x) (pop1 (code i-branch (peek1
     (ccor (BB x) (push1 (eval (AB x) (ccoprecon k))))))))))

  (pop2 (ccor (B x) (push2 k)))))


 quote (\ x (? (qtd x) x (L '` x)))
 rw-sym (\ e x (: l (look e x)
  (? (= (A l) 'here) (quote (B l)) x)))

 rw-let (\ e x
  (: desug (\ d (L (L '\ (L ', (init d) (last d)))))
     sdefa (\ e y x
      (? (qtd x) (tset (tget e'val) y (unq x))
         (, (tset e'loc(X y (tget e'loc)))
            (? (twop x) (? (= '\ (A x))
             (tset (tget e'lam) y x))))))
     loop (\ e x (? x
      (: z (rw e (AB x)) y (A x)
       (, (sdefa e y z)
          (X y (X z (loop e (BB x))))))))
   (? (B x) (?
    (= 0 (% (len x) 2)) (desug x)
    (X ': (loop e (B x)))))))

 rw-seq (\ e x (:
  rw-seqr (\ e x (?
   (nilp (B x)) (L (rw e (A x)))
    (: y (rw e (A x))
       z (rw-seqr e (B x))
     (? (|| (symp y) (qtd y)) z (X y z)))))
  (? (: y (B x))
     (: z (rw-seqr e y) (? (B z) (X ', z) (A z))))))

 ; this rewrites lambda expressions of the form
 ;   (\ (: a b c)) -> (\ (, (: a b) c))
 ; which is always safe and assert better code.
 rw-lam (\ e l
  (: defp (\ x (? (twop x) (= (A x) ':)))
     deftp (\ x (? (defp x) (= 0 (% (len x) 2))))
     trlamp (\ l (? (B l) (deftp (last l))))
     rw-lamm (\ l (>>= (last l) (\ m (snoc (init l) (L ', (init m) (last m))))))
   (? (trlamp l) (rw-lamm l) l)))

 pures (immediate (set
  L X A B + - * / % id flip curry ++ iota rho partition
  snoc init last rev ldel elem at atn idx ldiff len
  homp nilp symp nump tblp strp twop
  && || scat slen sget ssub str))
 abelians (immediate (tbl && 0 || () + 0 * 1))
 monoids (immediate (tbl scat "" ++ ()))

 monofold (\ f i l (:
  mfold (\ f i j x y
   (? y (? (qtd x) (mfold f i (f j (unq x)) (A y) (B y))
                   (: z (X x (mfold f i i (A y) (B y)))
                    (? (= i j) z (X j z))))
      (qtd x) (>>= (f j (unq x)) (\ x (? (= i x)()(L x))))
      (= i j) (L x)
      (L j x)))
  (? l (X f (mfold f i i (A l) (B l))) (quote i))))

 rw-arity (\ x (: z (A x) (?
  (? (homp z) (= i-arity (hgeti z)))
   (? (>= (len (B x)) (hgetx (hseek z 1)))
      (X (hseek z 2) (B x))
      (ap z (B x)))
  x)))
 rw-list (\ e x (: a (A x) (case a
  '` (? (B x) x)
  '\ (rw-lam e x)
  ': (rw-let e x)
  '? (rw-if e (B x))
  ', (rw-seq e x)
  (? (thas macros a)
      (rw e (ap (tget macros a) (B x)))
     (: z (rw-arity (map (\ x (rw e x)) x)) q (A z) (?
      (nilp (thas pures q)) z
      (? (all qtd z)
          (quote (ap q (map unq (B z))))
         (thas abelians q)
          (: ff (partition qtd (B z))
             fg (ap q (A ff))
             (X q (? (= fg (tget abelians q))
                     (B ff) (X fg (B ff)))))
         (thas monoids q)
          (monofold q (tget monoids q) (B z))
         z)))))))

 rw-if (\ e x
  (: rw-ifr (\ e x (?
      (nilp x) (L ())
      (nilp (B x)) (L (rw e (A x)))
      (: a (rw e (A x))
       (? (qtd a) (? (unq a) (L (rw e (AB x)))
                             (rw-ifr e (BB x)))
        (X a (X (rw e (A (B x))) (rw-ifr e (BB x))))))))
   (: r (rw-ifr e x) (? r (? (B r) (X '? r) (A r))))))

 rw (\ e x (?
  (twop x) (rw-list e x)
  (symp x) (rw-sym e x)
  (quote x)))

 ev-part (\ e x m (>>= (rw e x) (\ x (,
  (resolve e)
  ((eval x ini)e m)))))

 ltu (\ e nom l
  (: n (|| (B l) '(()))
     x (last n)
     f (env (init n) e (X nom (tget e 'nom)))
   (,
      (>>= (ev-part f x 4) (\ k
       (>>= (? (nilp (tget f 'loc)) k
              (emif i-prel (emx (len (tget f 'loc)) k))) (\ k
        (>>= (hfin (?
             (> (: i (tget f 'sig)) 0) (emif i-arity (emx i k))
             (< i 0) (emif i-vararg (emx (- (- i) 1) k))
             k)) (\ k
         (? (tget f 'clo) (X (tget f 'clo) k) k))))))))))

 resolve (\ e
  (: precomps (\ e ks (? ks
      (: k (A ks) i (ltu e k (tget (tget e 'lam) k)) (,
       (? (homp i) (, (tset (tget e 'val) k i)
                      (tdel (tget e 'lam) k)
                      (tset e'loc(ldel (tget e 'loc) k)))
                   (: lams (tget e'lam)
                         j (X (A i) (tget lams k))
                       (tset lams k j)))
       (precomps e (B ks))))))

     okvs (\ e vs (?
      (nilp vs) 0
      (: v (A vs)
       (? (|| (thas (tget e 'lam) v) (thas (tget e'val) v))
          (okvs e (B vs))))))

     elim (\ e ks (? ks (>>= (A ks) (\ k (?
      (nilp (okvs e (A (tget (tget e 'lam) k))))
       (, (tdel (tget e'lam) k) (elim e (tkeys (tget e'lam))))
      (elim e (B ks)))))))

     recomps (\ e d ks (? ks (: k (A ks) (,
      (tset e 'loc (ldel (tget e 'loc) k))
      (tset (tget e 'val) k (ltu e k (B (tget d k))))
      (recomps e d (B ks))))))

   (, (precomps e (tkeys (tget e 'lam)))
      (elim e (tkeys (tget e'lam)))
      (: ls (tget e 'lam) (recomps e ls (tset e 'lam (tkeys ls)))))))

 t-tag (\ x (?
  (homp x) 'hom (nump x) 'num
  (twop x) 'two (vecp x) 'vec
  (symp x) 'sym (strp x) 'oct
  (tblp x) 'tbl (nilp x) 'nil))
 t-checks (tbl
  i-idhom 'hom 'hom i-idhom
  i-idnum 'num 'num i-idnum
  i-idtwo 'two 'two i-idtwo
  i-idtbl 'tbl 'tbl i-idtbl)


 ev-la (\ x k (:
  gnom (\ e k (: i (hgeti k) (case i
   i-tbind (hgetx (hseek k 1))
   i-setl  (at (tget e'loc) (hgetx (hseek k 1))))))

  claclo (\ e arg (:
   clacloin (\ e arg k (?
    (nilp arg) k
    (clacloin e (B arg)
     (eval (A arg) (code i-push k)))))
   ((clacloin e arg (\ e m
     (emif i-take (emx (len arg) (hom (+ m 2))))))
    e 0)))
  (\ e m (>>= (assert e (+ m 2) 'hom k) (\ k
   (>>= (ltu e (gnom e k) x) (\ x (?
    (homp x) (emif i-immv (emx x k))
    (emif (? (tget e'loc) i-encll i-encln)
     (emx (X (B x) (claclo e (A x))) k))))))))))

 ev-qt (\ x k (immk (AB x) k))
 ev-de (\ x k (\ e m (cde e m x k)))
 ev-list (\ x k (: z (A x) ((case z
  '` ev-qt
  '? ev-if
  ': ev-de
  '\ ev-la
  ', ev-seq
  ev-ap) x k)))

 ini (\ e m (insx e m i-ret (tget e'nom) (\ e m (hom m))))
 ev (\ x ((ev-part (env () () 'ev) x 0)x))
 ev))

(ev lib)
(: ev (ev egg))
(ev lib)
(: ev (ev egg))
(each local-vars (\ v (tdel ns v)))
