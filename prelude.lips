(: lib '(,
  (: ~ nilp 2p twop Hp homp Tg tget Ts tset
     (and l)  (? l (? (A l) (and (B l))) 1)
     (&& l .) (and l)
     (or l)   (? l (: a (A l) (? a a (or (B l)))))
     (|| l .) (or l)

     (L . .) .
     (cat a .) (: (app a b) (? a(X(A a)(app(B a)b))b)
      (foldr a () app))

     (iota n x .)
      (: (loop m n) (? (< m n) (X m (loop (+ m 1) n)))
       (? (~ x) (loop 0 n) (loop n (A x))))

     (rho n xs .)
      (: (loop n x) (?(= n 1)x(cat x(loop(- n 1)x)))
       (?(> n 0)(loop n xs)))

     (id x) x (const x) (\ x)

     (foldr x z f) (? x (f (A x) (foldr (B x) z f)) z)
     (foldl x z f) (? x (foldl (B x) (f z (A x)) f) z)
     (foldl1  x f) (foldl (B x) (A x) f)
     (foldr1  x f) (? (B x) (f (A x) (foldr1 (B x) f)) (A x))
     (map     x f) (foldr x () (\ x m (X (f x) m)))

     (each x f) (? x (,(f (A x)) (each (B x) f)))
     (all l p) (? l (? (p (A l)) (all (B l) p)) 0)
     (any l p) (? l (? (p (A l)) 0 (any (B l) p)))
     (part l p) (foldr l '(()) (\ a m
      (? (p a) (X (X a (A m)) (B m))
               (X (A m) (X a (B m))))))
     (intercal i l) (:
      (loop i l m) (? (~ m) l (cat l i (intercal i m)))
      (? l (loop i (A l) (B l))))

     (filter x p) (foldr x () (\ x m (? (p x) (X x m) m)))
     (at l n) (? (< n 1) (A l) (at (B l) (- n 1)))
     (flip f) (\ x y (f y x))
     (diag f) (\ x (f x x))
     (cu f x .) (\ y . (ap f (cat x y)))
     ({set} x .) (: d (tbl) (, (each x (\ y (Ts d y ()))) d))

     (snoc l x) (? l (X (A l) (snoc (B l) x)) (L x))
     (init l) (? (B l) (X (A l) (init (B l))))
     (last l) (? (B l) (last (B l)) (A l))

     (memq x k) (? x (? (= k (A x)) x (memq (B x) k)))
     (rev l) (foldl l () (\ r x (X x r)))
     (ldel l k) (filter l (\ x (~ (= x k))))
     (idx l x) (:
      (loop l x n)
       (? l (? (= x (A l)) n (loop (B l) x (+ n 1))))
      (loop l x 0))
     (len l) (? l (+ 1 (len (B l))) 0))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: (defm n x .) (,(Ts macros n (: v (ev (A x))))
                          (? (B x) (ap defm (B x)) v)))
   'AA (\ x (X A (L (X A (L x))))) 'AB (\ x (X A (L (X B (L x)))))
   'BA (\ x (X B (L (X A (L x))))) 'BB (\ x (X B (L (X B (L x)))))
   'imm (\ x (ev x))
   '&& (\ x . (? x ((: & (\ x
     (? (B x) (L '? (A x) (& (B x))) (A x)))) x) 1))
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a . (: y (gensym)
    (L ': y x ((: (loop a)
      (? a (? (B a) (L '? (L '= y (A a)) (A (B a))
                      (loop (B (B a))))
                     (A a)))) a)))))))

(: egg '(: ev (ev '(:
 ; this function creates a new lexical environment.
 ; if the second argument (the parent scope) is nil,
 ; then the expression is compiled in the global scope.
 (env a p n)  (:
  (asig a n)
   (? (~ a) (X n a)
    (? (? (B a) (= '. (AB a)))
     (X (- (+ n 1)) (L (A a)))
      (>>= (asig (B a) (+ n 1)) (\ r
       (X (A r) (X (A a) (B r)))))))
  (>>= (asig a 0) (\ b (tbl 'arg (B b) 'par p
                            'nom n 'def (tbl)
                            'val (tbl) 'sig (A b)))))

 (toplp e) (~ (Tg e'par))

 ; this function is used in several places to look for a
 ; variable's value, or failing that to find where it's bound.
 (look e y) (?
  (thas (Tg e 'val) y)
   (X 'here (Tg (Tg e'val) y))
  (toplp e)
   ; toplevel bindings are special. if it's already defined
   ; we usually want to bind early, but we also want to allow
   ; redefinition, so in that case bind late.
   (? (&& (thas ns y) (~ (thas (Tg e'def) y)))
    (X 'here (Tg ns y))
    (X 'wait ns))
  (memq (Tg e'clo) y) (X 'clo e)
  (memq (Tg e'dfr) y) (X 'wait (Tg e'val))
  (memq (Tg e'loc) y) (X 'loc e)
  (memq (Tg e'arg) y) (X 'arg e)
  (look (Tg e'par) y))

 ; ltu : evaluate a lambda expression.
 ; depending on if it encloses any variables, a lambda
 ; expression may or may not have a value at compile time. this
 ; function returns either a function or a pair; in the latter
 ; case the hd is the list of variables it encloses, and the
 ; tl is the "prototype" thread that expects those variables
 ; to have already been assembled in a closure. the enclosing
 ; scope can then compose the prototype with a constructor
 ; for its closure in order to produce an "instance" of the
 ; function at runtime.
 (ltu e nom l) (:
  (loc k) (? (~ (: loc (Tg f 'loc))) k
           (emi i-locals (emx (len loc) k)))
  (ar k) (: i (Tg f 'sig) (?
   (> i 0) (emf i-arity (emx i k))
   (< i 0) (emi i-vararg (emx (- (- i) 1) k))
   k))

  n (|| (B l) '(()))
  f (env (init n) e (X nom (Tg e'nom)) nom)
  x (weak f (last n))

  (?
   ; if the function is nonvariadic and all it does is apply
   ; another known function to its exact list of arguments,
   ; then it's an alias for the second function.
   (&& (2p x) (Hp (A x)) (>= (Tg f 'sig) 0) (= (B x) (Tg f'arg)))
    (A x)
   ; otherwise compile it
   (: k (hfin (ar (loc ((eval x ini) f 4))))
    ; free variables or not ?
    (? (: clo (Tg f 'clo)) (X clo k) k))))


 ; first compiler moiety : the " weak evaluator "
 ; 1. construct the local scope of the function
 ; 2. desugaring, macroexpansion, and partial evaluation
 ;    (constant folding, dead code elimination, etc), which has
 ;    some preliminary "static type checking" as a side effect
 ; it populates the local variables list and the known values
 ; dictionary in the function environment, and returns an
 ; expression with the same value (under eval) as the input,
 ; but pre-evaluated "as much as possible". to tell if an
 ; expression was fully evaluated, check whether the image is
 ; quoted.
 (qtd x) (? (twop x) (= (A x) '`) (~ (symp x)))
 (unq x) (? (twop x) (AB x) x)
 (quote x) (? (qtd x) x (L '` x))

 (weak e x)  (:

  (rwlade x) (X(AA x)(X(X'\(snoc(BA x)(AB x)))(BB x)))

  (loop e x) (? x (?
   (2p (A x)) (loop e (rwlade x))
   (, (? (qtd (: a (AB x))) (Ts (Tg e'val) (A x) (unq a))
                            (Ts (Tg e'def) (A x) a))
      (rec e a)
      (loop e (BB x)))))

  (rec e x) (? (2p x) (case (A x)
   '\ () '` ()
   ': (? (= 1 (% (len x) 2)) (loop e (B x)))
   (each x (\ x (rec e x)))))

  (, (rec e x) (resolve e) (wv e x)))

 ; this is a huge complicated procedure for "resolving
 ; the addresses" of sets of mutually recursive functions at
 ; compile time, so they can call each other without closures.
 ; what it actually does is construct the maximum set of
 ; named functions with no free variables except those
 ; referring to other functions also in the set; then it
 ; recompiles these functions so all the in-set references get
 ; resolved (with optimizations etc) at runtime, which lets
 ; the compiler generate appropriate code without yet
 ; knowing the exact value. without this mechanism everything
 ; would still work correctly, but many functions (including
 ; simple self-recursive functions) would run more slowly when
 ; defined elsewhere than in the global scope.
 (resolve e) (:

  ; step one: pass over each inner def for this function and
  ; try to rewrite and evaluate it. if this succeeds, add it
  ; to the known values. otherwise, if the definition is for
  ; a function, collect it into a list.
  (f1 e kvs) (? kvs (?
   (thas (Tg e'val) (: kv (A kvs) k (A kv)))
    (f1 e (B kvs))
   (: qq (wv e (B kv)) bb (f1 e (B kvs)) (?
    (qtd (Ts (Tg e'def) k qq))
     (, (Ts (Tg e'val) k (unq qq))
        (tdel (Tg e'def) k)
        bb)
    (&& (2p qq) (= '\ (A qq)))
     (X (X k qq) bb)
    bb))))

  (f2 e kvs) (? kvs (: kv (A kvs) rr (f2 e (B kvs)) (?
   (Hp (: i (ltu e (: k (A kv)) (: v (B kv)))))
    (, (Ts (Tg e'val) k i)
       (tdel (Tg e'def) k)
       rr)
   (X (X k (X (A i) v)) rr))))

  (f3r e i kvs q) (:
   (chk e i vs) (? (~ vs) 1 (: v (A vs) (?
    (|| (any i (\ j (= (A j) v))) (thas (Tg e'val) v))
     (chk e i (B vs)))))

   (? (~ kvs) q (?
    (chk e i (AB (: kv (A kvs))))
     (f3r e i (B kvs) (X kv q))
    (f3 e (ldel i kv)))))

  (f3 e kvs) (f3r e kvs kvs ())

  (f4 e kvs) (? (~ kvs)
   (Ts e'loc (tkeys (Tg e'def)))
   (, (tdel (Tg e'def) (: kv (A kvs) k (A kv)))
      (Ts e 'dfr (X k (Tg e'dfr)))
      (f4 e (B kvs))
      (Ts (Tg e'val) k (ltu e k (BB kv)))))


  ; only bother with this if there are any inner defs
  (? (: ks (tkeys (: def (Tg e'def))))
   (f4 e (f3 e (f2 e (f1 e (map (Ts e'loc ks) (\ k
    (X k (Tg def k))))))))))

 (wv e x)  (:
  (list e x) (:

   ; static arity check : we can skip the intrinsic
   ; check in the called function just by incrementing
   ; the pointer.
   (adj-ar x) (: z (A x) (?
    (~ (? (Hp z) (= i-arity (hgeti z)))) x
    (? (>= (len (B x)) (hgetx (hseek z 1)))
     (X (hseek z 2) (B x))
     (ap z (B x))))) ; but if it fails, purposely cause an arity error

   (defn e x) (:
    (suga d) (L (L '\ (L ', (init d) (last d))))
    (loop e x) (? x (:
     y (? (2p (A x)) (AA x) (A x))
     ll (loop e (BB x))
     (X y (X (Tg (Tg e'def) y) ll))))
    (? (B x) (? (= 0 (% (len x) 2)) (suga x)
                (X ': (loop e (B x))))))

   (lamb e l) (:
    (trlamp l) (&& (B l) (: x (last l)
     (&& (2p x) (= (A x) ':) (= 0 (% (len x) 2)))))
    (wv-lamm l) (: m (last l)
     (snoc (init l) (L ', (init m) (last m))))
    (? (trlamp l) (wv-lamm l) l))

   (mono f i l) (:
    (fold f i j x y) (?
     y (? (qtd x) (fold f i (f j (unq x)) (A y) (B y))
          (: z (X x (fold f i i (A y) (B y)))
           (? (= i j) z (X j z))))
     (qtd x) (>>= (f j (unq x)) (\ x (? (= i x)()(L x))))
     (= i j) (L x)
     (L j x))
    (? l (X f (fold f i i (A l) (B l)))
         (quote i)))

   (cond e x) (:
    (rec e x) (?
     (~ x) (L ())
     (~ (B x)) (L (wv e (A x)))
     (~ (qtd (: a (wv e (A x)))))
      (X a (X (wv e (A (B x))) (rec e (BB x))))
     (unq a) (L (wv e (AB x)))
     (rec e (BB x)))
    (? (: r (rec e x))
     (? (B r) (X '? r) (A r))))

   (seq e x) (:
    (loop e x) (?
     (nilp (B x)) (L (wv e (A x)))
     (: z (loop e (B x))
        y (wv e (A x))
      (? (|| (symp y) (qtd y)) z (X y z))))
    (? (: y (B x)) (: z (loop e y)
                    (? (B z) (X ', z) (A z)))))

   ; these data structures encode rules for partially evaluating
   ; different functions. right now the functions eligible for
   ; partial evaluation are hardcoded. but the compiler should
   ; be able to infer if a function is pure in many cases, and
   ; users should be able to provide their own monoid instances
   ; (or whatever).

   ; having a hardcoded list is not ideal ...
   pures (imm ({set}
    L X A B + - * / % id flip cat iota rho const
    snoc init last rev ldel memq at idx len
    homp nilp symp nump tblp strp twop vecp
    && || scat slen sget ssub str))

   ; these enable extra partial evaluation for functions
   ; with certain algebraic properties. the nullary case for
   ; any grouplike function has to return its structure's
   ; identity element.
   monoids (imm ({set} scat cat))   ; pairs of consecutive arguments can be combined in place
   abelians (imm ({set} && || + *)) ; arguments can be combined freely

   a (A x) (case a
    '` (? (B x) x)
    '\ (lamb e x)
    ': (defn e x)
    '? (cond e (B x))
    ', (seq e x)
    (? (thas macros a)
        (wv e (ap (tget macros a) (B x)))
       (: z (map x (\ x (wv e x))) q (A z) r (B z) (?
        (nilp (thas pures q)) (adj-ar z)
        (all r qtd) (quote (ap q (map r unq)))
        (thas monoids q) (mono q (q) r)
        (thas abelians q) (:
         ff (part r qtd)
         fg (ap q (map (A ff) unq))
         (X q (? (= fg (q)) (B ff)
               (X fg (B ff)))))
        (adj-ar z))))))

  (symb e x) (: l (look e x) (?
   (= (A l) 'here) (quote (B l))
   (nilp (thas (: defs (tget e'def)) x)) x
   (: dd (wv e (tdel defs x))
    (? (nilp (qtd (tset defs x dd))) x (,
     (tdel (tget e'def) x)
     (tset (tget e'val) x (unq dd))
     dd)))))

 (? (twop x) (list e x) (symp x) (symb e x) x))

 ; second moiety : the " analyzing evaluator "
 ; generates code to produce the value of the expression
 ; produced by the first moiety.

 (xc i k) (\ e m (emf i (k e (+ m 1))))
 (xd x k) (\ e m (emx x (k e (+ m 1))))

 (emf i h) ((? (: q (tget fuse i)) q emi) i h)
 (Im x k) (:
  t (? (homp x) 'hom (nump x) 'num
       (twop x) 'two (vecp x) 'vec
       (symp x) 'sym (strp x) 'str
       (tblp x) 'tbl          'nil)
  (xc i-imm (xd x (-> t k))))

 ; these functions produce functions to do certain side effects
 ; with per-scope stack structures during code generation:
 ; either manipulating the stack or embedding the item at the
 ; top into the thread.
 (pushr s) (\ k (\ e m (>>= (k e m) (\ k (A (Ts e s (X k (Tg e s))))))))
 (popr s)  (\ k (\ e m (>>= (k e m) (\ k (, (Ts e s (B (Tg e s))) k)))))
 (peekr s) (\ k (\ e m (>>= (k e (+ m 1)) (\ k (emx (A (Tg e s)) k)))))

 push1 (pushr 's1) push2 (pushr 's2)
 pop1 (popr 's1) pop2 (popr 's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 ; these functions are for type checking
 (>- t k) (? (nilp t) k (:
  tcr (case t 'two i-id2 'num i-idZ
              'hom i-idH 'tbl i-idT
              (fail))
  (xc tcr k)))

 (-> t k) (\ e m (:
  (type e m t k) (:
   (== t h) (>>= t (consumes h) h (\ t u h (?
    (nilp u) h
    (= u t) (== t (hseek h 1))
    (fail))))
   (== t (k e m)))
  (? (nilp t) (k e m) (type e m t k))))

 (consumes h) (: i (hgeti h) (case i
  i-idH 'hom i-idZ 'num
  i-id2 'two i-idT 'tbl))

 (eval x k) (:
  (list x k) (:

   (cond x k) (:
    (loop x k) (:
     (fin e m) (:
      thd (k e (+ m 2))
      ex (A (tget e's2))
      i (hgeti ex)
      (? (= i i-ret) (emf i thd) ; forward return instructions
       (emf i-jump ; otherwise jump somewhere ...
        (emx (? (= i i-jump) (hgetx (hseek ex 1)) ex) thd))))
     (? (nilp (B x)) (eval (A x) fin)
      (eval (A x) (pop1 (xc i-branch (peek1
       (loop (BB x) (push1 (eval (AB x) fin)))))))))
    (pop2 (loop x (push2 k))))

   (lamb x k) (\ e m (:
    (nom e k) (: i (hgeti k) (case i
     i-tbind (hgetx (hseek k 1))
     i-loc_  (at (tget e'loc) (hgetx (hseek k 1)))))

    (clo-thd e x k) (:
     (loop x k) (? (nilp x) k
      (loop (B x) (eval (A x) (xc i-push k))))
     (k e m) (emi i-take (emx (len x) (hom (+ m 2))))
     ((loop x k) e 0))

    l ((-> 'hom k) e (+ m 2))
    y (ltu e (nom e l) x)
    (? (homp y) (emf i-imm (emx y l))
     (emi (? (tget e'loc) i-encll i-encln)
      (emx (X (B y) (clo-thd e (A y) k)) l)))))

   (seq x k) (? x (eval (A x) (seq (B x) k)) k)
   (app a b k) (:
    (loop x k) (? (nilp x) k
     (loop (B x) (eval (A x) (xc i-push k))))
    (? (&& (qtd a) (: q (tget inliners (unq a)))) (q b k)
     (loop b (eval a (>- 'hom (xc i-call (xd (len b) k)))))))

   (defn x k) (:
   ; the rewrite ensures the : expression is always an even form.
    (loop e x k) (? (nilp x) k (:
     l (loop e (BB x) k)
     m (? (nilp (|| (toplp e) (memq (tget e'loc) (A x)))) l
        (\ e m (? (toplp e) ((xc i-tbind (xd (A x) l)) e m)
                            ((xc i-loc_ (xd (idx (tget e'loc) (A x)) l)) e m))))
     (? (= 'here (A (: v (look e (A x)))))
      (Im (B v) m) (eval (AB x) m))))

    (\ e m ((loop e x k) e m)))

   z (A x) (case z
    '` (Im (AB x) k)
    '? (cond (B x) k)
    ': (defn (B x) k)
    '\ (lamb x k)
    ', (seq (B x) k)
    (app z (B x) k)))

  (symb x k) (\ e m (:
   (late e m x d k) (:
    ; the runtime encodes fundamental types as specific
    ; integer values.
    (t-code x) (case x
     'hom 0 'num 1 'two 2 'vec 3 'str 4
     'tbl 5 'sym 6 'nil 7 () 8 (fail))

    h (k e (+ m 2))
    t (consumes h)
    (emf i-lbind
     (emx (X (t-code t) (X d x))
      (? t (hseek h 1) h))))

   s (A (: r (look e x))) (?
    (= s'here) ((Im (B r) k) e m)
    (= s'wait) (late e m x (B r) k)
    (= e (B r)) (case s
     'arg ((xc i-arg (xd (idx (Tg e'arg) x) k)) e m)
     'loc ((xc i-loc (xd (idx (Tg e'loc) x) k)) e m)
     'clo ((xc i-clo (xd (idx (Tg e'clo) x) k)) e m))
    (, (: l (len (Tg e'clo)))
       (Ts e'clo(snoc (Tg e'clo) x))
       ((xc i-clo (xd l k)) e m)))))


  ((? (twop x) list (symp x) symb Im) x k))


 ; this is a table of specialized emitters for specific
 ; instructions that dynamically rewrite instruction sequences
 ; into semantically equivalent but lighter forms.
 fuse (:

  ; a common case is to rewrite the last emitted
  ; instruction or value according to an exact table
  ; of values
  (f1 g xs .) (\ i p (>>= (g p) (hseek p 1) (\ a q
   (: (loop xs) (? (nilp xs)    (emi i p)
                   (= a (A xs)) (emi (AB xs) q)
                   (loop (BB xs)))
   (loop xs)))))

  ; for specialized indexed instructions
  (argn a b) (f1 hgetx 0 a 1 b)

  ; for specialized branch instructions ;
  ; takes an argument for each branch case
  (br2 b c) (f1 hgeti i-branch b i-barnch c)

  (tbl
   ; this along with "return forwarding" in branches is how
   ; tail calls get optimized.
   i-call (\ i h (case (hgeti (hseek h 1))
    i-ret (emi i-rec (emx (hgetx h) (hseek h 1)))
    (emi i h)))
   i-arg (argn i-arg0 i-arg1)
   i-loc (argn i-loc0 i-loc1)
   i-clo (argn i-clo0 i-clo1)
   i-lt (br2 i-brlt i-brgteq)
   i-lteq (br2 i-brlteq i-brgt)
   i-gt (br2 i-brgt i-brlteq)
   i-gteq (br2 i-brgteq i-brlt)
   i-eq (br2 i-breq i-brne)
   i-nilpp (f1 hgeti i-branch i-barnch i-barnch i-branch)
   i-imm (f1 hgetx () i-unit 0 i-zero 1 i-one)))

 ; this is a table of specialized "subcompilers" for specific
 ; functions. they preserve the value semantics of an expression
 ; but may change its side effects by affecting which
 ; subexpressions are evaluated and in what order. they
 ; "inline" the function in the sense of replacing the code
 ; for the function call with a sequence of specialized
 ; instructions.
 inliners (:

  (mono f m x) (:
   (fold f m x) (? (nilp x) (L m)
    (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
     (: z (fold f m (B x)) (X (A z) (X y (B z))))))
   (? (= (f) (A (: j (fold f m x)))) (B j) j))

  (ordr i) (\ x k (?
   (nilp x) (Im () k)
   (nilp (B x)) (Im 1 k)
   (eval (A x) (:
    (fold k x y)
     (eval x (xc i (? (nilp y) (push2 k)
      (xc i-barnch (peek2 (xc i-push
       (fold k (A y) (B y))))))))
    (xc i-push (pop2 (fold k (AB x) (BB x))))))))

  (abel f i) (\ x k (>>= (mono f (f) x) (\ x
   (eval (A x) (>- 'num (2f i k (B x)))))))

  (0y i t0) (\ _ k (xc i (-> t0 k)))
  (1y i t0 t1) (\ x k
   (eval (A x) (>- t0 (xc i (-> t1 k)))))
  (2y i t0 t1 t2) (\ x k
   (eval (AB x) (>- t1 (xc i-push
    (eval (A x) (>- t0 (xc i (-> t2 k))))))))
  (2f i k x)
   (: (2g i k x xs)
       (xc i-push (eval x (>- 'num (xc i (2f i k xs)))))
    (? x (2g i k (A x) (B x)) (-> 'num k)))

  (3y i t0 t1 t2 t3) (\ x k
   (eval (A (BB x)) (>- t2
    (xc i-push (eval (AB x) (>- t1
     (xc i-push (eval (A x) (>- t0
      (xc i-tset (-> t3 k)))))))))))

  (tbl
   id (\ x k (eval (A x) k))
   + (abel + i-add)
   * (abel * i-mul)
   - (\ x k
    (? (nilp x) (Im 0 k)
       (nilp (B x)) ((1y i-neg 'num 'num) x k)
       (: y (mono + 0 (B x))
          z (? (nump (A x)) (mono - (A x) y) (X (A x) y))
        (? z (eval (A z) (>- 'num (2f i-sub k (B z))))
             (Im 0 k)))))
   L (\ x k (:
    loop (\ x k (? x (loop (B x) (xc i-push (eval (A x) (xc i-cons (-> 'two k))))) k))
    (Im () (loop x k))))

   / (\ x k
    (? (nilp x) (Im 1 k)
       (nilp (B x)) (eval (A x) (>- 'num k))
       (: b (mono * 1 (B x))
          c (? (nump (A x)) (mono / (A x) b) (X (A x) b))
        (? c (eval (A c) (>- 'num (2f i-dqv k (B c))))
             (Im 1 k)))))
   < (ordr i-lt) <= (ordr i-lteq)
   >= (ordr i-gteq) > (ordr i-gt)
   A (1y i-car 'two ())
   B (1y i-cdr 'two ())
   X (2y i-cons () () 'two)

   ;; be nice to the compiler
   emi  (2y i-emi 'num 'hom 'hom)
   emx  (2y i-emx () 'hom 'hom)
   tget (2y i-tget 'tbl () ())
   tset (3y i-tset 'tbl () () ())
   tlen (1y i-tlen 'tbl 'num)
   thas (2y i-thas 'tbl () ())

   = (\ x k (?
    (nilp x) (Im () k)
    (&& x (nilp (B x))) (Im 1 k)
    (? (: q (map (filter x qtd) unq)) (: r (A q)
      (any (B q) (\ v (nilp (= v r))))))
     (Im () k)
    (eval (A x) (xc i-push (? (BB x)
     (: fold (\ k x y
       (xc i-dupl (eval x (xc i-eq (? y
        (xc i-barnch (peek2 (fold k (A y) (B y))))
        k)))))
      (pop2 (fold (push2 k) (AB x) (BB x))))
     (eval (AB x) (xc i-eq k)))))))

   nilp (1y i-nilpp () ())
   fail (0y i-fail ())))

  (ini e m) ((xc i-ret (xd (Tg e'nom) (\ e m (hom m)))) e m)
  (ev x) (: e (env () () 'ev) (((eval (weak e x) ini) e 0) x))
  ;; end of compiler namespace ; now return the eval function
;  ev ; comment this line to define internals at toplevel
  ))))

; bootstrap
(ev lib) (ev egg) (ev lib) (ev egg)
; "drop privileges"
(each '(lib egg macros ns emi emx hom hseek hgeti hgetx hfin)
      (\ v (tdel ns v)))

; now prelude functions using ev
(: co (\ x .
 (ev(L'\'x(foldl x'x(\ m e(L(L'` e)m)))))))
