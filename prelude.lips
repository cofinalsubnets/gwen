(: local-vars '(local-vars old-ev prelude stage2 macros ns emi emx hom hom-seek hom-get-i hom-get-x hom-fin)
   old-ev ev
   prelude '(,
  ;; here's some data constructors
  (: X :: A *: B :* 
     li (\ . . .) ; dot only has special meaning following another argument, which can be dot
     ++ (\ a b(?(twop a)(X(A a)(++(B a)b))b)) ; append
     iota (\ n x .
      (: iota.l (\ m n (? (< m n) (X m (iota.l (+ m 1) n))))
       (? (nilp x) (iota.l 0 n) (iota.l n (A x)))))
     rho (\ n xs .
      (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
       (?(> n 0)(rho.l n xs)))))

  ;; here's some of your standard Functinal Progming stuf
  (: map (\ f x (? x (X (f (A x)) (map f (B x)))))
     foldl(\ z f x (? x (foldl (f z (A x)) f (B x)) z))
     foldr (\ z f x (? x (f (A x) (foldr z f (B x))) z))
     foldl1 (\ f x (foldl (A x) f (B x)))
     foldr1  (\ f x (? (B x) (f (A x) (foldr1 f (B x)))
                             (A x)))
     id (\ x x)
     each (\ x f (? x (,(f (A x)) (each (B x) f))))

     at (\ l n (? (< n 1) (A l) (at (B l) (- n 1))))
     atn (\ n (\ l (at l n)))
     flip (\ f (\ x y (f y x)))
     curry (\ f (\ x (\ y . (ap f (X x y))))))
  ;; and some list functions
  (: snoc  (\ l x (? (twop l) (X (A l) (snoc (B l) x))
                              (X x l)))
     init (\ l (? (B l) (X (A l) (init (B l)))))
     last (\ l (? (B l) (last (B l)) (A l)))

     rev (\ l (,
      (: rev.i (\ l m (? l (rev.i (B l) (X (A l) m)) m)))
      (rev.i l ())))
     ldel (\ l k (? l
      ((? (= k (A l)) id (\ m (X (A l) m)))
       (ldel (B l) k))))
     elem (\ l x (< -1 (idx l x)))
     ldiff (\ l m (?
      (nilp m) l
      (ldiff (ldel l (A m)) (B m))))
     idx (\ l x
      ((: .l (\ l x n (? (twop l) (? (= x (A l)) n (.l (B l) x (+ n 1))) -1)))
       l x 0))
     len (\ l (? (twop l) (+ 1 (len (B l))) 0)))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: defm (\ n x . (,(tset macros n (: v (ev (A x))))
                           (? (B x) (ap defm (B x)) v))))
   'AA (\ x (X A (X (X A (X x))))) 'AB (\ x (X A (X (X B (X x)))))
   'BA (\ x (X B (X (X A (X x))))) 'BB (\ x (X B (X (X B (X x)))))
   ; bind
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a .
    ((: case.i (\ x a
      (? a (? (B a) (li '? (li '= x (A a)) (A (B a))
                      (case.i x (B (B a))))
                     (A a))))) x a)))))

(ev prelude)

; ok now let's bootstrap a lisp compiler!
; we can do this by redefining ev at toplevel.
(: stage2 '(:
 env (\ a p n (>>=
  ((: asig (\ a n
       (? (twop a)
        (? (? (twop (B a)) (= '. (AB a)))
         (X (- (+ n 1)) (li (A a)))
         (>>= (asig (B a) (+ n 1)) (\ r
          (X (A r) (X (A a) (B r))))))
        (X n a)))) a 0) (\ b
  (tbl 'arg (B b) 'loc ()
       'clo ()     'par p
       'lam (tbl)  'nom n
       'val (tbl)  'sig (A b)))))

 fuse (tbl
  i-nilpp (\ i h (>>= (hom-get-i h) (\ j (case j
   i-branch (emi i-barnch (hom-seek h 1))
   i-barnch (emi i-branch (hom-seek h 1))
   (emi i h)))))
  )
 emif (\ i h ((? (: q (tget fuse i)) q emi) i h))

 inst (\ e m i k (emif i (k e (+ m 1))))
 insx (\ e m i x k (emif i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x (-> (t-tag x) k)))
 cev  (\ e m x k ((? (twop x) c2 (symp x) cy imm) e m x k))

 lfem (\ f (\ x . (\ e m (ap f (X e (X m x))))))
 kev (lfem cev)
 jnst (lfem inst)
 jnsx (lfem insx)

 cy (\ e m x k (:
  addclo (\ e y (tset e'clo(snoc (tget e 'clo) y)))
  late (\ e m x d k (>>= (k e (+ m 2)) (\ h
   (>>= (consumes h) (\ t
    (>>= (? t (hom-seek h 1) h) (\ h
     (emi i-lbind (emx (X (t-c t) (X d x)) h)))))))))
  r (look e x)
  s (A r)
  (? (= s 'here)  (imm e m (B r) k)
     (= s 'wait)  (late e m x (B r) k)
     (= e (B r)) (case s
      'arg (insx e m i-argn (idx (tget e 'arg) x) k)
      'loc (insx e m i-locn (idx (tget e'loc) x) k)
      'clo (insx e m i-clon (idx (tget e'clo) x) k))
     (,(: l (len (tget e'clo)))
       (addclo e x)
       (insx e m i-clon l k)))))

 cqt (\ e m x k (: y (B x) (imm e m (? y (A y)) k)))
 toplp (\ e (nilp (tget e'par)))
 look (\ e y
   (? (thas (tget e 'val) y) (X 'here (tget (tget e 'val) y))
      (< -1 (idx (tget e 'lam) y)) (X 'wait (tget e 'val))
      (< -1 (idx (tget e 'loc) y)) (X 'loc e)
      (< -1 (idx (tget e 'arg) y)) (X 'arg e)
      (< -1 (idx (tget e 'clo) y)) (X 'clo e)
      (tget e 'par) (look (tget e 'par) y)
      (thas ns y) (X 'here (tget ns y))
      (X 'wait ns)))
 >- (\ t k (? (: tc (tget t-checks t)) (jnst tc k) (fail)))

 cap (\ e m x k (:
   inline (\ x (case x
    A (\ e m x k
     (cev e m (AB x) (>- 'two (jnst i-car k))))
    B (\ e m x k
     (cev e m (AB x) (>- 'two (jnst i-cdr k))))
    X (\ e m x k
     (cev e m (? (: y (BB x)) (A y))
      (jnst i-push (kev (AB x) (jnst i-cons (-> 'two k))))))
    emi (\ e m x k
     (cev e m (A (BB x)) (>- 'hom
      (jnst i-push (kev (AB x) (>- 'num
       (jnst i-emi (-> 'hom k))))))))
    emx (\ e m x k
     (cev e m (A (BB x)) (>- 'hom
      (jnst i-push (kev (AB x)
       (jnst i-emx (-> 'hom k)))))))

#    tset (\ e m x k (>>= (B x) (\ x
#     (cev e m (A (BB x))
#      (jnst i-push (kev (AB x)
#       (jnst i-push (kev (A x) (>- 'tbl
#        (jnst i-tset k))))))))))

    nilp (\ e m x k (cev e m (AB x) (jnst i-nilpp k)))
     
    fail (\ e m x k (inst e m i-fail k))))
 (?
  (: q (inline (A x)))
   (q e m x k)
  ((: capi (\ e m x k
       (? (nilp x) (k e m)
        (capi e m (B x) (kev (A x) (jnst i-push k))))))

   e m (B x) (kev (A x) (>- 'hom (\ e m

    ((\ k l (?
      (nilp (= i-ret (hom-get-i k)))
       (emi i-call (emx l k))
      (>>= (hom-seek k 1) (\ k
       (? (= l (len (tget e 'arg)))
        (emi i-loop k)
        (emi i-rec (emx l k)))))))
     (k e (+ m 2))
     (len (B x))))))))))

 cse (\ e m x k (? (B x)
  ((: cser (\ e m x k (?
      (nilp x) (k e m)
               (cev e m (A x) (\ e m
                (cser e m (B x) k))))))
   e m (B x) k)
  (imm e m () k)))

 mat (\ e x (: y (look e x) (? (= (A y) 'here) (li (B y)))))
 cde (\ e m x k
  (: desug (\ d (li (li '\ (li ', (init d) (last d)))))
     cder (\ e m x k (? (nilp x) (k e m) (?
      (>>= (\ e m (cder e m (BB x) k)) (\ k
       (? (|| (toplp e) (< -1 (idx (tget e 'loc) (A x))))
           (cev e m (AB x) (\ e m (cdeb e m (A x) k)))
          (: q (mat e (A x)))
           (imm e m (A q) k)
           (cev e m (A x) k)))))))
     cdeb (\ e m x k (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (tget e 'loc) x) k)))
   (? (nilp (B x)) (imm e m () k)
      (= 1 (% (len (B x)) 2)) (cev e m (desug x) k)
      (cder e m (B x) k))))

 cco (\ e m x k
  (: ccopreant (\ e m k (>>= (k e (+ m 2)) (\ k
      (>>= (emi i-branch (emx (A (tget e 's1)) k)) (\ k
       (, (tset e 's1 (B (tget e 's1))) k))))))
     ccopre (\ e m k (>>= (k e m) (\ k
      (A (tset e 's2 (X k (tget e 's2)))))))
     ccoprecon (\ e m k (>>= (k e (+ m 2)) (\ x
      (>>= (A (tget e 's2)) (\ k
       (: i (hom-get-i k) (case i
        (? (= i i-ret) (emi i x)
         (emi i-jump
          (emx (? (= i i-jump) (hom-get-x (hom-seek k 1)) k) x))))))))))
     ccopostcon (\ e m k (>>= (k e m) (\ k
      (A (tset e 's1 (X k (tget e 's1)))))))
     ; unlike in the bootstrap compiler, here we can
     ; assume there are an odd number of arguments, ie.
     ; at least 1. this is assured by peco. thanks peco!
     ccor (\ e m x k (?
      (nilp (B x)) (cev e m (A x) ((lfem ccoprecon) k))
      (cev e m (A x)
       ((lfem ccopreant)
        ((lfem ccor) (BB x)
         ((lfem ccopostcon)
          (kev (AB x) ((lfem ccoprecon) k))))))))
   (? (nilp (B x)) (imm e m () k)
    ((\ k (, (tset e 's2 (B (tget e 's2))) k))
     (ccor e m (B x) (\ e m (ccopre e m k)))))))


 quote (\ x (? (qtd x) x (li '` x)))
 pey (\ e x (: l (look e x)
  (? (= (A l) 'here) (quote (B l)) x)))
 pede (\ e x
  (: peder (\ e x (? x
      (X (A x) (X (pev e (AB x)) (peder e (BB x))))))
   (X ': (? (|| (nilp x) (= 1 (% (len x) 2))) x (peder e x)))))
 pesq (\ e x (,
  (: pesqr (\ e x (?
   (nilp (B x)) (li (pev e (A x)))
   (: y (pev e (A x))
      z (pesqr e (B x))
    (? (|| (symp y) (qtd y)) z (X y z))))))
  (: y (B x) (? y
   (: z (pesqr e y) (? (B z) (X ', z) (A z)))))))

 ; this rewrites lambda expressions of the form
 ;   (\ (: a b c)) -> (\ (, (: a b) c))
 ; which is always safe and produces better code.
 pla (\ e l
  (: defp (\ x (? (twop x) (= (A x) ':)))
     deftp (\ x (? (defp x) (= 0 (% (len x) 2))))
     trlamp (\ l (? (B l) (deftp (last l))))
     rwlam (\ l (>>= (last l) (\ m (snoc (init l) (li ', (init m) (last m))))))
   (? (trlamp l) (rwlam l) l)))

 pe2 (\ e x (: a (A x) (case a
  '` x
  '\ (pla e x)
  ': (pede e (B x))
  '? (peco e (B x))
  ', (pesq e x)
  (? (thas macros a)
      (pev e (ap (tget macros a) (B x)))
     (map (\ x (pev e x)) x)))))

 pcomm (\ e f m x (?  (nilp x) (li m) (,
  (: y (pev e (A x)))
  (? (nump y) (pcomm e f (f m y) (B x))
   (, (: z (pcomm e f m (B x)))
      (!* z (X y (B z)))
      z)))))

 qtd (\ x (? (twop x) (= (A x) '`) (nilp (symp x))))
 unq (\ x (? (twop x) (AB x) x))
 peco (\ e x
  (: pecor (\ e x (?
      (nilp x) (li ())
      (nilp (B x)) (li (pev e (A x)))
      (: a (pev e (A x))
       (? (qtd a) (? (unq a) (li (pev e (AB x)))
                             (pecor e (BB x)))
        (X a (X (pev e (A (B x))) (pecor e (BB x))))))))
   (: r (pecor e x) (? r (? (B r) (X '? r) (A r))))))

 pev (\ e x (?
  (twop x) (pe2 e x)
  (symp x) (pey e x)
  (quote x)))
 prev (\ e x m (cev e m (pev e x) ini))

 ltu (\ e nom l
  (: n (|| (B l) '(()))
     x (last n)
     f (env (init n) e (X nom (tget e 'nom)))
   (, (scan f x)
      (resolve f)
      (>>= (prev f x 4) (\ k
       (>>= (? (nilp (tget f 'loc)) k
              (emi i-prel (emx (len (tget f 'loc)) k))) (\ k
        (>>= (hom-fin (?
             (> (: i (tget f 'sig)) 0) (emi i-arity (emx i k))
             (< i 0) (emi i-vararg (emx (- (- i) 1) k))
             k)) (\ k
         (? (tget f 'clo) (X (tget f 'clo) k) k))))))))))

 resolve (\ e
  (: precomps (\ e ks (? ks
      (: k (A ks) i (ltu e k (tget (tget e 'lam) k)) (,
       (? (homp i) (, (tset (tget e 'val) k i)
                      (tdel (tget e 'lam) k)
                      (tset e'loc(ldel (tget e 'loc) k)))
                   (, (!* i (tget (tget e 'lam) k))
                      (tset (tget e 'lam) k i)))
       (precomps e (B ks))))))

     okvs (\ e vs (?
      (nilp vs) 0
      (: v (A vs)
       (? (|| (thas (tget e 'lam) v) (thas (tget e'val) v))
          (okvs e (B vs))))))

     elim (\ e ks (? ks (>>= (A ks) (\ k (?
      (nilp (okvs e (A (tget (tget e 'lam) k))))
       (, (tdel (tget e'lam) k) (elim e (tkeys (tget e'lam))))
      (elim e (B ks)))))))

     recomps (\ e d ks (? ks (: k (A ks) (,
      (tset e 'loc (ldel (tget e 'loc) k))
      (tset (tget e 'val) k (ltu e k (B (tget d k))))
      (recomps e d (B ks))))))

   (, (precomps e (tkeys (tget e 'lam)))
      (elim e (tkeys (tget e'lam)))
      (: ls (tget e 'lam) (recomps e ls (tset e 'lam (tkeys ls)))))))

 scan (\ e x
  (: scandef (\ e x (?
      (nilp x) 0
      (B x) ((\ r (, (? r (scandefadd e (A x) (AB x))) r))
              (scandef e (BB x)))))
     mcar (\ x (? x (A x)))
     addloc (\ e y (tset e 'loc (X y (tget e 'loc))))

     scandefadd (\ e y x (,
      (? (symp x) (addloc e y)
         (twop x) (>>= (A x) (\ z (case z
          '` (tset (tget e'val) y (mcar (B x)))
          '\ (, (tset (tget e'lam) y x) (addloc e y))
          (addloc e y))))
         (tset (tget e'val) y x))
      (scan e x)))

   (? (twop x) (: y (A x) (case y
    ': (scandef e (B x))
    '\ () '` ()
    (each x (\ x (scan e x))))))))

 t-tag (\ x (?
  (homp x) 'hom (nump x) 'num
  (twop x) 'two ;(tupp x) t-tup
  (symp x) 'sym (strp x) 'oct
  (tblp x) 'tbl (nilp x) 'nil))
 t-c (\ x (case x
  'hom 0 'num 1 'two 2 'tup 3 'oct 4
  'tbl 5 'sym 6 'nil 7 () 8
  (fail)))
 t-checks (tbl
  i-tchom 'hom 'hom i-tchom
  i-tcnum 'num 'num i-tcnum
  i-tctwo 'two 'two i-tctwo)

 ; this function has a lot of arguments sorry...
 ; env, len, type, cont, xpn.
 produces (\ e m t k (,
   (: type (\ t h
     ((\ t u (case u t (type t (hom-seek h 1))
                   () h
                   (fail)))
      t (consumes h))))
  (type t (k e m))))
 -> (\ t k (\ e m (produces e m t k)))
 consumes (\ h (? (: c (tget t-checks (hom-get-i h))) c))

 cla (\ e m x k
  (: gnom (\ e k (: i (hom-get-i k) (case i
      i-tbind (hom-get-x (hom-seek k 1))
      i-setl  (at (tget e'loc) (hom-get-x (hom-seek k 1))))))

     claclo (\ e arg
      (: clacloin (\ e arg k (? (nilp arg) k
          (clacloin e (B arg) (\ e m
           (cev e m (A arg) (jnst i-push k))))))
         k (\ e m (emi i-take (emx (len arg) (hom (+ m 2)))))
       ((clacloin e arg k) e 0)))

   (>>= (produces e (+ m 2) 'hom k) (\ k
    (>>= (ltu e (gnom e k) x) (\ x (?
     (homp x) (emi i-immv (emx x k))
     (emi (? (tget e'loc) i-encll i-encln)
      (emx (X (B x) (claclo e (A x))) k)))))))))

 forms(tbl '` cqt '? cco ': cde '\ cla ', cse)
 c2 (\ e m x k (: z (tget forms (A x)) ((? z z cap) e m x k)))
 ini (\ e m (insx e m i-ret (tget e'nom) (\ e m (hom m))))
 eval (\ x ((prev (env () () 'ev) x 0)x))
 eval ; comment this line to have compiler internals defined at toplevel
 ))

(tset ns 'ev ((\ q ((ev q) q)) stage2))

(? (= old-ev ev) (fail "bootstrap failed")
                 (ev prelude))
(each local-vars (\ s (tdel ns s)))
