(: local-vars '(local-vars old-ev lib egg s0 s1 s2 macros ns emi emx hom hseek hgeti hom-get-x hfin)
   lib '(,
  ;; here's some data constructors
  (:
     Tg tget Ts tset
     and (\ l (? l (? (A l) (and (B l))) 0))
     && (\ l . (and l))
     or (\ l (? l (: a (A l) (? a a (or (B l))))))
     || (\ l . (or l))
     L (\ . . .) ; dot only has special meaning following another argument, which can be dot
     ++ (: append (\ a b (? a(X(A a)(append(B a)b))b))
      (\ a . (foldr () append a)))
     iota (\ n x .
      (: iota.l (\ m n (? (< m n) (X m (iota.l (+ m 1) n))))
       (? (nilp x) (iota.l 0 n) (iota.l n (A x)))))
      rho (\ n xs .
       (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
        (?(> n 0)(rho.l n xs)))))

  ;; here's some of your standard Functinal Progming stuf
  (: map (\ f x (? x ((\ f x y (X (f (A x)) y))
                      f x (map f (B x)))))
     foldl(\ z f x (? x (foldl (f z (A x)) f (B x)) z))
     foldr (\ z f x (? x (f (A x) (foldr z f (B x))) z))
     foldl1 (\ f x (foldl (A x) f (B x)))
     foldr1  (\ f x (? (B x) (f (A x) (foldr1 f (B x)))
                             (A x)))

     curry (\ f x . (\ y . (ap f (++ x y))))
     |-> (\ xs . (: t (ap tbl xs)
                    @ (\ x (? (thas t x) (tget t x)
                              (fail)))))
     uniq (\ l (:
      u.l (\ x l (?
       (nilp l) x
       (elem x (A l)) (u.l x (B l))
       (u.l (X (A l) x) (B l))))
      (u.l () l)))

     id (\ x x)
     each (\ x f (? x (,(f (A x)) (each (B x) f))))
     all (\ p l (? l (? (p (A l)) (all p (B l))) 0))
     any (\ p l (? l (? (p (A l)) 0 (any p (B l)))))
     partition (\ p l (? (nilp l) '(())
      (: a (A l) m (partition p (B l))
       (? (p a) (X (X a (A m)) (B m))
                (X (A m) (X a (B m)))))))

     filter (\ f x (? x ((\ a y
      (? (f a) (X a y) y)) (A x) (filter f (B x)) )))
     at (\ l n (? (< n 1) (A l) (at (B l) (- n 1))))
     atn (\ n (\ l (at l n)))
     flip (\ f (\ x y (f y x)))
     {set} (\ x . (: d (tbl) (, (each x (\ y (tset d y ()))) d))))
  ;; and some list functions
  (: snoc  (\ l x (? l (X (A l) (snoc (B l) x))
                       (X x)))
     init (\ l (? (B l) (X (A l) (init (B l)))))
     last (\ l (? (B l) (last (B l)) (A l)))

     rev (\ l
      ((: rev.i (\ l m (? l (rev.i (B l) (X (A l) m)) m))) l()))
     ldel (\ l k (? l
      ((? (= k (A l)) id (\ m (X (A l) m)))
       (ldel (B l) k))))
     elem (\ l x (< -1 (idx l x)))
     ldiff (\ l m (? m (ldiff (ldel l (A m)) (B m)) l))
     idx (\ l x
      ((: .l (\ l x n (? l (? (= x (A l)) n (.l (B l) x (+ n 1))) -1)))
       l x 0))
     len (\ l (? l (+ 1 (len (B l))) 0)))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: defm (\ n x . (,(tset macros n (: v (ev (A x))))
                           (? (B x) (ap defm (B x)) v))))
   'AA (\ x (X A (X (X A (X x))))) 'AB (\ x (X A (X (X B (X x)))))
   'BA (\ x (X B (X (X A (X x))))) 'BB (\ x (X B (X (X B (X x)))))
   'immediate (\ x (ev x))
   '&& (\ x . ((: & (\ x
     (? (B x) (L '? (A x) (& (B x))) (A x)))) x))
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a .
    ((: case.i (\ x a
      (? a (? (B a) (L '? (L '= x (A a)) (A (B a))
                      (case.i x (B (B a))))
                     (A a))))) x a)))


  ))

(: egg '(: ev (:
 env (\ a p n (>>=
  ((: asig (\ a n
       (? a
        (? (? (B a) (= '. (AB a)))
         (X (- (+ n 1)) (L (A a)))
         (>>= (asig (B a) (+ n 1)) (\ r
          (X (A r) (X (A a) (B r))))))
        (X n a)))) a 0) (\ b
  (tbl 'arg (B b) 'par p
       'nom n
       'val (tbl) 'sig (A b)
       'def (tbl)))))

  t-c (immediate (|->
   'hom 0 'num 1 'two 2 'vec 3 'oct 4
   'tbl 5 'sym 6 'nil 7 () 8))


 qtd (\ x (? (twop x) (= (A x) '`) (nilp (symp x))))
 unq (\ x (? (twop x) (AB x) x))
 fuse (:
  f1 (\ g xs . (\ i p (>>= (g p) (hseek p 1) (\ a q
   ((: loop (\ xs (? xs
     (? (= a (A xs)) (emi (AB xs) q) (loop (BB xs)))
     (emi i p)))) xs)))))

  argr (\ a b (f1 hgetx 0 a 1 b))
  br2 (\ b c (f1 hgeti i-branch b i-barnch c))
  (tbl
   i-argn (argr i-arg0 i-arg1)
   i-locn (argr i-loc0 i-loc1)
   i-clon (argr i-clo0 i-clo1)
   i-lt (br2 i-brlt i-brgteq) i-lteq (br2 i-brlteq i-brgt)
   i-gt (br2 i-brgt i-brlteq) i-gteq (br2 i-brgteq i-brlt)
   i-eq (br2 i-breq i-brne)
   i-nilpp (f1 hgeti i-branch i-barnch i-barnch i-branch)
   i-call (\ i h (>>= (hgeti (hseek h 1)) (\ j (case j
    i-ret (emi i-rec (emx (hgetx h) (hseek h 1)))
    (emi i h)))))
   i-immv (f1 hgetx () i-unit 0 i-zero 1 i-one)))

 emif (\ i h ((? (: q (tget fuse i)) q emi) i h))

 inst (\ e m i k (emif i (k e (+ m 1))))
 insx (\ e m i x k (emif i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x (-> (t-tag x) k)))
 immk (\ x k (code i-immv (data x (-> (t-tag x) k))))

 eval (\ x k ((? (twop x) ev-list (symp x) ev-sym immk) x k))
 code (\ i k (\ e m (inst e m i k)))
 data (\ x k (\ e m (emx x (k e (+ m 1)))))


 ev-sym (\ x k (\ e m (:

  late (\ e m x d k (:
   h (k e (+ m 2))
   t (consumes h)
   (emif i-lbind (emx (X (t-c t) (X d x))
                     (? t (hseek h 1) h)))))

  s (A (: r (look e x)))
  (case s
   'here (imm e m (B r) k)
   'wait  (late e m x (B r) k)
   (? (= e (B r))
    (case s 'arg (insx e m i-argn (idx (tget e'arg) x) k)
            'loc (insx e m i-locn (idx (tget e'loc) x) k)
            'clo (insx e m i-clon (idx (tget e'clo) x) k))
    (, (: l (len (tget e'clo)))
       (tset e'clo(snoc (tget e'clo) x))
       (insx e m i-clon l k)))))))

 toplp (\ e (nilp (tget e'par)))
 look (\ e y (?
  (thas (tget e 'val) y)
   (X 'here (tget (tget e'val) y))
  (toplp e) (?
   ; if it's already defined then bind early unless we are
   ; redefining it.
   (? (thas ns y) (nilp (thas (tget e'def) y)))
    (X 'here (tget ns y))
   (X 'wait ns))
  (elem (tget e'clo) y) (X 'clo e)
  (elem (tget e'dfr) y) (X 'wait (tget e'val))
  (thas (tget e'def) y) (X 'loc e)
  (elem (tget e'arg) y) (X 'arg e)
  (look (tget e'par) y)))

 assert (\ e m t k (>>= (k e m) (: type (\ h (:
  u (consumes h)
  (case u () h
          t (type (hseek h 1))
          (fail)))))))

 t-checks (tbl
  i-idhom 'hom 'hom i-idhom
  i-idnum 'num 'num i-idnum
  i-idtwo 'two 'two i-idtwo
  i-idtbl 'tbl 'tbl i-idtbl)

 consumes (\ h (? (: c (tget t-checks (hgeti h))) c))
 >- (\ t k (? (: tc (tget t-checks t)) (code tc k) (fail)))
 -> (\ t k (\ e m (assert e m t k)))

 pushr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (A (tset e s (X k (tget e s)))))))))
 popr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (, (tset e s (B (tget e s))) k))))))
 peekr (\ s (\ k (\ e m (>>= (k e (+ m 1)) (\ k
  (emx (A (tget e s)) k))))))

 push1 (pushr 's1) push2 (pushr 's2)
 pop1 (popr 's1) pop2 (popr 's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 ev-ap (\ x k (:
  ev-api (\ x k (? (nilp x) k
   (ev-api (B x) (eval (A x) (code i-push k)))))
  (>>= (A x) (B x) (\ z x (?
   (? (qtd z) (: q (tget inliners (unq z))))
    (q x k)
   (ev-api x (eval z (>- 'hom
    (code i-call (data (len x) k))))))))))

 ev-seq (\ x k
  ((: ev-seqr (\ x k
       (? (nilp x) k (eval (A x) (ev-seqr (B x) k)))))
    (B x) k))

 cde (\ e m x k
 ; the rewrite ensures the : expression is always an even form.
  (: cder (\ x k (? (nilp x) k (>>= (cder (BB x) k) (\ k
   (>>= (? (|| (toplp e) (< -1 (idx (tget e'loc)(A x))))
         (cdeb (A x) k) k) (\ k (? (= 'here (A (: v (look e (A x)))))
          (immk (B v) k) (eval (AB x) k))))))))
     cdeb (\ x k (\ e m (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (tget e 'loc) x) k))))
    ((cder (B x) k) e m)))

 ev-if (\ x k (:

  ccoprecon (\ k (\ e m
   (>>= (k e (+ m 2)) (\ x
    (>>= (A (tget e 's2)) (\ brx
     (: i (hgeti brx) (case i
      (? (= i i-ret) (emif i x)
       (emif i-jump
        (emx (? (= i i-jump) (hgetx (hseek brx 1)) brx) x)))))))))))

  ccor (\ x k (?
   (nilp (B x)) (eval (A x) (ccoprecon k))
   (eval (A x) (pop1 (code i-branch (peek1
     (ccor (BB x) (push1 (eval (AB x) (ccoprecon k))))))))))

  (pop2 (ccor (B x) (push2 k)))))


 quote (\ x (? (qtd x) x (L '` x)))
 l-exp? (\ x (? (twop x) (= '\ (A x))))
 ; this rewrites lambda expressions of the form
 ;   (\ (: a b c)) -> (\ (, (: a b) c))
 ; which is always safe and produces better code.

 abelians (immediate (tbl && 1 || () + 0 * 1))
 monoids (immediate (tbl scat "" ++ ()))
 pures (immediate ({set}
  L X A B + - * / % id flip ++ iota rho |->
  snoc init last rev ldel elem at idx ldiff len
  homp nilp symp nump tblp strp twop vecp
  && || scat slen sget ssub str))

 monofold (\ f i l (:
  mfold (\ f i j x y
   (? y (? (qtd x) (mfold f i (f j (unq x)) (A y) (B y))
                   (: z (X x (mfold f i i (A y) (B y)))
                    (? (= i j) z (X j z))))
      (qtd x) (>>= (f j (unq x)) (\ x (? (= i x)()(L x))))
      (= i j) (L x)
      (L j x)))
  (? l (X f (mfold f i i (A l) (B l))) (quote i))))

 ev-la (\ x k (:
  gnom (\ e k (: i (hgeti k) (case i
   i-tbind (hgetx (hseek k 1))
   i-setl  (at (tget e'loc) (hgetx (hseek k 1))))))

  claclo (\ e arg (:
   clacloin (\ e arg k (?
    (nilp arg) k
    (clacloin e (B arg)
     (eval (A arg) (code i-push k)))))
   ((clacloin e arg (\ e m
     (emif i-take (emx (len arg) (hom (+ m 2))))))
    e 0)))
  (\ e m (>>= (assert e (+ m 2) 'hom k) (\ k
   (>>= (ltu e (gnom e k) x) (\ x (?
    (homp x) (emif i-immv (emx x k))
    (emif (? (tget e'loc) i-encll i-encln)
     (emx (X (B x) (claclo e (A x))) k))))))))))

 inliners (:
  grp (\ f m id x
   (: fold (\ f m x (? (nilp x) (X m)
             (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
                                  (>>= (fold f m (B x)) (\ z
                                   (X (A z) (X y (B z))))))))
    (? (= id (A (: j (fold f m x)))) (B j) j)))

  ordr (\ i (\ x k (?
   (nilp x) (immk 0 k)
   (eval (A x) (? (nilp (B x)) k
    (: fold (\ k x y
      (eval x (code i (? (nilp y) (push2 k)
       (code i-barnch (peek2 (code i-push
        (fold k (A y) (B y)))))))))
     (code i-push (pop2 (fold k (AB x) (BB x))))))))))
  bf0 (\ i k x
   (: fold (\ i k x xs
       (code i-push (eval x (>- 'num (code i (bf0 i k xs))))))
    (? x (fold i k (A x) (B x)) (-> 'num k))))

  abel (\ f z i (\ x k (>>= (grp f z z x) (\ x
   (eval (A x) (>- 'num (bf0 i k (B x))))))))

  (tbl
   + (abel + 0 i-add)
   * (abel * 1 i-mul)
   - (\ x k
    (? (nilp x) (immk 0 k)
       (nilp (B x)) (eval (A x) (>- 'num (code i-neg (-> 'num k))))
       (: y (grp + 0 0 (B x))
          z (? (nump (A x)) (grp - (A x) 0 y) (X(A x)y))
        (? z (eval (A z) (>- 'num (bf0 i-sub k (B z))))
             (immk 0 k)))))
   id (\ x k (eval (A x) k))
   L (\ x k (: l (\ x k (? x (l (B x) (code i-push (eval (A x) (code i-cons (-> 'two k))))) k))
    (immk () (l x k))))
                
   / (\ x k
    (? (nilp x) (immk 1 k)
       (nilp (B x)) (eval (A x) (>- 'num k))
       (: b (grp * 1 1 (B x))
          c (? (nump (A x)) (grp / (A x) 1 b) (X (A x) b))
        (? c (eval (A c) (>- 'num (bf0 i-dqv k (B c))))
             (immk 1 k)))))
   <  (ordr i-lt) <= (ordr i-lteq) >= (ordr i-gteq) > (ordr i-gt)
   A (\ x k (eval (A x) (>- 'two (code i-car k))))
   B (\ x k (eval (A x) (>- 'two (code i-cdr k))))
   X (\ x k (eval (? (: y (B x)) (A y))
             (code i-push (eval (A x)
              (code i-cons (-> 'two k))))))

   ;; be nice to the compiler
   emi (\ x k
    (eval (AB x) (>- 'hom
     (code i-push (eval (A x) (>- 'num
      (code i-emi (-> 'hom k))))))))
   emx (\ x k
    (eval (AB x) (>- 'hom
     (code i-push (eval (A x)
      (code i-emx (-> 'hom k)))))))
    tget (\ x k
     (eval (AB x) (code i-push
      (eval (A x) (>- 'tbl (code i-tget k))))))

    tset (\ x k
     (eval (A (BB x))
      (code i-push (eval (AB x)
       (code i-push (eval (A x) (>- 'tbl
        (code i-tset k))))))))

   = (\ x k (?
    (? (: q (map unq (filter qtd x))) (: r (A q)
      (any (\ v (nilp (= v r))) (B q))))
     (immk () k)
    (? x (nilp (B x)) 0) (immk 0 k)
    (eval (A x) (code i-push (? (BB x)
     (: fold (\ k x y
       (code i-dupl (eval x (code i-eq (? y
        (code i-barnch (peek2 (fold k (A y) (B y))))
        k)))))
      (pop2 (fold (push2 k) (AB x) (BB x))))
     (eval (AB x) (code i-eq k)))))))

    && (\ x k (?
     (nilp x) (immk 0 k)
     (any nilp x) (immk () k)
     (: fold (\ x y k
       (eval x (? (nilp y) k (code i-barnch
        (peek2 (fold (A y) (B y) k))))))
      (pop2 (fold (A x) (B x) (push2 k))))))
   nilp (\ x k (eval (A x) (code i-nilpp k)))
   fail (\ x k (code i-fail k))))

 rw (\ e x  (:

  rw-list (\ e x (:
   rw-arity (\ x (: z (A x) (?
    (nilp (? (homp z) (= i-arity (hgeti z)))) x
    (? (>= (len (B x)) (hgetx (hseek z 1)))
     (X (hseek z 2) (B x))
     (ap z (B x)); this immediately causes an arity error.
     ))))
   rw-let (\ e x (:
    desug (\ d (L (L '\ (L ', (init d) (last d)))))
    loop (\ e x (? x
     (: ll (loop e (BB x))
      (X (A x) (X (tget (tget e'def) (A x)) ll)))))
    (? (B x) (? (= 0 (% (len x) 2)) (desug x)
                (X ': (loop e (B x)))))))
   rw-lam (\ e l (:
    defp (\ x (? (twop x) (= (A x) ':)))
    deftp (\ x (? (defp x) (= 0 (% (len x) 2))))
    trlamp (\ l (? (B l) (deftp (last l))))
    rw-lamm (\ l (>>= (last l) (\ m (snoc (init l) (L ', (init m) (last m))))))
    (? (trlamp l) (rw-lamm l) l)))

   a (A x)
   (case a
    '` (? (B x) x)
    '\ (rw-lam e x)
    ': (rw-let e x)
    '? (rw-if e (B x))
    ', (rw-seq e x)
    (? (thas macros a)
        (rw e (ap (tget macros a) (B x)))
       (: z (map (\ x (rw e x)) x) q (A z) r (B z) (?
        (nilp (thas pures q)) (rw-arity z)
        (all qtd r) (quote (ap q (map unq r)))
        (thas monoids q) (monofold q (tget monoids q) r)
        (thas abelians q) (:
         ff (partition qtd r)
         fg (ap q (map unq (A ff)))
         (X q (? (= fg (tget abelians q)) (B ff)
               (X fg (B ff)))))
        (rw-arity z)))))))

  rw-if (\ e x (:
   rw-ifr (\ e x (?
    (nilp x) (L ())
    (nilp (B x)) (L (rw e (A x)))
    (: a (rw e (A x))
     (? (qtd a) (? (unq a) (L (rw e (AB x)))
                           (rw-ifr e (BB x)))
      (X a (X (rw e (A (B x))) (rw-ifr e (BB x))))))))
   (: r (rw-ifr e x) (? r (? (B r) (X '? r) (A r))))))

  rw-sym (\ e x (: l (look e x) (?
   (= (A l) 'here) (quote (B l))
   (nilp (thas (: defs (tget e'def)) x)) x
   (: dd (rw e (tdel defs x))
    (? (nilp (qtd (tset defs x dd))) x
     (, (loc-del e x)
        (tset (tget e'val) x (unq dd))
        dd))))))

  rw-seq (\ e x (:
   rw-seqr (\ e x (?
    (nilp (B x)) (L (rw e (A x)))
     (: z (rw-seqr e (B x))
        y (rw e (A x))
      (? (|| (symp y) (qtd y)) z (X y z)))))
   (? (: y (B x))
      (: z (rw-seqr e y) (? (B z) (X ', z) (A z))))))



 (? (twop x) (rw-list e x)
             (symp x) (rw-sym e x)
             (quote x))))

 rwmap (\ f x (X (A x) (f (B x))))
 rwX (\ a b (X (uniq (++ (A a) (A b))) (X (B a) (B b))))

 rw2 (\ e x (:
  rwy (\ e x (: l (look e x) (?
   (= (A l) 'here) (rwq e (B l))
   (nilp (thas (: defs (tget e'def)) x)) (X (L x) x)
   (: d2 (rw2 e (tdel defs x)) rr (B d2)
    (, (? (qtd (tset defs x rr))
        (, (loc-del e x)
           (tset (tget e'val) x (unq rr))))
       d2)))))
 rwl (\ e x (: a (.'a (A x)) (case a
  ', (rwsq e x)
  (foldr '(()) (\ x m
   (rwX (rw2 e x) m)) x))))
  rwsq (\ e x (:
   rwsqr (\ e x (: y (rw2 e (A x)) (?
    (nilp (B x)) (rwmap L y)
    (: z (rwsqr e (B x))
     (? (|| (symp (B y)) (qtd (B y))) z (rwX y z))))))
   (? (: y (B x))
      (: z (rwsqr e y) (rwmap (\ q (? q (X', q))) z)))))
  rwq (\ e x (X () (quote x)))

  (? (twop x) (rwl e x)
     (symp x) (rwy e x)
     (rwq e x))))



 ltu (\ e nom l (:
  with-locals (\ e k (? (: loc (tget e 'loc))
                        (emif i-prel (emx (len loc) k)) k))
  with-arity (\ f k (?
   (> (: i (tget f 'sig)) 0) (emif i-arity (emx i k))
   (< i 0) (emif i-vararg (emx (- (- i) 1) k))
   k))
  fx (rewrl e nom l)
  f (A fx) x (B fx) arg (tget f'arg)
  (? (&& (twop x) (homp (A x))
      (>= (tget f 'sig) 0) (= (B x) arg))
   (A x) ; in this case the function is an alias for (A x)
   (>>= (hfin (with-arity f (with-locals f
         ((eval x ini) f 4)))) (\ k
    (? (tget f 'clo) (X (tget f 'clo) k) k))))))


 rewrl (\ e nom l (:
  n (|| (B l) '(()))
  arg (init n)
  f (env (init n)e (X nom (tget e'nom)) nom)
  x (last n)
  (, (scan f x) (X f (rw f x)))))

 scan (\ e x (:
  scanr (\ e x (:
   sdef (\ e x (?
    (nilp x) 0
    (B x) (>>= (sdef e (BB x)) (\ r (,
           (? r (sdefa e (A x) (AB x)))
           r)))))

   sdefa (\ e y x (,
    (? (qtd x) (tset (tget e'val) y (unq x))
          (tset (tget e'def) y x))
    (scanr e x)))

   (? (twop x) (: y (A x) (case y
    '\ () '` ()
    ': (sdef e (B x))
    (each x (\ x (scanr e x))))))))
  (, (scanr e x) (resolve e))))

 loc-del (\ e k (, (tdel (tget e'def) k)))
 resolve (\ e (:

  pc2 (\ e kvs (? kvs (:
   kv (A kvs) rr (pc2 e (B kvs))
   (? (homp (: i (ltu e (: k (A kv)) (: v (B kv)))))
    (, (tset (tget e 'val) k i) (loc-del e k) rr)
    (X (X k (X (A i) v)) rr)))))

  pkvs (\ e i vs (?
   (nilp vs) 1
   (: v (A vs) (?
    (|| (any (\ j (= (A j) v)) i) (thas (tget e'val) v))
     (pkvs e i (B vs))))))

  elis (\ e i kvs q (?
   (nilp kvs) q
   (: kv (A kvs) (?
    (nilp (pkvs e i (AB kv)))
     (>>= (ldel i kv) (\ j (elis e j j ())))
    (elis e i (B kvs) (X kv q))))))

  dfr-add (\ e k (tset e'dfr (X k (tget e'dfr))))

  rc2 (\ e kvs (? kvs (: kv (A kvs) k (A kv) (,
   (loc-del e k)
   (dfr-add e k)
   (rc2 e (B kvs))
   (tset (tget e'val) k (ltu e k (BB kv)))))))


  pvs (\ e kvs (? kvs (: kv (A kvs) k (A kv) (?
   (thas (tget e'val) k)
    (pvs e (B kvs))
   (>>= (rw e (B kv)) (\ qq (: bb (pvs e (B kvs)) (?
    (qtd (tset (tget e'def) k qq))
     (, (tset (tget e'val) k (unq qq))
        (loc-del e k)
        bb)
    (l-exp? qq)
     (X (X k qq) bb)
    bb))))))))

  tkvs (\ t (map (\ k (X k (tget t k))) (tkeys t)))

  (? (> (tlen (: def (tget e'def))) 0) (,
   (rc2 e (: pcs (pc2 e (pvs e (map
                  (\ k (X k (tget def k)))
                  (tset e'loc (tkeys def)))))
           (elis e pcs pcs ())))
   (tset e'loc (tkeys def))))))

 t-tag (\ x (?
  (homp x) 'hom (nump x) 'num
  (twop x) 'two (vecp x) 'vec
  (symp x) 'sym (strp x) 'oct
  (tblp x) 'tbl          'nil))

 ev-qt (\ x k (immk (AB x) k))
 ev-de (\ x k (\ e m (cde e m x k)))
 ev-list (\ x k (: z (A x) ((case z
  '` ev-qt
  '? ev-if
  ': ev-de
  '\ ev-la
  ', ev-seq
  ev-ap) x k)))
 ini (\ e m (insx e m i-ret (tget e'nom) (\ e m (hom m))))
 ev (\ x (: e (env () () 'ev)
  (((eval (, (scan e x) (rw e x)) ini) e 0) x)))

; ev
 )))

; bootstrap
(ev lib) (ev egg) ; C -> prelips
(ev lib) (ev egg) ; prelips -> lips
(each local-vars (\ v (tdel ns v)))
