(: local-vars '(local-vars old-ev lib egg s0 s1 s2 macros ns emi emx hom hseek hgeti hom-get-x hfin)
   lib '(,
  ;; here's some data constructors
  (: and (\ l (? l (? (A l) (and (B l))) 0))
     && (\ l . (and l))
     or (\ l (? l (: a (A l) (? a a (or (B l))))))
     || (\ l . (or l))
     L (\ . . .) ; dot only has special meaning following another argument, which can be dot
     ++ (\ a b(?(twop a)(X(A a)(++(B a)b))b)) ; append
     iota (\ n x .
      (: iota.l (\ m n (? (< m n) (X m (iota.l (+ m 1) n))))
       (? (nilp x) (iota.l 0 n) (iota.l n (A x)))))
     rho (\ n xs .
      (: rho.l(\ n x(?(= n 1)x(++ x(rho.l(- n 1)x))))
       (?(> n 0)(rho.l n xs)))))

  ;; here's some of your standard Functinal Progming stuf
  (: map (\ f x (? x (X (f (A x)) (map f (B x)))))
     foldl(\ z f x (? x (foldl (f z (A x)) f (B x)) z))
     foldr (\ z f x (? x (f (A x) (foldr z f (B x))) z))
     foldl1 (\ f x (foldl (A x) f (B x)))
     foldr1  (\ f x (? (B x) (f (A x) (foldr1 f (B x)))
                             (A x)))
     id (\ x x)
     each (\ x f (? x (,(f (A x)) (each (B x) f))))

     filter (\ f x (? x ((\ a y
      (? (f a) (X a y) y)) (A x) (filter f (B x)) )))
     at (\ l n (? (< n 1) (A l) (at (B l) (- n 1))))
     atn (\ n (\ l (at l n)))
     flip (\ f (\ x y (f y x)))
     curry (\ f (\ x (\ y . (ap f (X x y))))))
  ;; and some list functions
  (: snoc  (\ l x (? (twop l) (X (A l) (snoc (B l) x))
                              (X x l)))
     init (\ l (? (B l) (X (A l) (init (B l)))))
     last (\ l (? (B l) (last (B l)) (A l)))

     rev (\ l (,
      (: rev.i (\ l m (? l (rev.i (B l) (X (A l) m)) m)))
      (rev.i l ())))
     ldel (\ l k (? l
      ((? (= k (A l)) id (\ m (X (A l) m)))
       (ldel (B l) k))))
     elem (\ l x (< -1 (idx l x)))
     ldiff (\ l m (?
      (nilp m) l
      (ldiff (ldel l (A m)) (B m))))
     idx (\ l x
      ((: .l (\ l x n (? (twop l) (? (= x (A l)) n (.l (B l) x (+ n 1))) -1)))
       l x 0))
     len (\ l (? (twop l) (+ 1 (len (B l))) 0)))

  ;; and some marcos
  (tset macros
   ; a macro for defining macros
   '::: (: defm (\ n x . (,(tset macros n (: v (ev (A x))))
                           (? (B x) (ap defm (B x)) v))))
   'AA (\ x (X A (X (X A (X x))))) 'AB (\ x (X A (X (X B (X x)))))
   'BA (\ x (X B (X (X A (X x))))) 'BB (\ x (X B (X (X B (X x)))))
   ; bind
   '>>= (\ x . (X (last x) (init x)))
   'case (\ x a .
    ((: case.i (\ x a
      (? a (? (B a) (L '? (L '= x (A a)) (A (B a))
                      (case.i x (B (B a))))
                     (A a))))) x a)))))


(: egg '(:
 env (\ a p n (>>=
  ((: asig (\ a n
       (? (twop a)
        (? (? (twop (B a)) (= '. (AB a)))
         (X (- (+ n 1)) (L (A a)))
         (>>= (asig (B a) (+ n 1)) (\ r
          (X (A r) (X (A a) (B r))))))
        (X n a)))) a 0) (\ b
  (tbl 'arg (B b) 'loc ()
       'clo ()     'par p
       'lam (tbl)  'nom n
       'val (tbl)  'sig (A b)))))

 brr (\ b (\ i h (>>= (hgeti h) (\ j (case j
  i-branch (emi b (hseek h 1)) (emi i h))))))
 argr (\ _0 _1 (\ i h (>>= (hgetx h) (\ x (case x
  0 (emi _0 (hseek h 1))
  1 (emi _1 (hseek h 1))
  (emi i h))))))
 fuse (tbl
  i-argn (argr i-arg0 i-arg1)
  i-locn (argr i-loc0 i-loc1)
  i-clon (argr i-clo0 i-clo1)
  i-lt (brr i-brlt) i-lteq (brr i-brlteq)
  i-gt (brr i-brgt) i-gteq (brr i-brgteq)
  i-eq (brr i-breq)
  i-nilpp (\ i h (>>= (hgeti h) (\ j (case j
   i-branch (emi i-barnch (hseek h 1))
   i-barnch (emi i-branch (hseek h 1))
   (emi i h)))))
  i-call (\ i h (>>= (hgeti (hseek h 1)) (\ j (case j
   i-ret (emi i-rec (emx (hgetx h) (hseek h 1)))
   (emi i h)))))
  i-immv (\ i h (>>= (hseek h 1) (\ q
   (>>= (hgeti q) (hgetx h) (\ j x (?
    (? (? (= j i-call) 0 (= j i-rec))
       (? ((: arity-check (\ a
           (? (homp a) (? (= (hgeti a) i-arity) (?
             (<= (hgetx (hseek a 1))
                 (hgetx (hseek q 1))) 0
             (fail)))))) (hgetx h))))
     (emi i (emx (hseek (hgetx h) 2) q))
    (case x
     () (emi i-unit q) 0 (emi i-zero q)
     1 (emi i-one q) (emi i h)))))))))

 emif (\ i h ((? (: q (tget fuse i)) q emi) i h))

 inst (\ e m i k (emif i (k e (+ m 1))))
 insx (\ e m i x k (emif i (emx x (k e (+ m 2)))))
 imm  (\ e m x k (insx e m i-immv x (-> (t-tag x) k)))
 immk (\ x k (code i-immv (data x (-> (t-tag x) k))))

 eval (\ x k ((? (twop x) eval-list (symp x) eval-sym immk) x k))
 code (\ i k (\ e m (inst e m i k)))
 data (\ x k (\ e m (emx x (k e (+ m 1)))))

 t-c (\ x (case x
  'hom 0 'num 1 'two 2 'vec 3 'oct 4
  'tbl 5 'sym 6 'nil 7 () 8 (fail)))

 late (\ e m x d k (>>= (k e (+ m 2)) (\ h
  (>>= (consumes h) (\ t
   (>>= (? t (hseek h 1) h) (\ h
    (emif i-lbind (emx (X (t-c t) (X d x)) h)))))))))

 eval-sym (\ x k (\ e m (:
  r (look e x)
  s (A r)
  (case s
   'here (imm e m (B r) k)
   'wait  (late e m x (B r) k)
   (? (= e (B r))
    (case s 'arg (insx e m i-argn (idx (tget e 'arg) x) k)
            'loc (insx e m i-locn (idx (tget e'loc) x) k)
            'clo (insx e m i-clon (idx (tget e'clo) x) k))
    (, (: l (len (tget e'clo)))
       (tset e'clo(snoc (tget e'clo) x))
       (insx e m i-clon l k)))))))

 toplp (\ e (nilp (tget e'par)))
 look (\ e y (?
  (thas (tget e 'val) y) (X 'here (tget (tget e 'val) y))
  (toplp e) (?
   ; if it's already defined then bind early unless we are
   ; redefining it.
   (? (thas ns y) (nilp (elem (tget e'loc) y)))
    (X 'here (tget ns y))
   (X 'wait ns))
  (elem (tget e'lam) y) (X 'wait (tget e 'val))
  (elem (tget e'loc) y) (X 'loc e)
  (elem (tget e'arg) y) (X 'arg e)
  (elem (tget e'clo) y) (X 'clo e)
  (look (tget e 'par) y)))

 >- (\ t k (? (: tc (tget t-checks t)) (code tc k) (fail)))
 -> (\ t k (\ e m (assert e m t k)))

 group (\ f m id x
  (: fold (\ f m x (? (nilp x) (X m)
            (? (qtd (: y (A x))) (fold f (f m (unq y)) (B x))
                                 (>>= (fold f m (B x)) (\ z
                                  (X (A z) (X y (B z))))))))
   (? (= id (A (: j (fold f m x)))) (B j) j)))

 bf0 (\ i k x
  (: bf (\ i k x xs
      (code i-push (eval x (>- 'num (code i (bf0 i k xs))))))
   (? x (bf i k (A x) (B x)) (-> 'num k))))

 pushr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (A (tset e s (X k (tget e s)))))))))
 popr (\ s (\ k (\ e m (>>= (k e m) (\ k
  (, (tset e s (B (tget e s))) k))))))
 peekr (\ s (\ k (\ e m (>>= (k e (+ m 1)) (\ k
  (emx (A (tget e s)) k))))))

 push1 (pushr 's1) push2 (pushr 's2)
 pop1 (popr 's1) pop2 (popr 's2)
 peek1 (peekr 's1) peek2 (peekr 's2)

 ordr (\ i (\ x k (?
  (nilp x) (code i-zero k)
  (eval (A x) (? (nilp (B x)) k
   (: fold (\ k x y
     (eval x (code i (? (nilp y) (push2 k)
      (code i-barnch (peek2 (code i-push
       (fold k (A y) (B y)))))))))
    (code i-push (pop2 (fold k (AB x) (BB x))))))))))

 inliners (tbl
  <  (ordr i-lt) <= (ordr i-lteq) >= (ordr i-gteq) > (ordr i-gt)
  A (\ x k (eval (A x) (>- 'two (code i-car k))))
  B (\ x k (eval (A x) (>- 'two (code i-cdr k))))
  X (\ x k (eval (? (: y (B x)) (A y))
            (code i-push (eval (A x)
             (code i-cons (-> 'two k))))))

  ;; be nice to the compiler
  emi (\ x k
   (eval (AB x) (>- 'hom
    (code i-push (eval (A x) (>- 'num
     (code i-emi (-> 'hom k))))))))
  emx (\ x k
   (eval (AB x) (>- 'hom
    (code i-push (eval (A x)
     (code i-emx (-> 'hom k)))))))
  + (\ x k (>>= (group + 0 0 x) (\ x
   (eval (A x) (>- 'num (bf0 i-add k (B x)))))))
  * (\ x k (>>= (group * 1 1 x) (\ x
   (eval (A x) (>- 'num (bf0 i-mul k (B x)))))))
         
  - (\ x k
   (? (nilp x)
       (immk 0 k)
      (nilp (B x))
       (eval (A x) (>- 'num (code i-neg (-> 'num k))))
      (: y (group + 0 0 (B x))
         z (? (nump (A x)) (group - (A x) 0 y) (X(A x)y))
       (? z (eval (A z) (>- 'num (bf0 i-sub k (B z))))
            (immk 0 k)))))
   tget (\ x k
    (eval (AB x) (code i-push
     (eval (A x) (>- 'tbl (code i-tget k))))))

   tset (\ x k
    (eval (A (BB x))
     (code i-push (eval (AB x)
      (code i-push (eval (A x) (>- 'tbl
       (code i-tset k))))))))
  = (\ x k (?
   (? (: q (map unq (filter qtd x))) (: r (A q)
     (any (\ v (nilp (= v r))) (B q))))
    (code i-unit k)
   (? x (nilp (B x)) 0) (code i-zero k)
   (eval (A x) (code i-push (? (BB x)
    (: fold (\ k x y
      (code i-dupl (eval x (code i-eq (? y
       (code i-barnch (peek2 (fold k (A y) (B y))))
       k)))))
     (pop2 (fold (push2 k) (AB x) (BB x))))
    (eval (AB x) (code i-eq k)))))))

   && (\ x k (?
    (nilp x) (code i-zero k)
    (any nilp x) (code i-unit k)
    (: fold (\ x y k 
      (eval x (? (nilp y) k (code i-barnch
       (peek2 (fold (A y) (B y) k))))))
     (pop2 (fold (A x) (B x) (push2 k))))))
  nilp (\ x k (eval (A x) (code i-nilpp k)))
  fail (\ x k (code i-fail k)))

 eval-apply (\ x k (:
  eval-applyi (\ x k (? (nilp x) k
   (eval-applyi (B x) (eval (A x) (code i-push k)))))
  (>>= (A x) (B x) (\ z x
   (? (: q (tget inliners z))
    (q x k)
   (eval-applyi x (eval z (>- 'hom (code i-call (data (len x) k))))))))))

 eval-seq (\ x k
  ((: eval-seqr (\ x k (? (nilp x) k (eval (A x) (eval-seqr (B x) k)))))
    (B x) k))

 cde (\ e m x k
 ; the rewrite ensures the : expression is always an even form.
  (: cder (\ x k (? (nilp x) k (>>= (cder (BB x) k) (\ k
     (? (|| (toplp e) (< -1 (idx (tget e 'loc) (A x))))
         (eval (AB x) (cdeb (A x) k))
        (eval (A x) k))))))
     cdeb (\ x k (\ e m (?
      (toplp e) (insx e m i-tbind x k)
                (insx e m i-setl (idx (tget e 'loc) x) k))))
    ((cder (B x) k) e m)))

 eval-if (\ x k (:

  ccoprecon (\ k (\ e m
   (>>= (k e (+ m 2)) (\ x
    (>>= (A (tget e 's2)) (\ brx
     (: i (hgeti brx) (case i
      (? (= i i-ret) (emif i x)
       (emif i-jump
        (emx (? (= i i-jump) (hgetx (hseek brx 1)) brx) x)))))))))))

  ccor (\ x k (?
   (nilp (B x)) (eval (A x) (ccoprecon k))
   (eval (A x) (pop1 (code i-branch (peek1
     (ccor (BB x) (push1 (eval (AB x) (ccoprecon k))))))))))

  (pop2 (ccor (B x) (push2 k)))))


 quote (\ x (? (qtd x) x (L '` x)))
 rw-sym (\ e x (: l (look e x)
  (? (= (A l) 'here) (quote (B l)) x)))

 rw-let (\ e x
  (: desug (\ d (L (L '\ (L ', (init d) (last d)))))
     sdefa (\ e y x
      (? (qtd x) (tset (tget e'val) y (unq x))
         (, (tset e'loc(X y (tget e'loc)))
            (? (twop x) (? (= '\ (A x))
             (tset (tget e'lam) y x))))))
     loop (\ e x (? x
      (: z (rw e (AB x)) y (A x)
       (, (sdefa e y z)
          (X y (X z (loop e (BB x))))))))
   (? (B x) (?
    (= 0 (% (len x) 2)) (desug x)
    (X ': (loop e (B x)))))))

 rw-seq (\ e x (:
  rw-seqr (\ e x (?
   (nilp (B x)) (L (rw e (A x)))
    (: y (rw e (A x))
       z (rw-seqr e (B x))
     (? (|| (symp y) (qtd y)) z (X y z)))))
  (? (: y (B x))
     (: z (rw-seqr e y) (? (B z) (X ', z) (A z))))))

 ; this rewrites lambda expressions of the form
 ;   (\ (: a b c)) -> (\ (, (: a b) c))
 ; which is always safe and assert better code.
 rw-lam (\ e l
  (: defp (\ x (? (twop x) (= (A x) ':)))
     deftp (\ x (? (defp x) (= 0 (% (len x) 2))))
     trlamp (\ l (? (B l) (deftp (last l))))
     rw-lamm (\ l (>>= (last l) (\ m (snoc (init l) (L ', (init m) (last m))))))
   (? (trlamp l) (rw-lamm l) l)))

 pures (L L X A B + - * / %
          homp nilp symp nump tblp strp twop
          && || scat slen sget ssub str)
 all (\ p l (? l (? (p (A l)) (all p (B l))) 0))
 any (\ p l (? l (? (p (A l)) 0 (any p (B l)))))
 rw-list (\ e x (: a (A x) (case a
  '` (? (B x) x)
  '\ (rw-lam e x)
  ': (rw-let e x)
  '? (rw-if e (B x))
  ', (rw-seq e x)
  (? (thas macros a)
      (rw e (ap (tget macros a) (B x)))
     (? (all qtd (: z (map (\ x (rw e x)) x)))
      (? (elem pures (A z))))
       (quote (ap (A z) (map unq (B z))))
     z))))

 qtd (\ x (? (twop x) (= (A x) '`) (nilp (symp x))))
 unq (\ x (? (twop x) (AB x) x))
 rw-if (\ e x
  (: rw-ifr (\ e x (?
      (nilp x) (L ())
      (nilp (B x)) (L (rw e (A x)))
      (: a (rw e (A x))
       (? (qtd a) (? (unq a) (L (rw e (AB x)))
                             (rw-ifr e (BB x)))
        (X a (X (rw e (A (B x))) (rw-ifr e (BB x))))))))
   (: r (rw-ifr e x) (? r (? (B r) (X '? r) (A r))))))

 rw (\ e x (?
  (twop x) (rw-list e x)
  (symp x) (rw-sym e x)
  (quote x)))

 ev-part (\ e x m (>>= (rw e x) (\ x (,
  (resolve e)
  ((eval x ini)e m)))))

 ltu (\ e nom l
  (: n (|| (B l) '(()))
     x (last n)
     f (env (init n) e (X nom (tget e 'nom)))
   (,
      (>>= (ev-part f x 4) (\ k
       (>>= (? (nilp (tget f 'loc)) k
              (emif i-prel (emx (len (tget f 'loc)) k))) (\ k
        (>>= (hfin (?
             (> (: i (tget f 'sig)) 0) (emif i-arity (emx i k))
             (< i 0) (emif i-vararg (emx (- (- i) 1) k))
             k)) (\ k
         (? (tget f 'clo) (X (tget f 'clo) k) k))))))))))

 resolve (\ e
  (: precomps (\ e ks (? ks
      (: k (A ks) i (ltu e k (tget (tget e 'lam) k)) (,
       (? (homp i) (, (tset (tget e 'val) k i)
                      (tdel (tget e 'lam) k)
                      (tset e'loc(ldel (tget e 'loc) k)))
                   (: lams (tget e'lam)
                         j (X (A i) (tget lams k))
                       (tset lams k j)))
       (precomps e (B ks))))))

     okvs (\ e vs (?
      (nilp vs) 0
      (: v (A vs)
       (? (|| (thas (tget e 'lam) v) (thas (tget e'val) v))
          (okvs e (B vs))))))

     elim (\ e ks (? ks (>>= (A ks) (\ k (?
      (nilp (okvs e (A (tget (tget e 'lam) k))))
       (, (tdel (tget e'lam) k) (elim e (tkeys (tget e'lam))))
      (elim e (B ks)))))))

     recomps (\ e d ks (? ks (: k (A ks) (,
      (tset e 'loc (ldel (tget e 'loc) k))
      (tset (tget e 'val) k (ltu e k (B (tget d k))))
      (recomps e d (B ks))))))

   (, (precomps e (tkeys (tget e 'lam)))
      (elim e (tkeys (tget e'lam)))
      (: ls (tget e 'lam) (recomps e ls (tset e 'lam (tkeys ls)))))))

 t-tag (\ x (?
  (homp x) 'hom (nump x) 'num
  (twop x) 'two (vecp x) 'vec
  (symp x) 'sym (strp x) 'oct
  (tblp x) 'tbl (nilp x) 'nil))
 t-checks (tbl
  i-idhom 'hom 'hom i-idhom
  i-idnum 'num 'num i-idnum
  i-idtwo 'two 'two i-idtwo
  i-idtbl 'tbl 'tbl i-idtbl)

 ; this function has a lot of arguments sorry...
 ; env, len, type, cont, xpn.
 assert (\ e m t k (,
   (: type (\ t h
     ((\ t u (case u () h
                     t (type t (hseek h 1))
                     (fail)))
      t (consumes h))))
  (type t (k e m))))
 consumes (\ h (? (: c (tget t-checks (hgeti h))) c))

 eval-lam (\ x k (:
  gnom (\ e k (: i (hgeti k) (case i
   i-tbind (hgetx (hseek k 1))
   i-setl  (at (tget e'loc) (hgetx (hseek k 1))))))

  claclo (\ e arg (:
   clacloin (\ e arg k (?
    (nilp arg) k
    (clacloin e (B arg)
     (eval (A arg) (code i-push k)))))
   ((clacloin e arg (\ e m
     (emif i-take (emx (len arg) (hom (+ m 2))))))
    e 0)))
  (\ e m (>>= (assert e (+ m 2) 'hom k) (\ k
   (>>= (ltu e (gnom e k) x) (\ x (?
    (homp x) (emif i-immv (emx x k))
    (emif (? (tget e'loc) i-encll i-encln)
     (emx (X (B x) (claclo e (A x))) k))))))))))

 eval-qt (\ x k (immk (AB x) k))
 eval-let (\ x k (\ e m (cde e m x k)))
 eval-list (\ x k (: z (A x) ((case z
  '` eval-qt
  '? eval-if
  ': eval-let
  '\ eval-lam
  ', eval-seq
  eval-apply) x k)))

 ini (\ e m (insx e m i-ret (tget e'nom) (\ e m (hom m))))
 ev (\ x ((ev-part (env () () 'ev) x 0)x))
 ev))

(ev lib)
(: ev (ev egg))
(ev lib)
(: ev (ev egg))
(each local-vars (\ v (tdel ns v)))
